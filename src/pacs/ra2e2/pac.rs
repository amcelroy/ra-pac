#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (d771c7b 2025-03-27))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "0 - ICU Interrupt 0"]
    IEL0 = 0,
    #[doc = "1 - ICU Interrupt 1"]
    IEL1 = 1,
    #[doc = "2 - ICU Interrupt 2"]
    IEL2 = 2,
    #[doc = "3 - ICU Interrupt 3"]
    IEL3 = 3,
    #[doc = "4 - ICU Interrupt 4"]
    IEL4 = 4,
    #[doc = "5 - ICU Interrupt 5"]
    IEL5 = 5,
    #[doc = "6 - ICU Interrupt 6"]
    IEL6 = 6,
    #[doc = "7 - ICU Interrupt 7"]
    IEL7 = 7,
    #[doc = "8 - ICU Interrupt 8"]
    IEL8 = 8,
    #[doc = "9 - ICU Interrupt 9"]
    IEL9 = 9,
    #[doc = "10 - ICU Interrupt 10"]
    IEL10 = 10,
    #[doc = "11 - ICU Interrupt 11"]
    IEL11 = 11,
    #[doc = "12 - ICU Interrupt 12"]
    IEL12 = 12,
    #[doc = "13 - ICU Interrupt 13"]
    IEL13 = 13,
    #[doc = "14 - ICU Interrupt 14"]
    IEL14 = 14,
    #[doc = "15 - ICU Interrupt 15"]
    IEL15 = 15,
    #[doc = "16 - ICU Interrupt 16"]
    IEL16 = 16,
    #[doc = "17 - ICU Interrupt 17"]
    IEL17 = 17,
    #[doc = "18 - ICU Interrupt 18"]
    IEL18 = 18,
    #[doc = "19 - ICU Interrupt 19"]
    IEL19 = 19,
    #[doc = "20 - ICU Interrupt 20"]
    IEL20 = 20,
    #[doc = "21 - ICU Interrupt 21"]
    IEL21 = 21,
    #[doc = "22 - ICU Interrupt 22"]
    IEL22 = 22,
    #[doc = "23 - ICU Interrupt 23"]
    IEL23 = 23,
    #[doc = "24 - ICU Interrupt 24"]
    IEL24 = 24,
    #[doc = "25 - ICU Interrupt 25"]
    IEL25 = 25,
    #[doc = "26 - ICU Interrupt 26"]
    IEL26 = 26,
    #[doc = "27 - ICU Interrupt 27"]
    IEL27 = 27,
    #[doc = "28 - ICU Interrupt 28"]
    IEL28 = 28,
    #[doc = "29 - ICU Interrupt 29"]
    IEL29 = 29,
    #[doc = "30 - ICU Interrupt 30"]
    IEL30 = 30,
    #[doc = "31 - ICU Interrupt 31"]
    IEL31 = 31,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    extern "C" {
        fn IEL0();
        fn IEL1();
        fn IEL2();
        fn IEL3();
        fn IEL4();
        fn IEL5();
        fn IEL6();
        fn IEL7();
        fn IEL8();
        fn IEL9();
        fn IEL10();
        fn IEL11();
        fn IEL12();
        fn IEL13();
        fn IEL14();
        fn IEL15();
        fn IEL16();
        fn IEL17();
        fn IEL18();
        fn IEL19();
        fn IEL20();
        fn IEL21();
        fn IEL22();
        fn IEL23();
        fn IEL24();
        fn IEL25();
        fn IEL26();
        fn IEL27();
        fn IEL28();
        fn IEL29();
        fn IEL30();
        fn IEL31();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    pub static __INTERRUPTS: [Vector; 32] = [
        Vector { _handler: IEL0 },
        Vector { _handler: IEL1 },
        Vector { _handler: IEL2 },
        Vector { _handler: IEL3 },
        Vector { _handler: IEL4 },
        Vector { _handler: IEL5 },
        Vector { _handler: IEL6 },
        Vector { _handler: IEL7 },
        Vector { _handler: IEL8 },
        Vector { _handler: IEL9 },
        Vector { _handler: IEL10 },
        Vector { _handler: IEL11 },
        Vector { _handler: IEL12 },
        Vector { _handler: IEL13 },
        Vector { _handler: IEL14 },
        Vector { _handler: IEL15 },
        Vector { _handler: IEL16 },
        Vector { _handler: IEL17 },
        Vector { _handler: IEL18 },
        Vector { _handler: IEL19 },
        Vector { _handler: IEL20 },
        Vector { _handler: IEL21 },
        Vector { _handler: IEL22 },
        Vector { _handler: IEL23 },
        Vector { _handler: IEL24 },
        Vector { _handler: IEL25 },
        Vector { _handler: IEL26 },
        Vector { _handler: IEL27 },
        Vector { _handler: IEL28 },
        Vector { _handler: IEL29 },
        Vector { _handler: IEL30 },
        Vector { _handler: IEL31 },
    ];
}
#[doc = "Renesas Memory Protection Unit"]
pub const RMPU: rmpu::Rmpu = unsafe { rmpu::Rmpu::from_ptr(0x4000_0000usize as _) };
#[doc = "SRAM Control"]
pub const SRAM: sram::Sram = unsafe { sram::Sram::from_ptr(0x4000_2000usize as _) };
#[doc = "BUS Control"]
pub const BUS: bus::Bus = unsafe { bus::Bus::from_ptr(0x4000_3000usize as _) };
#[doc = "Data Transfer Controller"]
pub const DTC: dtc::Dtc = unsafe { dtc::Dtc::from_ptr(0x4000_5400usize as _) };
#[doc = "ICU for CPU"]
pub const ICU: icu::Icu = unsafe { icu::Icu::from_ptr(0x4000_6000usize as _) };
#[doc = "Debug Function"]
pub const DBG: dbg::Dbg = unsafe { dbg::Dbg::from_ptr(0x4001_b000usize as _) };
#[doc = "System Control"]
pub const SYSC: sysc::Sysc = unsafe { sysc::Sysc::from_ptr(0x4001_e000usize as _) };
#[doc = "Port 0 Control Registers"]
pub const PORT0: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0000usize as _) };
#[doc = "Port 1 Control Registers"]
pub const PORT1: port1::Port1 = unsafe { port1::Port1::from_ptr(0x4004_0020usize as _) };
#[doc = "Port 2 Control Registers"]
pub const PORT2: port1::Port1 = unsafe { port1::Port1::from_ptr(0x4004_0040usize as _) };
#[doc = "Port 3 Control Registers"]
pub const PORT3: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0060usize as _) };
#[doc = "Port 4 Control Registers"]
pub const PORT4: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0080usize as _) };
#[doc = "Port 9 Control Registers"]
pub const PORT9: port0::Port0 = unsafe { port0::Port0::from_ptr(0x4004_0120usize as _) };
#[doc = "Pmn Pin Function Control Register"]
pub const PFS: pfs::Pfs = unsafe { pfs::Pfs::from_ptr(0x4004_0800usize as _) };
#[doc = "Event Link Controller"]
pub const ELC: elc::Elc = unsafe { elc::Elc::from_ptr(0x4004_1000usize as _) };
#[doc = "Port Output Enable Module for GPT"]
pub const POEG: poeg::Poeg = unsafe { poeg::Poeg::from_ptr(0x4004_2000usize as _) };
#[doc = "Watchdog Timer"]
pub const WDT: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4004_4200usize as _) };
#[doc = "Independent Watchdog Timer"]
pub const IWDT: iwdt::Iwdt = unsafe { iwdt::Iwdt::from_ptr(0x4004_4400usize as _) };
#[doc = "Clock Frequency Accuracy Measurement Circuit"]
pub const CAC: cac::Cac = unsafe { cac::Cac::from_ptr(0x4004_4600usize as _) };
#[doc = "Module Stop Control B, C, D"]
pub const MSTP: mstp::Mstp = unsafe { mstp::Mstp::from_ptr(0x4004_7000usize as _) };
#[doc = "Data Operation Circuit"]
pub const DOC: doc::Doc = unsafe { doc::Doc::from_ptr(0x4005_4100usize as _) };
#[doc = "12-bit A/D Converter"]
pub const ADC120: adc120::Adc120 = unsafe { adc120::Adc120::from_ptr(0x4005_c000usize as _) };
#[doc = "Serial Communication Interface 0"]
pub const SCI9: sci9::Sci9 = unsafe { sci9::Sci9::from_ptr(0x4007_0120usize as _) };
#[doc = "Serial Peripheral Interface"]
pub const SPI0: spi0::Spi0 = unsafe { spi0::Spi0::from_ptr(0x4007_2000usize as _) };
#[doc = "Cyclic Redundancy Check Calculator"]
pub const CRC: crc::Crc = unsafe { crc::Crc::from_ptr(0x4007_4000usize as _) };
#[doc = "General PWM 16-bit Timer 4"]
pub const GPT164: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8400usize as _) };
#[doc = "General PWM 16-bit Timer 5"]
pub const GPT165: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8500usize as _) };
#[doc = "General PWM 16-bit Timer 6"]
pub const GPT166: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8600usize as _) };
#[doc = "General PWM 16-bit Timer 7"]
pub const GPT167: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8700usize as _) };
#[doc = "General PWM 16-bit Timer 8"]
pub const GPT168: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8800usize as _) };
#[doc = "General PWM 16-bit Timer 9"]
pub const GPT169: gpt164::Gpt164 = unsafe { gpt164::Gpt164::from_ptr(0x4007_8900usize as _) };
#[doc = "Output Phase Switching Controller"]
pub const GPT_OPS: gpt_ops::GptOps = unsafe { gpt_ops::GptOps::from_ptr(0x4007_8ff0usize as _) };
#[doc = "Key Interrupt Function"]
pub const KINT: kint::Kint = unsafe { kint::Kint::from_ptr(0x4008_0000usize as _) };
#[doc = "I3C Bus Interface"]
pub const I3C: i3c::I3c = unsafe { i3c::I3c::from_ptr(0x4008_3000usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 0"]
pub const AGTW0: agtw0::Agtw0 = unsafe { agtw0::Agtw0::from_ptr(0x4008_4000usize as _) };
#[doc = "Low Power Asynchronous General Purpose Timer 1"]
pub const AGTW1: agtw0::Agtw0 = unsafe { agtw0::Agtw0::from_ptr(0x4008_4100usize as _) };
#[doc = "Flash I/O Registers"]
pub const FLCN: flcn::Flcn = unsafe { flcn::Flcn::from_ptr(0x407e_c000usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 2;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
pub mod adc120 {
    #[doc = "12-bit A/D Converter"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Adc120 {
        ptr: *mut u8,
    }
    unsafe impl Send for Adc120 {}
    unsafe impl Sync for Adc120 {}
    impl Adc120 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A/D Control Register"]
        #[inline(always)]
        pub const fn adcsr(self) -> crate::common::Reg<regs::Adcsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "A/D Channel Select Register A0"]
        #[inline(always)]
        pub const fn adansa0(self) -> crate::common::Reg<regs::Adansa0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "A/D Channel Select Register A1"]
        #[inline(always)]
        pub const fn adansa1(self) -> crate::common::Reg<regs::Adansa1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "A/D,Converted Value Addition/Average Channel Select Register 0"]
        #[inline(always)]
        pub const fn adads0(self) -> crate::common::Reg<regs::Adads0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "A/D,Converted Value Addition/Average Channel Select Register 1"]
        #[inline(always)]
        pub const fn adads1(self) -> crate::common::Reg<regs::Adads1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "A/D,Converted Value Addition/Average Count Select Register"]
        #[inline(always)]
        pub const fn adadc(self) -> crate::common::Reg<regs::Adadc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "A/D Control Extended Register"]
        #[inline(always)]
        pub const fn adcer(self) -> crate::common::Reg<regs::Adcer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "A/D Conversion Start Trigger Select Register"]
        #[inline(always)]
        pub const fn adstrgr(self) -> crate::common::Reg<regs::Adstrgr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "A/D Conversion Extended Input Control Registers"]
        #[inline(always)]
        pub const fn adexicr(self) -> crate::common::Reg<regs::Adexicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "A/D Channel Select Register B0"]
        #[inline(always)]
        pub const fn adansb0(self) -> crate::common::Reg<regs::Adansb0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "A/D Channel Select Register B1"]
        #[inline(always)]
        pub const fn adansb1(self) -> crate::common::Reg<regs::Adansb1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x16usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register"]
        #[inline(always)]
        pub const fn addbldr(self) -> crate::common::Reg<regs::Addbldr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "A/D Temperature Sensor Data Register"]
        #[inline(always)]
        pub const fn adtsdr(self) -> crate::common::Reg<regs::Adtsdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "A/D Internal Reference Voltage Data Register"]
        #[inline(always)]
        pub const fn adocdr(self) -> crate::common::Reg<regs::Adocdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "A/D Self,Diagnosis Data Register"]
        #[inline(always)]
        pub const fn adrd(self) -> crate::common::Reg<regs::Adrd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1eusize) as _) }
        }
        #[doc = "A/D Data Registers %s"]
        #[inline(always)]
        pub const fn addr(self, n: usize) -> crate::common::Reg<regs::Addr, crate::common::R> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2ausize + n * 2usize) as _) }
        }
        #[doc = "A/D Data Registers %s"]
        #[inline(always)]
        pub const fn addr_1(self, n: usize) -> crate::common::Reg<regs::Addr1, crate::common::R> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x32usize + n * 2usize) as _) }
        }
        #[doc = "A/D Data Registers %s"]
        #[inline(always)]
        pub const fn addr_2(self, n: usize) -> crate::common::Reg<regs::Addr2, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x46usize + n * 2usize) as _) }
        }
        #[doc = "A/D Disconnection Detection Control Register"]
        #[inline(always)]
        pub const fn addiscr(self) -> crate::common::Reg<regs::Addiscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7ausize) as _) }
        }
        #[doc = "A/D Conversion Operation Mode Select Register"]
        #[inline(always)]
        pub const fn adacsr(self) -> crate::common::Reg<regs::Adacsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7eusize) as _) }
        }
        #[doc = "A/D Group Scan Priority Control Register"]
        #[inline(always)]
        pub const fn adgspcr(self) -> crate::common::Reg<regs::Adgspcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register A"]
        #[inline(always)]
        pub const fn addbldra(self) -> crate::common::Reg<regs::Addbldra, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "A/D Data Duplexing Register B"]
        #[inline(always)]
        pub const fn addbldrb(self) -> crate::common::Reg<regs::Addbldrb, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x86usize) as _) }
        }
        #[doc = "A/D High,Potential/Low,Potential Reference Voltage Control Register"]
        #[inline(always)]
        pub const fn adhvrefcnt(self) -> crate::common::Reg<regs::Adhvrefcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8ausize) as _) }
        }
        #[doc = "A/D Compare Function Window A/B Status Monitor Register"]
        #[inline(always)]
        pub const fn adwinmon(self) -> crate::common::Reg<regs::Adwinmon, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "A/D Compare Function Control Register"]
        #[inline(always)]
        pub const fn adcmpcr(self) -> crate::common::Reg<regs::Adcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Select Register"]
        #[inline(always)]
        pub const fn adcmpanser(self) -> crate::common::Reg<regs::Adcmpanser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x92usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Comparison Condition Setting Register"]
        #[inline(always)]
        pub const fn adcmpler(self) -> crate::common::Reg<regs::Adcmpler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x93usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 0"]
        #[inline(always)]
        pub const fn adcmpansr0(self) -> crate::common::Reg<regs::Adcmpansr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 1"]
        #[inline(always)]
        pub const fn adcmpansr1(self) -> crate::common::Reg<regs::Adcmpansr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x96usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 0"]
        #[inline(always)]
        pub const fn adcmplr0(self) -> crate::common::Reg<regs::Adcmplr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 1"]
        #[inline(always)]
        pub const fn adcmplr1(self) -> crate::common::Reg<regs::Adcmplr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9ausize) as _) }
        }
        #[doc = "A/D Compare Function Window A Lower,Side/Upper,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adcmpdr(self, n: usize) -> crate::common::Reg<u16, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize + n * 2usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register 0"]
        #[inline(always)]
        pub const fn adcmpsr0(self) -> crate::common::Reg<regs::Adcmpsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register1"]
        #[inline(always)]
        pub const fn adcmpsr1(self) -> crate::common::Reg<regs::Adcmpsr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa2usize) as _) }
        }
        #[doc = "A/D Compare Function Window A Extended Input Channel Status Register"]
        #[inline(always)]
        pub const fn adcmpser(self) -> crate::common::Reg<regs::Adcmpser, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Channel Select Register"]
        #[inline(always)]
        pub const fn adcmpbnsr(self) -> crate::common::Reg<regs::Adcmpbnsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa6usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Lower,Side/Upper,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adwinllb(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "A/D Compare Function Window B Lower,Side/Upper,Side Level Setting Register"]
        #[inline(always)]
        pub const fn adwinulb(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xaausize) as _) }
        }
        #[doc = "A/D Compare Function Window B Status Register"]
        #[inline(always)]
        pub const fn adcmpbsr(self) -> crate::common::Reg<regs::Adcmpbsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xacusize) as _) }
        }
        #[doc = "A/D Sampling State Register"]
        #[inline(always)]
        pub const fn adsstrl(self) -> crate::common::Reg<regs::Adsstrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xddusize) as _) }
        }
        #[doc = "A/D Sampling State Register"]
        #[inline(always)]
        pub const fn adsstrt(self) -> crate::common::Reg<regs::Adsstrt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdeusize) as _) }
        }
        #[doc = "A/D Sampling State Register"]
        #[inline(always)]
        pub const fn adsstro(self) -> crate::common::Reg<regs::Adsstro, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdfusize) as _) }
        }
        #[doc = "A/D Sampling State Register"]
        #[inline(always)]
        pub const fn adsstr(self, n: usize) -> crate::common::Reg<regs::Adsstr, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe5usize + n * 1usize) as _) }
        }
        #[doc = "A/D Sampling State Register"]
        #[inline(always)]
        pub const fn adsstr_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Adsstr1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe9usize + n * 1usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "A/D Conversion Operation Mode Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adacsr(pub u8);
        impl Adacsr {
            #[doc = "Successive Approximation Control Setting"]
            #[inline(always)]
            pub const fn adsac(&self) -> super::vals::Adsac {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Adsac::from_bits(val as u8)
            }
            #[doc = "Successive Approximation Control Setting"]
            #[inline(always)]
            pub fn set_adsac(&mut self, val: super::vals::Adsac) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Adacsr {
            #[inline(always)]
            fn default() -> Adacsr {
                Adacsr(0)
            }
        }
        impl core::fmt::Debug for Adacsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adacsr")
                    .field("adsac", &self.adsac())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adacsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adacsr {{ adsac: {:?} }}", self.adsac())
            }
        }
        #[doc = "A/D,Converted Value Addition/Average Count Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adadc(pub u8);
        impl Adadc {
            #[doc = "Addition/Average Count Select"]
            #[inline(always)]
            pub const fn adc(&self) -> super::vals::Adc {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Adc::from_bits(val as u8)
            }
            #[doc = "Addition/Average Count Select"]
            #[inline(always)]
            pub fn set_adc(&mut self, val: super::vals::Adc) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Average Mode Select"]
            #[inline(always)]
            pub const fn avee(&self) -> super::vals::Avee {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Avee::from_bits(val as u8)
            }
            #[doc = "Average Mode Select"]
            #[inline(always)]
            pub fn set_avee(&mut self, val: super::vals::Avee) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adadc {
            #[inline(always)]
            fn default() -> Adadc {
                Adadc(0)
            }
        }
        impl core::fmt::Debug for Adadc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adadc")
                    .field("adc", &self.adc())
                    .field("avee", &self.avee())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adadc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adadc {{ adc: {:?}, avee: {:?} }}",
                    self.adc(),
                    self.avee()
                )
            }
        }
        #[doc = "A/D,Converted Value Addition/Average Channel Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adads0(pub u16);
        impl Adads0 {
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads00(&self) -> super::vals::Ads00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ads00::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads00(&mut self, val: super::vals::Ads00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads01(&self) -> super::vals::Ads01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ads01::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads01(&mut self, val: super::vals::Ads01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads02(&self) -> super::vals::Ads02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ads02::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads02(&mut self, val: super::vals::Ads02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads03(&self) -> super::vals::Ads03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ads03::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads03(&mut self, val: super::vals::Ads03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads04(&self) -> super::vals::Ads04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ads04::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads04(&mut self, val: super::vals::Ads04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads05(&self) -> super::vals::Ads05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ads05::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads05(&mut self, val: super::vals::Ads05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads06(&self) -> super::vals::Ads06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ads06::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads06(&mut self, val: super::vals::Ads06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads07(&self) -> super::vals::Ads07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ads07::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads07(&mut self, val: super::vals::Ads07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads08(&self) -> super::vals::Ads08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ads08::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads08(&mut self, val: super::vals::Ads08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads09(&self) -> super::vals::Ads09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ads09::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads09(&mut self, val: super::vals::Ads09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads10(&self) -> super::vals::Ads10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ads10::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads10(&mut self, val: super::vals::Ads10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads11(&self) -> super::vals::Ads11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ads11::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads11(&mut self, val: super::vals::Ads11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads12(&self) -> super::vals::Ads12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ads12::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads12(&mut self, val: super::vals::Ads12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads13(&self) -> super::vals::Ads13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ads13::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads13(&mut self, val: super::vals::Ads13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads14(&self) -> super::vals::Ads14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ads14::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads14(&mut self, val: super::vals::Ads14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads15(&self) -> super::vals::Ads15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ads15::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads15(&mut self, val: super::vals::Ads15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adads0 {
            #[inline(always)]
            fn default() -> Adads0 {
                Adads0(0)
            }
        }
        impl core::fmt::Debug for Adads0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adads0")
                    .field("ads00", &self.ads00())
                    .field("ads01", &self.ads01())
                    .field("ads02", &self.ads02())
                    .field("ads03", &self.ads03())
                    .field("ads04", &self.ads04())
                    .field("ads05", &self.ads05())
                    .field("ads06", &self.ads06())
                    .field("ads07", &self.ads07())
                    .field("ads08", &self.ads08())
                    .field("ads09", &self.ads09())
                    .field("ads10", &self.ads10())
                    .field("ads11", &self.ads11())
                    .field("ads12", &self.ads12())
                    .field("ads13", &self.ads13())
                    .field("ads14", &self.ads14())
                    .field("ads15", &self.ads15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adads0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adads0 {{ ads00: {:?}, ads01: {:?}, ads02: {:?}, ads03: {:?}, ads04: {:?}, ads05: {:?}, ads06: {:?}, ads07: {:?}, ads08: {:?}, ads09: {:?}, ads10: {:?}, ads11: {:?}, ads12: {:?}, ads13: {:?}, ads14: {:?}, ads15: {:?} }}" , self . ads00 () , self . ads01 () , self . ads02 () , self . ads03 () , self . ads04 () , self . ads05 () , self . ads06 () , self . ads07 () , self . ads08 () , self . ads09 () , self . ads10 () , self . ads11 () , self . ads12 () , self . ads13 () , self . ads14 () , self . ads15 ())
            }
        }
        #[doc = "A/D,Converted Value Addition/Average Channel Select Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adads1(pub u16);
        impl Adads1 {
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads16(&self) -> super::vals::Ads16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ads16::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads16(&mut self, val: super::vals::Ads16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads17(&self) -> super::vals::Ads17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ads17::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads17(&mut self, val: super::vals::Ads17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads18(&self) -> super::vals::Ads18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ads18::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads18(&mut self, val: super::vals::Ads18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads19(&self) -> super::vals::Ads19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ads19::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads19(&mut self, val: super::vals::Ads19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads20(&self) -> super::vals::Ads20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ads20::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads20(&mut self, val: super::vals::Ads20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads21(&self) -> super::vals::Ads21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ads21::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads21(&mut self, val: super::vals::Ads21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads22(&self) -> super::vals::Ads22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ads22::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads22(&mut self, val: super::vals::Ads22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads23(&self) -> super::vals::Ads23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ads23::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads23(&mut self, val: super::vals::Ads23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads24(&self) -> super::vals::Ads24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ads24::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads24(&mut self, val: super::vals::Ads24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads25(&self) -> super::vals::Ads25 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ads25::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads25(&mut self, val: super::vals::Ads25) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads26(&self) -> super::vals::Ads26 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ads26::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads26(&mut self, val: super::vals::Ads26) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads27(&self) -> super::vals::Ads27 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ads27::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads27(&mut self, val: super::vals::Ads27) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads28(&self) -> super::vals::Ads28 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ads28::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads28(&mut self, val: super::vals::Ads28) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads29(&self) -> super::vals::Ads29 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ads29::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads29(&mut self, val: super::vals::Ads29) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads30(&self) -> super::vals::Ads30 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ads30::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads30(&mut self, val: super::vals::Ads30) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub const fn ads31(&self) -> super::vals::Ads31 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ads31::from_bits(val as u8)
            }
            #[doc = "A/D,Converted Value Addition/Average Channel Select"]
            #[inline(always)]
            pub fn set_ads31(&mut self, val: super::vals::Ads31) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adads1 {
            #[inline(always)]
            fn default() -> Adads1 {
                Adads1(0)
            }
        }
        impl core::fmt::Debug for Adads1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adads1")
                    .field("ads16", &self.ads16())
                    .field("ads17", &self.ads17())
                    .field("ads18", &self.ads18())
                    .field("ads19", &self.ads19())
                    .field("ads20", &self.ads20())
                    .field("ads21", &self.ads21())
                    .field("ads22", &self.ads22())
                    .field("ads23", &self.ads23())
                    .field("ads24", &self.ads24())
                    .field("ads25", &self.ads25())
                    .field("ads26", &self.ads26())
                    .field("ads27", &self.ads27())
                    .field("ads28", &self.ads28())
                    .field("ads29", &self.ads29())
                    .field("ads30", &self.ads30())
                    .field("ads31", &self.ads31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adads1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adads1 {{ ads16: {:?}, ads17: {:?}, ads18: {:?}, ads19: {:?}, ads20: {:?}, ads21: {:?}, ads22: {:?}, ads23: {:?}, ads24: {:?}, ads25: {:?}, ads26: {:?}, ads27: {:?}, ads28: {:?}, ads29: {:?}, ads30: {:?}, ads31: {:?} }}" , self . ads16 () , self . ads17 () , self . ads18 () , self . ads19 () , self . ads20 () , self . ads21 () , self . ads22 () , self . ads23 () , self . ads24 () , self . ads25 () , self . ads26 () , self . ads27 () , self . ads28 () , self . ads29 () , self . ads30 () , self . ads31 ())
            }
        }
        #[doc = "A/D Channel Select Register A0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansa0(pub u16);
        impl Adansa0 {
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa00(&self) -> super::vals::Ansa00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansa00::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa00(&mut self, val: super::vals::Ansa00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa01(&self) -> super::vals::Ansa01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansa01::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa01(&mut self, val: super::vals::Ansa01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa02(&self) -> super::vals::Ansa02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansa02::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa02(&mut self, val: super::vals::Ansa02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa03(&self) -> super::vals::Ansa03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansa03::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa03(&mut self, val: super::vals::Ansa03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa04(&self) -> super::vals::Ansa04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ansa04::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa04(&mut self, val: super::vals::Ansa04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa05(&self) -> super::vals::Ansa05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ansa05::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa05(&mut self, val: super::vals::Ansa05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa06(&self) -> super::vals::Ansa06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ansa06::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa06(&mut self, val: super::vals::Ansa06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa07(&self) -> super::vals::Ansa07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ansa07::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa07(&mut self, val: super::vals::Ansa07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa08(&self) -> super::vals::Ansa08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ansa08::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa08(&mut self, val: super::vals::Ansa08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa09(&self) -> super::vals::Ansa09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ansa09::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa09(&mut self, val: super::vals::Ansa09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa10(&self) -> super::vals::Ansa10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ansa10::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa10(&mut self, val: super::vals::Ansa10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa11(&self) -> super::vals::Ansa11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ansa11::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa11(&mut self, val: super::vals::Ansa11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa12(&self) -> super::vals::Ansa12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ansa12::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa12(&mut self, val: super::vals::Ansa12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa13(&self) -> super::vals::Ansa13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ansa13::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa13(&mut self, val: super::vals::Ansa13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa14(&self) -> super::vals::Ansa14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ansa14::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa14(&mut self, val: super::vals::Ansa14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa15(&self) -> super::vals::Ansa15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ansa15::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa15(&mut self, val: super::vals::Ansa15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adansa0 {
            #[inline(always)]
            fn default() -> Adansa0 {
                Adansa0(0)
            }
        }
        impl core::fmt::Debug for Adansa0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansa0")
                    .field("ansa00", &self.ansa00())
                    .field("ansa01", &self.ansa01())
                    .field("ansa02", &self.ansa02())
                    .field("ansa03", &self.ansa03())
                    .field("ansa04", &self.ansa04())
                    .field("ansa05", &self.ansa05())
                    .field("ansa06", &self.ansa06())
                    .field("ansa07", &self.ansa07())
                    .field("ansa08", &self.ansa08())
                    .field("ansa09", &self.ansa09())
                    .field("ansa10", &self.ansa10())
                    .field("ansa11", &self.ansa11())
                    .field("ansa12", &self.ansa12())
                    .field("ansa13", &self.ansa13())
                    .field("ansa14", &self.ansa14())
                    .field("ansa15", &self.ansa15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansa0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adansa0 {{ ansa00: {:?}, ansa01: {:?}, ansa02: {:?}, ansa03: {:?}, ansa04: {:?}, ansa05: {:?}, ansa06: {:?}, ansa07: {:?}, ansa08: {:?}, ansa09: {:?}, ansa10: {:?}, ansa11: {:?}, ansa12: {:?}, ansa13: {:?}, ansa14: {:?}, ansa15: {:?} }}" , self . ansa00 () , self . ansa01 () , self . ansa02 () , self . ansa03 () , self . ansa04 () , self . ansa05 () , self . ansa06 () , self . ansa07 () , self . ansa08 () , self . ansa09 () , self . ansa10 () , self . ansa11 () , self . ansa12 () , self . ansa13 () , self . ansa14 () , self . ansa15 ())
            }
        }
        #[doc = "A/D Channel Select Register A1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansa1(pub u16);
        impl Adansa1 {
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa16(&self) -> super::vals::Ansa16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansa16::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa16(&mut self, val: super::vals::Ansa16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa17(&self) -> super::vals::Ansa17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansa17::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa17(&mut self, val: super::vals::Ansa17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa18(&self) -> super::vals::Ansa18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansa18::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa18(&mut self, val: super::vals::Ansa18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa19(&self) -> super::vals::Ansa19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansa19::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa19(&mut self, val: super::vals::Ansa19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa20(&self) -> super::vals::Ansa20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ansa20::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa20(&mut self, val: super::vals::Ansa20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa21(&self) -> super::vals::Ansa21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ansa21::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa21(&mut self, val: super::vals::Ansa21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa22(&self) -> super::vals::Ansa22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ansa22::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa22(&mut self, val: super::vals::Ansa22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa23(&self) -> super::vals::Ansa23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ansa23::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa23(&mut self, val: super::vals::Ansa23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa24(&self) -> super::vals::Ansa24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ansa24::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa24(&mut self, val: super::vals::Ansa24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa25(&self) -> super::vals::Ansa25 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ansa25::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa25(&mut self, val: super::vals::Ansa25) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa26(&self) -> super::vals::Ansa26 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ansa26::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa26(&mut self, val: super::vals::Ansa26) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa27(&self) -> super::vals::Ansa27 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ansa27::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa27(&mut self, val: super::vals::Ansa27) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa28(&self) -> super::vals::Ansa28 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ansa28::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa28(&mut self, val: super::vals::Ansa28) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa29(&self) -> super::vals::Ansa29 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ansa29::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa29(&mut self, val: super::vals::Ansa29) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa30(&self) -> super::vals::Ansa30 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ansa30::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa30(&mut self, val: super::vals::Ansa30) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansa31(&self) -> super::vals::Ansa31 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ansa31::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansa31(&mut self, val: super::vals::Ansa31) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adansa1 {
            #[inline(always)]
            fn default() -> Adansa1 {
                Adansa1(0)
            }
        }
        impl core::fmt::Debug for Adansa1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansa1")
                    .field("ansa16", &self.ansa16())
                    .field("ansa17", &self.ansa17())
                    .field("ansa18", &self.ansa18())
                    .field("ansa19", &self.ansa19())
                    .field("ansa20", &self.ansa20())
                    .field("ansa21", &self.ansa21())
                    .field("ansa22", &self.ansa22())
                    .field("ansa23", &self.ansa23())
                    .field("ansa24", &self.ansa24())
                    .field("ansa25", &self.ansa25())
                    .field("ansa26", &self.ansa26())
                    .field("ansa27", &self.ansa27())
                    .field("ansa28", &self.ansa28())
                    .field("ansa29", &self.ansa29())
                    .field("ansa30", &self.ansa30())
                    .field("ansa31", &self.ansa31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansa1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adansa1 {{ ansa16: {:?}, ansa17: {:?}, ansa18: {:?}, ansa19: {:?}, ansa20: {:?}, ansa21: {:?}, ansa22: {:?}, ansa23: {:?}, ansa24: {:?}, ansa25: {:?}, ansa26: {:?}, ansa27: {:?}, ansa28: {:?}, ansa29: {:?}, ansa30: {:?}, ansa31: {:?} }}" , self . ansa16 () , self . ansa17 () , self . ansa18 () , self . ansa19 () , self . ansa20 () , self . ansa21 () , self . ansa22 () , self . ansa23 () , self . ansa24 () , self . ansa25 () , self . ansa26 () , self . ansa27 () , self . ansa28 () , self . ansa29 () , self . ansa30 () , self . ansa31 ())
            }
        }
        #[doc = "A/D Channel Select Register B0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansb0(pub u16);
        impl Adansb0 {
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb00(&self) -> super::vals::Ansb00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansb00::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb00(&mut self, val: super::vals::Ansb00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb01(&self) -> super::vals::Ansb01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansb01::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb01(&mut self, val: super::vals::Ansb01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb02(&self) -> super::vals::Ansb02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansb02::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb02(&mut self, val: super::vals::Ansb02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb03(&self) -> super::vals::Ansb03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansb03::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb03(&mut self, val: super::vals::Ansb03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb04(&self) -> super::vals::Ansb04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ansb04::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb04(&mut self, val: super::vals::Ansb04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb05(&self) -> super::vals::Ansb05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ansb05::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb05(&mut self, val: super::vals::Ansb05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb06(&self) -> super::vals::Ansb06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ansb06::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb06(&mut self, val: super::vals::Ansb06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb07(&self) -> super::vals::Ansb07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ansb07::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb07(&mut self, val: super::vals::Ansb07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb08(&self) -> super::vals::Ansb08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ansb08::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb08(&mut self, val: super::vals::Ansb08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb09(&self) -> super::vals::Ansb09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ansb09::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb09(&mut self, val: super::vals::Ansb09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb10(&self) -> super::vals::Ansb10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ansb10::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb10(&mut self, val: super::vals::Ansb10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb11(&self) -> super::vals::Ansb11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ansb11::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb11(&mut self, val: super::vals::Ansb11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb12(&self) -> super::vals::Ansb12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ansb12::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb12(&mut self, val: super::vals::Ansb12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb13(&self) -> super::vals::Ansb13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ansb13::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb13(&mut self, val: super::vals::Ansb13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb14(&self) -> super::vals::Ansb14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ansb14::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb14(&mut self, val: super::vals::Ansb14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb15(&self) -> super::vals::Ansb15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ansb15::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb15(&mut self, val: super::vals::Ansb15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adansb0 {
            #[inline(always)]
            fn default() -> Adansb0 {
                Adansb0(0)
            }
        }
        impl core::fmt::Debug for Adansb0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansb0")
                    .field("ansb00", &self.ansb00())
                    .field("ansb01", &self.ansb01())
                    .field("ansb02", &self.ansb02())
                    .field("ansb03", &self.ansb03())
                    .field("ansb04", &self.ansb04())
                    .field("ansb05", &self.ansb05())
                    .field("ansb06", &self.ansb06())
                    .field("ansb07", &self.ansb07())
                    .field("ansb08", &self.ansb08())
                    .field("ansb09", &self.ansb09())
                    .field("ansb10", &self.ansb10())
                    .field("ansb11", &self.ansb11())
                    .field("ansb12", &self.ansb12())
                    .field("ansb13", &self.ansb13())
                    .field("ansb14", &self.ansb14())
                    .field("ansb15", &self.ansb15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansb0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adansb0 {{ ansb00: {:?}, ansb01: {:?}, ansb02: {:?}, ansb03: {:?}, ansb04: {:?}, ansb05: {:?}, ansb06: {:?}, ansb07: {:?}, ansb08: {:?}, ansb09: {:?}, ansb10: {:?}, ansb11: {:?}, ansb12: {:?}, ansb13: {:?}, ansb14: {:?}, ansb15: {:?} }}" , self . ansb00 () , self . ansb01 () , self . ansb02 () , self . ansb03 () , self . ansb04 () , self . ansb05 () , self . ansb06 () , self . ansb07 () , self . ansb08 () , self . ansb09 () , self . ansb10 () , self . ansb11 () , self . ansb12 () , self . ansb13 () , self . ansb14 () , self . ansb15 ())
            }
        }
        #[doc = "A/D Channel Select Register B1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adansb1(pub u16);
        impl Adansb1 {
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb16(&self) -> super::vals::Ansb16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ansb16::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb16(&mut self, val: super::vals::Ansb16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb17(&self) -> super::vals::Ansb17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ansb17::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb17(&mut self, val: super::vals::Ansb17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb18(&self) -> super::vals::Ansb18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ansb18::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb18(&mut self, val: super::vals::Ansb18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb19(&self) -> super::vals::Ansb19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ansb19::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb19(&mut self, val: super::vals::Ansb19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb20(&self) -> super::vals::Ansb20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ansb20::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb20(&mut self, val: super::vals::Ansb20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb21(&self) -> super::vals::Ansb21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ansb21::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb21(&mut self, val: super::vals::Ansb21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb22(&self) -> super::vals::Ansb22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ansb22::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb22(&mut self, val: super::vals::Ansb22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb23(&self) -> super::vals::Ansb23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ansb23::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb23(&mut self, val: super::vals::Ansb23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb24(&self) -> super::vals::Ansb24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ansb24::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb24(&mut self, val: super::vals::Ansb24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb25(&self) -> super::vals::Ansb25 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ansb25::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb25(&mut self, val: super::vals::Ansb25) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb26(&self) -> super::vals::Ansb26 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ansb26::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb26(&mut self, val: super::vals::Ansb26) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb27(&self) -> super::vals::Ansb27 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ansb27::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb27(&mut self, val: super::vals::Ansb27) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb28(&self) -> super::vals::Ansb28 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ansb28::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb28(&mut self, val: super::vals::Ansb28) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb29(&self) -> super::vals::Ansb29 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ansb29::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb29(&mut self, val: super::vals::Ansb29) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb30(&self) -> super::vals::Ansb30 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ansb30::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb30(&mut self, val: super::vals::Ansb30) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub const fn ansb31(&self) -> super::vals::Ansb31 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ansb31::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Channels Select"]
            #[inline(always)]
            pub fn set_ansb31(&mut self, val: super::vals::Ansb31) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adansb1 {
            #[inline(always)]
            fn default() -> Adansb1 {
                Adansb1(0)
            }
        }
        impl core::fmt::Debug for Adansb1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adansb1")
                    .field("ansb16", &self.ansb16())
                    .field("ansb17", &self.ansb17())
                    .field("ansb18", &self.ansb18())
                    .field("ansb19", &self.ansb19())
                    .field("ansb20", &self.ansb20())
                    .field("ansb21", &self.ansb21())
                    .field("ansb22", &self.ansb22())
                    .field("ansb23", &self.ansb23())
                    .field("ansb24", &self.ansb24())
                    .field("ansb25", &self.ansb25())
                    .field("ansb26", &self.ansb26())
                    .field("ansb27", &self.ansb27())
                    .field("ansb28", &self.ansb28())
                    .field("ansb29", &self.ansb29())
                    .field("ansb30", &self.ansb30())
                    .field("ansb31", &self.ansb31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adansb1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adansb1 {{ ansb16: {:?}, ansb17: {:?}, ansb18: {:?}, ansb19: {:?}, ansb20: {:?}, ansb21: {:?}, ansb22: {:?}, ansb23: {:?}, ansb24: {:?}, ansb25: {:?}, ansb26: {:?}, ansb27: {:?}, ansb28: {:?}, ansb29: {:?}, ansb30: {:?}, ansb31: {:?} }}" , self . ansb16 () , self . ansb17 () , self . ansb18 () , self . ansb19 () , self . ansb20 () , self . ansb21 () , self . ansb22 () , self . ansb23 () , self . ansb24 () , self . ansb25 () , self . ansb26 () , self . ansb27 () , self . ansb28 () , self . ansb29 () , self . ansb30 () , self . ansb31 ())
            }
        }
        #[doc = "A/D Control Extended Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcer(pub u16);
        impl Adcer {
            #[doc = "A/D Data Register Automatic Clearing Enable"]
            #[inline(always)]
            pub const fn ace(&self) -> super::vals::Ace {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ace::from_bits(val as u8)
            }
            #[doc = "A/D Data Register Automatic Clearing Enable"]
            #[inline(always)]
            pub fn set_ace(&mut self, val: super::vals::Ace) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Self,Diagnosis Conversion Voltage Select"]
            #[inline(always)]
            pub const fn diagval(&self) -> super::vals::Diagval {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Diagval::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Conversion Voltage Select"]
            #[inline(always)]
            pub fn set_diagval(&mut self, val: super::vals::Diagval) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Self,Diagnosis Mode Select"]
            #[inline(always)]
            pub const fn diagld(&self) -> super::vals::Diagld {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Diagld::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Mode Select"]
            #[inline(always)]
            pub fn set_diagld(&mut self, val: super::vals::Diagld) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Self,Diagnosis Enable"]
            #[inline(always)]
            pub const fn diagm(&self) -> super::vals::Diagm {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Diagm::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Enable"]
            #[inline(always)]
            pub fn set_diagm(&mut self, val: super::vals::Diagm) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "A/D Data Register Format Select"]
            #[inline(always)]
            pub const fn adrfmt(&self) -> super::vals::Adrfmt {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Adrfmt::from_bits(val as u8)
            }
            #[doc = "A/D Data Register Format Select"]
            #[inline(always)]
            pub fn set_adrfmt(&mut self, val: super::vals::Adrfmt) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcer {
            #[inline(always)]
            fn default() -> Adcer {
                Adcer(0)
            }
        }
        impl core::fmt::Debug for Adcer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcer")
                    .field("ace", &self.ace())
                    .field("diagval", &self.diagval())
                    .field("diagld", &self.diagld())
                    .field("diagm", &self.diagm())
                    .field("adrfmt", &self.adrfmt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcer {{ ace: {:?}, diagval: {:?}, diagld: {:?}, diagm: {:?}, adrfmt: {:?} }}",
                    self.ace(),
                    self.diagval(),
                    self.diagld(),
                    self.diagm(),
                    self.adrfmt()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpanser(pub u8);
        impl Adcmpanser {
            #[doc = "Temperature Sensor Output Compare Select"]
            #[inline(always)]
            pub const fn cmptsa(&self) -> super::vals::Cmptsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmptsa::from_bits(val as u8)
            }
            #[doc = "Temperature Sensor Output Compare Select"]
            #[inline(always)]
            pub fn set_cmptsa(&mut self, val: super::vals::Cmptsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Internal Reference Voltage Compare Select"]
            #[inline(always)]
            pub const fn cmpoca(&self) -> super::vals::Cmpoca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpoca::from_bits(val as u8)
            }
            #[doc = "Internal Reference Voltage Compare Select"]
            #[inline(always)]
            pub fn set_cmpoca(&mut self, val: super::vals::Cmpoca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Adcmpanser {
            #[inline(always)]
            fn default() -> Adcmpanser {
                Adcmpanser(0)
            }
        }
        impl core::fmt::Debug for Adcmpanser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpanser")
                    .field("cmptsa", &self.cmptsa())
                    .field("cmpoca", &self.cmpoca())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpanser {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpanser {{ cmptsa: {:?}, cmpoca: {:?} }}",
                    self.cmptsa(),
                    self.cmpoca()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpansr0(pub u16);
        impl Adcmpansr0 {
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha00(&self) -> super::vals::Cmpcha00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpcha00::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha00(&mut self, val: super::vals::Cmpcha00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha01(&self) -> super::vals::Cmpcha01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpcha01::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha01(&mut self, val: super::vals::Cmpcha01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha02(&self) -> super::vals::Cmpcha02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpcha02::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha02(&mut self, val: super::vals::Cmpcha02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha03(&self) -> super::vals::Cmpcha03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpcha03::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha03(&mut self, val: super::vals::Cmpcha03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha04(&self) -> super::vals::Cmpcha04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmpcha04::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha04(&mut self, val: super::vals::Cmpcha04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha05(&self) -> super::vals::Cmpcha05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmpcha05::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha05(&mut self, val: super::vals::Cmpcha05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha06(&self) -> super::vals::Cmpcha06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmpcha06::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha06(&mut self, val: super::vals::Cmpcha06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha07(&self) -> super::vals::Cmpcha07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmpcha07::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha07(&mut self, val: super::vals::Cmpcha07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha08(&self) -> super::vals::Cmpcha08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmpcha08::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha08(&mut self, val: super::vals::Cmpcha08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha09(&self) -> super::vals::Cmpcha09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmpcha09::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha09(&mut self, val: super::vals::Cmpcha09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha10(&self) -> super::vals::Cmpcha10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cmpcha10::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha10(&mut self, val: super::vals::Cmpcha10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha11(&self) -> super::vals::Cmpcha11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmpcha11::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha11(&mut self, val: super::vals::Cmpcha11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha12(&self) -> super::vals::Cmpcha12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cmpcha12::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha12(&mut self, val: super::vals::Cmpcha12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha13(&self) -> super::vals::Cmpcha13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmpcha13::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha13(&mut self, val: super::vals::Cmpcha13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha14(&self) -> super::vals::Cmpcha14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cmpcha14::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha14(&mut self, val: super::vals::Cmpcha14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha15(&self) -> super::vals::Cmpcha15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmpcha15::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha15(&mut self, val: super::vals::Cmpcha15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmpansr0 {
            #[inline(always)]
            fn default() -> Adcmpansr0 {
                Adcmpansr0(0)
            }
        }
        impl core::fmt::Debug for Adcmpansr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpansr0")
                    .field("cmpcha00", &self.cmpcha00())
                    .field("cmpcha01", &self.cmpcha01())
                    .field("cmpcha02", &self.cmpcha02())
                    .field("cmpcha03", &self.cmpcha03())
                    .field("cmpcha04", &self.cmpcha04())
                    .field("cmpcha05", &self.cmpcha05())
                    .field("cmpcha06", &self.cmpcha06())
                    .field("cmpcha07", &self.cmpcha07())
                    .field("cmpcha08", &self.cmpcha08())
                    .field("cmpcha09", &self.cmpcha09())
                    .field("cmpcha10", &self.cmpcha10())
                    .field("cmpcha11", &self.cmpcha11())
                    .field("cmpcha12", &self.cmpcha12())
                    .field("cmpcha13", &self.cmpcha13())
                    .field("cmpcha14", &self.cmpcha14())
                    .field("cmpcha15", &self.cmpcha15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpansr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpansr0 {{ cmpcha00: {:?}, cmpcha01: {:?}, cmpcha02: {:?}, cmpcha03: {:?}, cmpcha04: {:?}, cmpcha05: {:?}, cmpcha06: {:?}, cmpcha07: {:?}, cmpcha08: {:?}, cmpcha09: {:?}, cmpcha10: {:?}, cmpcha11: {:?}, cmpcha12: {:?}, cmpcha13: {:?}, cmpcha14: {:?}, cmpcha15: {:?} }}" , self . cmpcha00 () , self . cmpcha01 () , self . cmpcha02 () , self . cmpcha03 () , self . cmpcha04 () , self . cmpcha05 () , self . cmpcha06 () , self . cmpcha07 () , self . cmpcha08 () , self . cmpcha09 () , self . cmpcha10 () , self . cmpcha11 () , self . cmpcha12 () , self . cmpcha13 () , self . cmpcha14 () , self . cmpcha15 ())
            }
        }
        #[doc = "A/D Compare Function Window A Channel Select Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpansr1(pub u16);
        impl Adcmpansr1 {
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha16(&self) -> super::vals::Cmpcha16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpcha16::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha16(&mut self, val: super::vals::Cmpcha16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha17(&self) -> super::vals::Cmpcha17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpcha17::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha17(&mut self, val: super::vals::Cmpcha17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha18(&self) -> super::vals::Cmpcha18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpcha18::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha18(&mut self, val: super::vals::Cmpcha18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha19(&self) -> super::vals::Cmpcha19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpcha19::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha19(&mut self, val: super::vals::Cmpcha19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha20(&self) -> super::vals::Cmpcha20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmpcha20::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha20(&mut self, val: super::vals::Cmpcha20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha21(&self) -> super::vals::Cmpcha21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmpcha21::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha21(&mut self, val: super::vals::Cmpcha21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha22(&self) -> super::vals::Cmpcha22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmpcha22::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha22(&mut self, val: super::vals::Cmpcha22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha23(&self) -> super::vals::Cmpcha23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmpcha23::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha23(&mut self, val: super::vals::Cmpcha23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha24(&self) -> super::vals::Cmpcha24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmpcha24::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha24(&mut self, val: super::vals::Cmpcha24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha25(&self) -> super::vals::Cmpcha25 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmpcha25::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha25(&mut self, val: super::vals::Cmpcha25) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha26(&self) -> super::vals::Cmpcha26 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cmpcha26::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha26(&mut self, val: super::vals::Cmpcha26) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha27(&self) -> super::vals::Cmpcha27 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmpcha27::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha27(&mut self, val: super::vals::Cmpcha27) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha28(&self) -> super::vals::Cmpcha28 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cmpcha28::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha28(&mut self, val: super::vals::Cmpcha28) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha29(&self) -> super::vals::Cmpcha29 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmpcha29::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha29(&mut self, val: super::vals::Cmpcha29) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha30(&self) -> super::vals::Cmpcha30 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cmpcha30::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha30(&mut self, val: super::vals::Cmpcha30) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub const fn cmpcha31(&self) -> super::vals::Cmpcha31 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmpcha31::from_bits(val as u8)
            }
            #[doc = "Compare Window A Channel Select"]
            #[inline(always)]
            pub fn set_cmpcha31(&mut self, val: super::vals::Cmpcha31) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmpansr1 {
            #[inline(always)]
            fn default() -> Adcmpansr1 {
                Adcmpansr1(0)
            }
        }
        impl core::fmt::Debug for Adcmpansr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpansr1")
                    .field("cmpcha16", &self.cmpcha16())
                    .field("cmpcha17", &self.cmpcha17())
                    .field("cmpcha18", &self.cmpcha18())
                    .field("cmpcha19", &self.cmpcha19())
                    .field("cmpcha20", &self.cmpcha20())
                    .field("cmpcha21", &self.cmpcha21())
                    .field("cmpcha22", &self.cmpcha22())
                    .field("cmpcha23", &self.cmpcha23())
                    .field("cmpcha24", &self.cmpcha24())
                    .field("cmpcha25", &self.cmpcha25())
                    .field("cmpcha26", &self.cmpcha26())
                    .field("cmpcha27", &self.cmpcha27())
                    .field("cmpcha28", &self.cmpcha28())
                    .field("cmpcha29", &self.cmpcha29())
                    .field("cmpcha30", &self.cmpcha30())
                    .field("cmpcha31", &self.cmpcha31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpansr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpansr1 {{ cmpcha16: {:?}, cmpcha17: {:?}, cmpcha18: {:?}, cmpcha19: {:?}, cmpcha20: {:?}, cmpcha21: {:?}, cmpcha22: {:?}, cmpcha23: {:?}, cmpcha24: {:?}, cmpcha25: {:?}, cmpcha26: {:?}, cmpcha27: {:?}, cmpcha28: {:?}, cmpcha29: {:?}, cmpcha30: {:?}, cmpcha31: {:?} }}" , self . cmpcha16 () , self . cmpcha17 () , self . cmpcha18 () , self . cmpcha19 () , self . cmpcha20 () , self . cmpcha21 () , self . cmpcha22 () , self . cmpcha23 () , self . cmpcha24 () , self . cmpcha25 () , self . cmpcha26 () , self . cmpcha27 () , self . cmpcha28 () , self . cmpcha29 () , self . cmpcha30 () , self . cmpcha31 ())
            }
        }
        #[doc = "A/D Compare Function Window B Channel Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpbnsr(pub u8);
        impl Adcmpbnsr {
            #[doc = "Compare Window B Channel Select"]
            #[inline(always)]
            pub const fn cmpchb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Compare Window B Channel Select"]
            #[inline(always)]
            pub fn set_cmpchb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Compare Window B Comparison Condition Setting"]
            #[inline(always)]
            pub const fn cmplb(&self) -> super::vals::Cmplb {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmplb::from_bits(val as u8)
            }
            #[doc = "Compare Window B Comparison Condition Setting"]
            #[inline(always)]
            pub fn set_cmplb(&mut self, val: super::vals::Cmplb) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adcmpbnsr {
            #[inline(always)]
            fn default() -> Adcmpbnsr {
                Adcmpbnsr(0)
            }
        }
        impl core::fmt::Debug for Adcmpbnsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpbnsr")
                    .field("cmpchb", &self.cmpchb())
                    .field("cmplb", &self.cmplb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpbnsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpbnsr {{ cmpchb: {=u8:?}, cmplb: {:?} }}",
                    self.cmpchb(),
                    self.cmplb()
                )
            }
        }
        #[doc = "A/D Compare Function Window B Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpbsr(pub u8);
        impl Adcmpbsr {
            #[doc = "Compare Window B Flag"]
            #[inline(always)]
            pub const fn cmpstb(&self) -> super::vals::Cmpstb {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpstb::from_bits(val as u8)
            }
            #[doc = "Compare Window B Flag"]
            #[inline(always)]
            pub fn set_cmpstb(&mut self, val: super::vals::Cmpstb) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Adcmpbsr {
            #[inline(always)]
            fn default() -> Adcmpbsr {
                Adcmpbsr(0)
            }
        }
        impl core::fmt::Debug for Adcmpbsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpbsr")
                    .field("cmpstb", &self.cmpstb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpbsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adcmpbsr {{ cmpstb: {:?} }}", self.cmpstb())
            }
        }
        #[doc = "A/D Compare Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpcr(pub u16);
        impl Adcmpcr {
            #[doc = "Window A/B Composite Conditions Setting"]
            #[inline(always)]
            pub const fn cmpab(&self) -> super::vals::Cmpab {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Cmpab::from_bits(val as u8)
            }
            #[doc = "Window A/B Composite Conditions Setting"]
            #[inline(always)]
            pub fn set_cmpab(&mut self, val: super::vals::Cmpab) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Compare Window B Operation Enable"]
            #[inline(always)]
            pub const fn cmpbe(&self) -> super::vals::Cmpbe {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmpbe::from_bits(val as u8)
            }
            #[doc = "Compare Window B Operation Enable"]
            #[inline(always)]
            pub fn set_cmpbe(&mut self, val: super::vals::Cmpbe) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Compare Window A Operation Enable"]
            #[inline(always)]
            pub const fn cmpae(&self) -> super::vals::Cmpae {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmpae::from_bits(val as u8)
            }
            #[doc = "Compare Window A Operation Enable"]
            #[inline(always)]
            pub fn set_cmpae(&mut self, val: super::vals::Cmpae) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Compare B Interrupt Enable"]
            #[inline(always)]
            pub const fn cmpbie(&self) -> super::vals::Cmpbie {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmpbie::from_bits(val as u8)
            }
            #[doc = "Compare B Interrupt Enable"]
            #[inline(always)]
            pub fn set_cmpbie(&mut self, val: super::vals::Cmpbie) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Window Function Setting"]
            #[inline(always)]
            pub const fn wcmpe(&self) -> super::vals::Wcmpe {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Wcmpe::from_bits(val as u8)
            }
            #[doc = "Window Function Setting"]
            #[inline(always)]
            pub fn set_wcmpe(&mut self, val: super::vals::Wcmpe) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare A Interrupt Enable"]
            #[inline(always)]
            pub const fn cmpaie(&self) -> super::vals::Cmpaie {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmpaie::from_bits(val as u8)
            }
            #[doc = "Compare A Interrupt Enable"]
            #[inline(always)]
            pub fn set_cmpaie(&mut self, val: super::vals::Cmpaie) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmpcr {
            #[inline(always)]
            fn default() -> Adcmpcr {
                Adcmpcr(0)
            }
        }
        impl core::fmt::Debug for Adcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpcr")
                    .field("cmpab", &self.cmpab())
                    .field("cmpbe", &self.cmpbe())
                    .field("cmpae", &self.cmpae())
                    .field("cmpbie", &self.cmpbie())
                    .field("wcmpe", &self.wcmpe())
                    .field("cmpaie", &self.cmpaie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpcr {{ cmpab: {:?}, cmpbe: {:?}, cmpae: {:?}, cmpbie: {:?}, wcmpe: {:?}, cmpaie: {:?} }}" , self . cmpab () , self . cmpbe () , self . cmpae () , self . cmpbie () , self . wcmpe () , self . cmpaie ())
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Comparison Condition Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpler(pub u8);
        impl Adcmpler {
            #[doc = "Compare Window A Temperature Sensor Output Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmpltsa(&self) -> super::vals::Cmpltsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpltsa::from_bits(val as u8)
            }
            #[doc = "Compare Window A Temperature Sensor Output Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmpltsa(&mut self, val: super::vals::Cmpltsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Internal Reference Voltage Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmploca(&self) -> super::vals::Cmploca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmploca::from_bits(val as u8)
            }
            #[doc = "Compare Window A Internal Reference Voltage Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmploca(&mut self, val: super::vals::Cmploca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Adcmpler {
            #[inline(always)]
            fn default() -> Adcmpler {
                Adcmpler(0)
            }
        }
        impl core::fmt::Debug for Adcmpler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpler")
                    .field("cmpltsa", &self.cmpltsa())
                    .field("cmploca", &self.cmploca())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpler {{ cmpltsa: {:?}, cmploca: {:?} }}",
                    self.cmpltsa(),
                    self.cmploca()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmplr0(pub u16);
        impl Adcmplr0 {
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha00(&self) -> super::vals::Cmplcha00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmplcha00::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha00(&mut self, val: super::vals::Cmplcha00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha01(&self) -> super::vals::Cmplcha01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmplcha01::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha01(&mut self, val: super::vals::Cmplcha01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha02(&self) -> super::vals::Cmplcha02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmplcha02::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha02(&mut self, val: super::vals::Cmplcha02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha03(&self) -> super::vals::Cmplcha03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmplcha03::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha03(&mut self, val: super::vals::Cmplcha03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha04(&self) -> super::vals::Cmplcha04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmplcha04::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha04(&mut self, val: super::vals::Cmplcha04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha05(&self) -> super::vals::Cmplcha05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmplcha05::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha05(&mut self, val: super::vals::Cmplcha05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha06(&self) -> super::vals::Cmplcha06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmplcha06::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha06(&mut self, val: super::vals::Cmplcha06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha07(&self) -> super::vals::Cmplcha07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmplcha07::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha07(&mut self, val: super::vals::Cmplcha07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha08(&self) -> super::vals::Cmplcha08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmplcha08::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha08(&mut self, val: super::vals::Cmplcha08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha09(&self) -> super::vals::Cmplcha09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmplcha09::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha09(&mut self, val: super::vals::Cmplcha09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha10(&self) -> super::vals::Cmplcha10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cmplcha10::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha10(&mut self, val: super::vals::Cmplcha10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha11(&self) -> super::vals::Cmplcha11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmplcha11::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha11(&mut self, val: super::vals::Cmplcha11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha12(&self) -> super::vals::Cmplcha12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cmplcha12::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha12(&mut self, val: super::vals::Cmplcha12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha13(&self) -> super::vals::Cmplcha13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmplcha13::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha13(&mut self, val: super::vals::Cmplcha13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha14(&self) -> super::vals::Cmplcha14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cmplcha14::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha14(&mut self, val: super::vals::Cmplcha14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha15(&self) -> super::vals::Cmplcha15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmplcha15::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha15(&mut self, val: super::vals::Cmplcha15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmplr0 {
            #[inline(always)]
            fn default() -> Adcmplr0 {
                Adcmplr0(0)
            }
        }
        impl core::fmt::Debug for Adcmplr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmplr0")
                    .field("cmplcha00", &self.cmplcha00())
                    .field("cmplcha01", &self.cmplcha01())
                    .field("cmplcha02", &self.cmplcha02())
                    .field("cmplcha03", &self.cmplcha03())
                    .field("cmplcha04", &self.cmplcha04())
                    .field("cmplcha05", &self.cmplcha05())
                    .field("cmplcha06", &self.cmplcha06())
                    .field("cmplcha07", &self.cmplcha07())
                    .field("cmplcha08", &self.cmplcha08())
                    .field("cmplcha09", &self.cmplcha09())
                    .field("cmplcha10", &self.cmplcha10())
                    .field("cmplcha11", &self.cmplcha11())
                    .field("cmplcha12", &self.cmplcha12())
                    .field("cmplcha13", &self.cmplcha13())
                    .field("cmplcha14", &self.cmplcha14())
                    .field("cmplcha15", &self.cmplcha15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmplr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmplr0 {{ cmplcha00: {:?}, cmplcha01: {:?}, cmplcha02: {:?}, cmplcha03: {:?}, cmplcha04: {:?}, cmplcha05: {:?}, cmplcha06: {:?}, cmplcha07: {:?}, cmplcha08: {:?}, cmplcha09: {:?}, cmplcha10: {:?}, cmplcha11: {:?}, cmplcha12: {:?}, cmplcha13: {:?}, cmplcha14: {:?}, cmplcha15: {:?} }}" , self . cmplcha00 () , self . cmplcha01 () , self . cmplcha02 () , self . cmplcha03 () , self . cmplcha04 () , self . cmplcha05 () , self . cmplcha06 () , self . cmplcha07 () , self . cmplcha08 () , self . cmplcha09 () , self . cmplcha10 () , self . cmplcha11 () , self . cmplcha12 () , self . cmplcha13 () , self . cmplcha14 () , self . cmplcha15 ())
            }
        }
        #[doc = "A/D Compare Function Window A Comparison Condition Setting Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmplr1(pub u16);
        impl Adcmplr1 {
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha16(&self) -> super::vals::Cmplcha16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmplcha16::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha16(&mut self, val: super::vals::Cmplcha16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha17(&self) -> super::vals::Cmplcha17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmplcha17::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha17(&mut self, val: super::vals::Cmplcha17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha18(&self) -> super::vals::Cmplcha18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmplcha18::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha18(&mut self, val: super::vals::Cmplcha18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha19(&self) -> super::vals::Cmplcha19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmplcha19::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha19(&mut self, val: super::vals::Cmplcha19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha20(&self) -> super::vals::Cmplcha20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmplcha20::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha20(&mut self, val: super::vals::Cmplcha20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha21(&self) -> super::vals::Cmplcha21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmplcha21::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha21(&mut self, val: super::vals::Cmplcha21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha22(&self) -> super::vals::Cmplcha22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmplcha22::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha22(&mut self, val: super::vals::Cmplcha22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha23(&self) -> super::vals::Cmplcha23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmplcha23::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha23(&mut self, val: super::vals::Cmplcha23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha24(&self) -> super::vals::Cmplcha24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmplcha24::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha24(&mut self, val: super::vals::Cmplcha24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha25(&self) -> super::vals::Cmplcha25 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmplcha25::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha25(&mut self, val: super::vals::Cmplcha25) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha26(&self) -> super::vals::Cmplcha26 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cmplcha26::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha26(&mut self, val: super::vals::Cmplcha26) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha27(&self) -> super::vals::Cmplcha27 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmplcha27::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha27(&mut self, val: super::vals::Cmplcha27) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha28(&self) -> super::vals::Cmplcha28 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cmplcha28::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha28(&mut self, val: super::vals::Cmplcha28) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha29(&self) -> super::vals::Cmplcha29 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmplcha29::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha29(&mut self, val: super::vals::Cmplcha29) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha30(&self) -> super::vals::Cmplcha30 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cmplcha30::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha30(&mut self, val: super::vals::Cmplcha30) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub const fn cmplcha31(&self) -> super::vals::Cmplcha31 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmplcha31::from_bits(val as u8)
            }
            #[doc = "Compare Window A Comparison Condition Select"]
            #[inline(always)]
            pub fn set_cmplcha31(&mut self, val: super::vals::Cmplcha31) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmplr1 {
            #[inline(always)]
            fn default() -> Adcmplr1 {
                Adcmplr1(0)
            }
        }
        impl core::fmt::Debug for Adcmplr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmplr1")
                    .field("cmplcha16", &self.cmplcha16())
                    .field("cmplcha17", &self.cmplcha17())
                    .field("cmplcha18", &self.cmplcha18())
                    .field("cmplcha19", &self.cmplcha19())
                    .field("cmplcha20", &self.cmplcha20())
                    .field("cmplcha21", &self.cmplcha21())
                    .field("cmplcha22", &self.cmplcha22())
                    .field("cmplcha23", &self.cmplcha23())
                    .field("cmplcha24", &self.cmplcha24())
                    .field("cmplcha25", &self.cmplcha25())
                    .field("cmplcha26", &self.cmplcha26())
                    .field("cmplcha27", &self.cmplcha27())
                    .field("cmplcha28", &self.cmplcha28())
                    .field("cmplcha29", &self.cmplcha29())
                    .field("cmplcha30", &self.cmplcha30())
                    .field("cmplcha31", &self.cmplcha31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmplr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmplr1 {{ cmplcha16: {:?}, cmplcha17: {:?}, cmplcha18: {:?}, cmplcha19: {:?}, cmplcha20: {:?}, cmplcha21: {:?}, cmplcha22: {:?}, cmplcha23: {:?}, cmplcha24: {:?}, cmplcha25: {:?}, cmplcha26: {:?}, cmplcha27: {:?}, cmplcha28: {:?}, cmplcha29: {:?}, cmplcha30: {:?}, cmplcha31: {:?} }}" , self . cmplcha16 () , self . cmplcha17 () , self . cmplcha18 () , self . cmplcha19 () , self . cmplcha20 () , self . cmplcha21 () , self . cmplcha22 () , self . cmplcha23 () , self . cmplcha24 () , self . cmplcha25 () , self . cmplcha26 () , self . cmplcha27 () , self . cmplcha28 () , self . cmplcha29 () , self . cmplcha30 () , self . cmplcha31 ())
            }
        }
        #[doc = "A/D Compare Function Window A Extended Input Channel Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpser(pub u8);
        impl Adcmpser {
            #[doc = "Compare Window A Temperature Sensor Output Compare Flag"]
            #[inline(always)]
            pub const fn cmpsttsa(&self) -> super::vals::Cmpsttsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpsttsa::from_bits(val as u8)
            }
            #[doc = "Compare Window A Temperature Sensor Output Compare Flag"]
            #[inline(always)]
            pub fn set_cmpsttsa(&mut self, val: super::vals::Cmpsttsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Internal Reference Voltage Compare Flag"]
            #[inline(always)]
            pub const fn cmpstoca(&self) -> super::vals::Cmpstoca {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpstoca::from_bits(val as u8)
            }
            #[doc = "Compare Window A Internal Reference Voltage Compare Flag"]
            #[inline(always)]
            pub fn set_cmpstoca(&mut self, val: super::vals::Cmpstoca) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Adcmpser {
            #[inline(always)]
            fn default() -> Adcmpser {
                Adcmpser(0)
            }
        }
        impl core::fmt::Debug for Adcmpser {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpser")
                    .field("cmpsttsa", &self.cmpsttsa())
                    .field("cmpstoca", &self.cmpstoca())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpser {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adcmpser {{ cmpsttsa: {:?}, cmpstoca: {:?} }}",
                    self.cmpsttsa(),
                    self.cmpstoca()
                )
            }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpsr0(pub u16);
        impl Adcmpsr0 {
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha00(&self) -> super::vals::Cmpstcha00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpstcha00::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha00(&mut self, val: super::vals::Cmpstcha00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha01(&self) -> super::vals::Cmpstcha01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpstcha01::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha01(&mut self, val: super::vals::Cmpstcha01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha02(&self) -> super::vals::Cmpstcha02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpstcha02::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha02(&mut self, val: super::vals::Cmpstcha02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha03(&self) -> super::vals::Cmpstcha03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpstcha03::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha03(&mut self, val: super::vals::Cmpstcha03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha04(&self) -> super::vals::Cmpstcha04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmpstcha04::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha04(&mut self, val: super::vals::Cmpstcha04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha05(&self) -> super::vals::Cmpstcha05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmpstcha05::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha05(&mut self, val: super::vals::Cmpstcha05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha06(&self) -> super::vals::Cmpstcha06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmpstcha06::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha06(&mut self, val: super::vals::Cmpstcha06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha07(&self) -> super::vals::Cmpstcha07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmpstcha07::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha07(&mut self, val: super::vals::Cmpstcha07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha08(&self) -> super::vals::Cmpstcha08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmpstcha08::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha08(&mut self, val: super::vals::Cmpstcha08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha09(&self) -> super::vals::Cmpstcha09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmpstcha09::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha09(&mut self, val: super::vals::Cmpstcha09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha10(&self) -> super::vals::Cmpstcha10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cmpstcha10::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha10(&mut self, val: super::vals::Cmpstcha10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha11(&self) -> super::vals::Cmpstcha11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmpstcha11::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha11(&mut self, val: super::vals::Cmpstcha11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha12(&self) -> super::vals::Cmpstcha12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cmpstcha12::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha12(&mut self, val: super::vals::Cmpstcha12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha13(&self) -> super::vals::Cmpstcha13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmpstcha13::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha13(&mut self, val: super::vals::Cmpstcha13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha14(&self) -> super::vals::Cmpstcha14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cmpstcha14::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha14(&mut self, val: super::vals::Cmpstcha14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha15(&self) -> super::vals::Cmpstcha15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmpstcha15::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha15(&mut self, val: super::vals::Cmpstcha15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmpsr0 {
            #[inline(always)]
            fn default() -> Adcmpsr0 {
                Adcmpsr0(0)
            }
        }
        impl core::fmt::Debug for Adcmpsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpsr0")
                    .field("cmpstcha00", &self.cmpstcha00())
                    .field("cmpstcha01", &self.cmpstcha01())
                    .field("cmpstcha02", &self.cmpstcha02())
                    .field("cmpstcha03", &self.cmpstcha03())
                    .field("cmpstcha04", &self.cmpstcha04())
                    .field("cmpstcha05", &self.cmpstcha05())
                    .field("cmpstcha06", &self.cmpstcha06())
                    .field("cmpstcha07", &self.cmpstcha07())
                    .field("cmpstcha08", &self.cmpstcha08())
                    .field("cmpstcha09", &self.cmpstcha09())
                    .field("cmpstcha10", &self.cmpstcha10())
                    .field("cmpstcha11", &self.cmpstcha11())
                    .field("cmpstcha12", &self.cmpstcha12())
                    .field("cmpstcha13", &self.cmpstcha13())
                    .field("cmpstcha14", &self.cmpstcha14())
                    .field("cmpstcha15", &self.cmpstcha15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpsr0 {{ cmpstcha00: {:?}, cmpstcha01: {:?}, cmpstcha02: {:?}, cmpstcha03: {:?}, cmpstcha04: {:?}, cmpstcha05: {:?}, cmpstcha06: {:?}, cmpstcha07: {:?}, cmpstcha08: {:?}, cmpstcha09: {:?}, cmpstcha10: {:?}, cmpstcha11: {:?}, cmpstcha12: {:?}, cmpstcha13: {:?}, cmpstcha14: {:?}, cmpstcha15: {:?} }}" , self . cmpstcha00 () , self . cmpstcha01 () , self . cmpstcha02 () , self . cmpstcha03 () , self . cmpstcha04 () , self . cmpstcha05 () , self . cmpstcha06 () , self . cmpstcha07 () , self . cmpstcha08 () , self . cmpstcha09 () , self . cmpstcha10 () , self . cmpstcha11 () , self . cmpstcha12 () , self . cmpstcha13 () , self . cmpstcha14 () , self . cmpstcha15 ())
            }
        }
        #[doc = "A/D Compare Function Window A Channel Status Register1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcmpsr1(pub u16);
        impl Adcmpsr1 {
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha16(&self) -> super::vals::Cmpstcha16 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cmpstcha16::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha16(&mut self, val: super::vals::Cmpstcha16) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha17(&self) -> super::vals::Cmpstcha17 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmpstcha17::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha17(&mut self, val: super::vals::Cmpstcha17) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha18(&self) -> super::vals::Cmpstcha18 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cmpstcha18::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha18(&mut self, val: super::vals::Cmpstcha18) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha19(&self) -> super::vals::Cmpstcha19 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmpstcha19::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha19(&mut self, val: super::vals::Cmpstcha19) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha20(&self) -> super::vals::Cmpstcha20 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cmpstcha20::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha20(&mut self, val: super::vals::Cmpstcha20) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha21(&self) -> super::vals::Cmpstcha21 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cmpstcha21::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha21(&mut self, val: super::vals::Cmpstcha21) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha22(&self) -> super::vals::Cmpstcha22 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cmpstcha22::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha22(&mut self, val: super::vals::Cmpstcha22) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha23(&self) -> super::vals::Cmpstcha23 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cmpstcha23::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha23(&mut self, val: super::vals::Cmpstcha23) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha24(&self) -> super::vals::Cmpstcha24 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cmpstcha24::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha24(&mut self, val: super::vals::Cmpstcha24) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha25(&self) -> super::vals::Cmpstcha25 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cmpstcha25::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha25(&mut self, val: super::vals::Cmpstcha25) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha26(&self) -> super::vals::Cmpstcha26 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cmpstcha26::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha26(&mut self, val: super::vals::Cmpstcha26) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha27(&self) -> super::vals::Cmpstcha27 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cmpstcha27::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha27(&mut self, val: super::vals::Cmpstcha27) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha28(&self) -> super::vals::Cmpstcha28 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cmpstcha28::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha28(&mut self, val: super::vals::Cmpstcha28) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha29(&self) -> super::vals::Cmpstcha29 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cmpstcha29::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha29(&mut self, val: super::vals::Cmpstcha29) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha30(&self) -> super::vals::Cmpstcha30 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cmpstcha30::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha30(&mut self, val: super::vals::Cmpstcha30) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub const fn cmpstcha31(&self) -> super::vals::Cmpstcha31 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cmpstcha31::from_bits(val as u8)
            }
            #[doc = "Compare Window A Flag"]
            #[inline(always)]
            pub fn set_cmpstcha31(&mut self, val: super::vals::Cmpstcha31) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcmpsr1 {
            #[inline(always)]
            fn default() -> Adcmpsr1 {
                Adcmpsr1(0)
            }
        }
        impl core::fmt::Debug for Adcmpsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcmpsr1")
                    .field("cmpstcha16", &self.cmpstcha16())
                    .field("cmpstcha17", &self.cmpstcha17())
                    .field("cmpstcha18", &self.cmpstcha18())
                    .field("cmpstcha19", &self.cmpstcha19())
                    .field("cmpstcha20", &self.cmpstcha20())
                    .field("cmpstcha21", &self.cmpstcha21())
                    .field("cmpstcha22", &self.cmpstcha22())
                    .field("cmpstcha23", &self.cmpstcha23())
                    .field("cmpstcha24", &self.cmpstcha24())
                    .field("cmpstcha25", &self.cmpstcha25())
                    .field("cmpstcha26", &self.cmpstcha26())
                    .field("cmpstcha27", &self.cmpstcha27())
                    .field("cmpstcha28", &self.cmpstcha28())
                    .field("cmpstcha29", &self.cmpstcha29())
                    .field("cmpstcha30", &self.cmpstcha30())
                    .field("cmpstcha31", &self.cmpstcha31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcmpsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcmpsr1 {{ cmpstcha16: {:?}, cmpstcha17: {:?}, cmpstcha18: {:?}, cmpstcha19: {:?}, cmpstcha20: {:?}, cmpstcha21: {:?}, cmpstcha22: {:?}, cmpstcha23: {:?}, cmpstcha24: {:?}, cmpstcha25: {:?}, cmpstcha26: {:?}, cmpstcha27: {:?}, cmpstcha28: {:?}, cmpstcha29: {:?}, cmpstcha30: {:?}, cmpstcha31: {:?} }}" , self . cmpstcha16 () , self . cmpstcha17 () , self . cmpstcha18 () , self . cmpstcha19 () , self . cmpstcha20 () , self . cmpstcha21 () , self . cmpstcha22 () , self . cmpstcha23 () , self . cmpstcha24 () , self . cmpstcha25 () , self . cmpstcha26 () , self . cmpstcha27 () , self . cmpstcha28 () , self . cmpstcha29 () , self . cmpstcha30 () , self . cmpstcha31 ())
            }
        }
        #[doc = "A/D Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adcsr(pub u16);
        impl Adcsr {
            #[doc = "Double Trigger Channel Select"]
            #[inline(always)]
            pub const fn dblans(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Double Trigger Channel Select"]
            #[inline(always)]
            pub fn set_dblans(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u16) & 0x1f) << 0usize);
            }
            #[doc = "Group B Scan End Interrupt and ELC Event Enable"]
            #[inline(always)]
            pub const fn gbadie(&self) -> super::vals::Gbadie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Gbadie::from_bits(val as u8)
            }
            #[doc = "Group B Scan End Interrupt and ELC Event Enable"]
            #[inline(always)]
            pub fn set_gbadie(&mut self, val: super::vals::Gbadie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Double Trigger Mode Select"]
            #[inline(always)]
            pub const fn dble(&self) -> super::vals::Dble {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dble::from_bits(val as u8)
            }
            #[doc = "Double Trigger Mode Select"]
            #[inline(always)]
            pub fn set_dble(&mut self, val: super::vals::Dble) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Trigger Select"]
            #[inline(always)]
            pub const fn extrg(&self) -> super::vals::Extrg {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Extrg::from_bits(val as u8)
            }
            #[doc = "Trigger Select"]
            #[inline(always)]
            pub fn set_extrg(&mut self, val: super::vals::Extrg) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Trigger Start Enable"]
            #[inline(always)]
            pub const fn trge(&self) -> super::vals::Trge {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Trge::from_bits(val as u8)
            }
            #[doc = "Trigger Start Enable"]
            #[inline(always)]
            pub fn set_trge(&mut self, val: super::vals::Trge) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "A/D Conversion Mode Select"]
            #[inline(always)]
            pub const fn adhsc(&self) -> super::vals::Adhsc {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Adhsc::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Mode Select"]
            #[inline(always)]
            pub fn set_adhsc(&mut self, val: super::vals::Adhsc) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Scan Mode Select"]
            #[inline(always)]
            pub const fn adcs(&self) -> super::vals::Adcs {
                let val = (self.0 >> 13usize) & 0x03;
                super::vals::Adcs::from_bits(val as u8)
            }
            #[doc = "Scan Mode Select"]
            #[inline(always)]
            pub fn set_adcs(&mut self, val: super::vals::Adcs) {
                self.0 =
                    (self.0 & !(0x03 << 13usize)) | (((val.to_bits() as u16) & 0x03) << 13usize);
            }
            #[doc = "A/D Conversion Start"]
            #[inline(always)]
            pub const fn adst(&self) -> super::vals::Adst {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Adst::from_bits(val as u8)
            }
            #[doc = "A/D Conversion Start"]
            #[inline(always)]
            pub fn set_adst(&mut self, val: super::vals::Adst) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adcsr {
            #[inline(always)]
            fn default() -> Adcsr {
                Adcsr(0)
            }
        }
        impl core::fmt::Debug for Adcsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adcsr")
                    .field("dblans", &self.dblans())
                    .field("gbadie", &self.gbadie())
                    .field("dble", &self.dble())
                    .field("extrg", &self.extrg())
                    .field("trge", &self.trge())
                    .field("adhsc", &self.adhsc())
                    .field("adcs", &self.adcs())
                    .field("adst", &self.adst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adcsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Adcsr {{ dblans: {=u8:?}, gbadie: {:?}, dble: {:?}, extrg: {:?}, trge: {:?}, adhsc: {:?}, adcs: {:?}, adst: {:?} }}" , self . dblans () , self . gbadie () , self . dble () , self . extrg () , self . trge () , self . adhsc () , self . adcs () , self . adst ())
            }
        }
        #[doc = "A/D Data Duplexing Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldr(pub u16);
        impl Addbldr {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addbldr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addbldr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldr {
            #[inline(always)]
            fn default() -> Addbldr {
                Addbldr(0)
            }
        }
        impl core::fmt::Debug for Addbldr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldr")
                    .field("addbldr", &self.addbldr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldr {{ addbldr: {=u16:?} }}", self.addbldr())
            }
        }
        #[doc = "A/D Data Duplexing Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldra(pub u16);
        impl Addbldra {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addbldr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addbldr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldra {
            #[inline(always)]
            fn default() -> Addbldra {
                Addbldra(0)
            }
        }
        impl core::fmt::Debug for Addbldra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldra")
                    .field("addbldr", &self.addbldr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldra {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldra {{ addbldr: {=u16:?} }}", self.addbldr())
            }
        }
        #[doc = "A/D Data Duplexing Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addbldrb(pub u16);
        impl Addbldrb {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addbldr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addbldr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addbldrb {
            #[inline(always)]
            fn default() -> Addbldrb {
                Addbldrb(0)
            }
        }
        impl core::fmt::Debug for Addbldrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addbldrb")
                    .field("addbldr", &self.addbldr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addbldrb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addbldrb {{ addbldr: {=u16:?} }}", self.addbldr())
            }
        }
        #[doc = "A/D Disconnection Detection Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addiscr(pub u8);
        impl Addiscr {
            #[doc = "Disconnection Detection Assist Setting"]
            #[inline(always)]
            pub const fn adndis(&self) -> super::vals::Adndis {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Adndis::from_bits(val as u8)
            }
            #[doc = "Disconnection Detection Assist Setting"]
            #[inline(always)]
            pub fn set_adndis(&mut self, val: super::vals::Adndis) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
            #[doc = "Precharge/discharge select"]
            #[inline(always)]
            pub const fn pchg(&self) -> super::vals::Pchg {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pchg::from_bits(val as u8)
            }
            #[doc = "Precharge/discharge select"]
            #[inline(always)]
            pub fn set_pchg(&mut self, val: super::vals::Pchg) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Addiscr {
            #[inline(always)]
            fn default() -> Addiscr {
                Addiscr(0)
            }
        }
        impl core::fmt::Debug for Addiscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addiscr")
                    .field("adndis", &self.adndis())
                    .field("pchg", &self.pchg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addiscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Addiscr {{ adndis: {:?}, pchg: {:?} }}",
                    self.adndis(),
                    self.pchg()
                )
            }
        }
        #[doc = "A/D Data Registers %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addr(pub u16);
        impl Addr {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addr {
            #[inline(always)]
            fn default() -> Addr {
                Addr(0)
            }
        }
        impl core::fmt::Debug for Addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addr").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addr {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "A/D Data Registers %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addr1(pub u16);
        impl Addr1 {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addr1 {
            #[inline(always)]
            fn default() -> Addr1 {
                Addr1(0)
            }
        }
        impl core::fmt::Debug for Addr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addr1").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addr1 {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "A/D Data Registers %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Addr2(pub u16);
        impl Addr2 {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Addr2 {
            #[inline(always)]
            fn default() -> Addr2 {
                Addr2(0)
            }
        }
        impl core::fmt::Debug for Addr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Addr2").field("addr", &self.addr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Addr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Addr2 {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "A/D Conversion Extended Input Control Registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adexicr(pub u16);
        impl Adexicr {
            #[doc = "Temperature Sensor Output A/D,Converted Value Addition/Average Mode Select"]
            #[inline(always)]
            pub const fn tssad(&self) -> super::vals::Tssad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tssad::from_bits(val as u8)
            }
            #[doc = "Temperature Sensor Output A/D,Converted Value Addition/Average Mode Select"]
            #[inline(always)]
            pub fn set_tssad(&mut self, val: super::vals::Tssad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Internal Reference Voltage A/D,Converted Value Addition/Average Mode Select"]
            #[inline(always)]
            pub const fn ocsad(&self) -> super::vals::Ocsad {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ocsad::from_bits(val as u8)
            }
            #[doc = "Internal Reference Voltage A/D,Converted Value Addition/Average Mode Select"]
            #[inline(always)]
            pub fn set_ocsad(&mut self, val: super::vals::Ocsad) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Temperature Sensor Output A/D Conversion Select"]
            #[inline(always)]
            pub const fn tssa(&self) -> super::vals::Tssa {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Tssa::from_bits(val as u8)
            }
            #[doc = "Temperature Sensor Output A/D Conversion Select"]
            #[inline(always)]
            pub fn set_tssa(&mut self, val: super::vals::Tssa) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Internal Reference Voltage A/D Conversion Select"]
            #[inline(always)]
            pub const fn ocsa(&self) -> super::vals::Ocsa {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ocsa::from_bits(val as u8)
            }
            #[doc = "Internal Reference Voltage A/D Conversion Select"]
            #[inline(always)]
            pub fn set_ocsa(&mut self, val: super::vals::Ocsa) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
        }
        impl Default for Adexicr {
            #[inline(always)]
            fn default() -> Adexicr {
                Adexicr(0)
            }
        }
        impl core::fmt::Debug for Adexicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adexicr")
                    .field("tssad", &self.tssad())
                    .field("ocsad", &self.ocsad())
                    .field("tssa", &self.tssa())
                    .field("ocsa", &self.ocsa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adexicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adexicr {{ tssad: {:?}, ocsad: {:?}, tssa: {:?}, ocsa: {:?} }}",
                    self.tssad(),
                    self.ocsad(),
                    self.tssa(),
                    self.ocsa()
                )
            }
        }
        #[doc = "A/D Group Scan Priority Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adgspcr(pub u16);
        impl Adgspcr {
            #[doc = "Group Priority Operation Setting"]
            #[inline(always)]
            pub const fn pgs(&self) -> super::vals::Pgs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pgs::from_bits(val as u8)
            }
            #[doc = "Group Priority Operation Setting"]
            #[inline(always)]
            pub fn set_pgs(&mut self, val: super::vals::Pgs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Lower,Priority Group Restart Setting"]
            #[inline(always)]
            pub const fn gbrscn(&self) -> super::vals::Gbrscn {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Gbrscn::from_bits(val as u8)
            }
            #[doc = "Lower,Priority Group Restart Setting"]
            #[inline(always)]
            pub fn set_gbrscn(&mut self, val: super::vals::Gbrscn) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Single Scan Continuous Start"]
            #[inline(always)]
            pub const fn gbrp(&self) -> super::vals::Gbrp {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Gbrp::from_bits(val as u8)
            }
            #[doc = "Single Scan Continuous Start"]
            #[inline(always)]
            pub fn set_gbrp(&mut self, val: super::vals::Gbrp) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Adgspcr {
            #[inline(always)]
            fn default() -> Adgspcr {
                Adgspcr(0)
            }
        }
        impl core::fmt::Debug for Adgspcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adgspcr")
                    .field("pgs", &self.pgs())
                    .field("gbrscn", &self.gbrscn())
                    .field("gbrp", &self.gbrp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adgspcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adgspcr {{ pgs: {:?}, gbrscn: {:?}, gbrp: {:?} }}",
                    self.pgs(),
                    self.gbrscn(),
                    self.gbrp()
                )
            }
        }
        #[doc = "A/D High,Potential/Low,Potential Reference Voltage Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adhvrefcnt(pub u8);
        impl Adhvrefcnt {
            #[doc = "High,Potential Reference Voltage Select"]
            #[inline(always)]
            pub const fn hvsel(&self) -> super::vals::Hvsel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Hvsel::from_bits(val as u8)
            }
            #[doc = "High,Potential Reference Voltage Select"]
            #[inline(always)]
            pub fn set_hvsel(&mut self, val: super::vals::Hvsel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Low,Potential Reference Voltage Select"]
            #[inline(always)]
            pub const fn lvsel(&self) -> super::vals::Lvsel {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Lvsel::from_bits(val as u8)
            }
            #[doc = "Low,Potential Reference Voltage Select"]
            #[inline(always)]
            pub fn set_lvsel(&mut self, val: super::vals::Lvsel) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Sleep"]
            #[inline(always)]
            pub const fn adslp(&self) -> super::vals::Adslp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Adslp::from_bits(val as u8)
            }
            #[doc = "Sleep"]
            #[inline(always)]
            pub fn set_adslp(&mut self, val: super::vals::Adslp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Adhvrefcnt {
            #[inline(always)]
            fn default() -> Adhvrefcnt {
                Adhvrefcnt(0)
            }
        }
        impl core::fmt::Debug for Adhvrefcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adhvrefcnt")
                    .field("hvsel", &self.hvsel())
                    .field("lvsel", &self.lvsel())
                    .field("adslp", &self.adslp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adhvrefcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adhvrefcnt {{ hvsel: {:?}, lvsel: {:?}, adslp: {:?} }}",
                    self.hvsel(),
                    self.lvsel(),
                    self.adslp()
                )
            }
        }
        #[doc = "A/D Internal Reference Voltage Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adocdr(pub u16);
        impl Adocdr {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn adocdr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_adocdr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adocdr {
            #[inline(always)]
            fn default() -> Adocdr {
                Adocdr(0)
            }
        }
        impl core::fmt::Debug for Adocdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adocdr")
                    .field("adocdr", &self.adocdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adocdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adocdr {{ adocdr: {=u16:?} }}", self.adocdr())
            }
        }
        #[doc = "A/D Self,Diagnosis Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adrd(pub u16);
        impl Adrd {
            #[doc = "Converted Value 11 to 0"]
            #[inline(always)]
            pub const fn ad(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Converted Value 11 to 0"]
            #[inline(always)]
            pub fn set_ad(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u16) & 0x0fff) << 0usize);
            }
            #[doc = "Self,Diagnosis Status"]
            #[inline(always)]
            pub const fn diagst(&self) -> super::vals::Diagst {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Diagst::from_bits(val as u8)
            }
            #[doc = "Self,Diagnosis Status"]
            #[inline(always)]
            pub fn set_diagst(&mut self, val: super::vals::Diagst) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u16) & 0x03) << 14usize);
            }
        }
        impl Default for Adrd {
            #[inline(always)]
            fn default() -> Adrd {
                Adrd(0)
            }
        }
        impl core::fmt::Debug for Adrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adrd")
                    .field("ad", &self.ad())
                    .field("diagst", &self.diagst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adrd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adrd {{ ad: {=u16:?}, diagst: {:?} }}",
                    self.ad(),
                    self.diagst()
                )
            }
        }
        #[doc = "A/D Sampling State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstr(pub u8);
        impl Adsstr {
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstr {
            #[inline(always)]
            fn default() -> Adsstr {
                Adsstr(0)
            }
        }
        impl core::fmt::Debug for Adsstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstr").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstr {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstr1(pub u8);
        impl Adsstr1 {
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstr1 {
            #[inline(always)]
            fn default() -> Adsstr1 {
                Adsstr1(0)
            }
        }
        impl core::fmt::Debug for Adsstr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstr1").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstr1 {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstrl(pub u8);
        impl Adsstrl {
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstrl {
            #[inline(always)]
            fn default() -> Adsstrl {
                Adsstrl(0)
            }
        }
        impl core::fmt::Debug for Adsstrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstrl").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstrl {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstro(pub u8);
        impl Adsstro {
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstro {
            #[inline(always)]
            fn default() -> Adsstro {
                Adsstro(0)
            }
        }
        impl core::fmt::Debug for Adsstro {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstro").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstro {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstro {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Sampling State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adsstrt(pub u8);
        impl Adsstrt {
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub const fn sst(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sampling Time Setting"]
            #[inline(always)]
            pub fn set_sst(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Adsstrt {
            #[inline(always)]
            fn default() -> Adsstrt {
                Adsstrt(0)
            }
        }
        impl core::fmt::Debug for Adsstrt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adsstrt").field("sst", &self.sst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adsstrt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adsstrt {{ sst: {=u8:?} }}", self.sst())
            }
        }
        #[doc = "A/D Conversion Start Trigger Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adstrgr(pub u16);
        impl Adstrgr {
            #[doc = "A/D Conversion Start Trigger Select for Group B"]
            #[inline(always)]
            pub const fn trsb(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "A/D Conversion Start Trigger Select for Group B"]
            #[inline(always)]
            pub fn set_trsb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u16) & 0x3f) << 0usize);
            }
            #[doc = "A/D Conversion Start Trigger Select"]
            #[inline(always)]
            pub const fn trsa(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "A/D Conversion Start Trigger Select"]
            #[inline(always)]
            pub fn set_trsa(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u16) & 0x3f) << 8usize);
            }
        }
        impl Default for Adstrgr {
            #[inline(always)]
            fn default() -> Adstrgr {
                Adstrgr(0)
            }
        }
        impl core::fmt::Debug for Adstrgr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adstrgr")
                    .field("trsb", &self.trsb())
                    .field("trsa", &self.trsa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adstrgr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adstrgr {{ trsb: {=u8:?}, trsa: {=u8:?} }}",
                    self.trsb(),
                    self.trsa()
                )
            }
        }
        #[doc = "A/D Temperature Sensor Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adtsdr(pub u16);
        impl Adtsdr {
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub const fn adtsdr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Converted Value 15 to 0"]
            #[inline(always)]
            pub fn set_adtsdr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Adtsdr {
            #[inline(always)]
            fn default() -> Adtsdr {
                Adtsdr(0)
            }
        }
        impl core::fmt::Debug for Adtsdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adtsdr")
                    .field("adtsdr", &self.adtsdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adtsdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adtsdr {{ adtsdr: {=u16:?} }}", self.adtsdr())
            }
        }
        #[doc = "A/D Compare Function Window A/B Status Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adwinmon(pub u8);
        impl Adwinmon {
            #[doc = "Combination Result Monitor"]
            #[inline(always)]
            pub const fn moncomb(&self) -> super::vals::Moncomb {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Moncomb::from_bits(val as u8)
            }
            #[doc = "Combination Result Monitor"]
            #[inline(always)]
            pub fn set_moncomb(&mut self, val: super::vals::Moncomb) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Comparison Result Monitor A"]
            #[inline(always)]
            pub const fn moncmpa(&self) -> super::vals::Moncmpa {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Moncmpa::from_bits(val as u8)
            }
            #[doc = "Comparison Result Monitor A"]
            #[inline(always)]
            pub fn set_moncmpa(&mut self, val: super::vals::Moncmpa) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Comparison Result Monitor B"]
            #[inline(always)]
            pub const fn moncmpb(&self) -> super::vals::Moncmpb {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Moncmpb::from_bits(val as u8)
            }
            #[doc = "Comparison Result Monitor B"]
            #[inline(always)]
            pub fn set_moncmpb(&mut self, val: super::vals::Moncmpb) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Adwinmon {
            #[inline(always)]
            fn default() -> Adwinmon {
                Adwinmon(0)
            }
        }
        impl core::fmt::Debug for Adwinmon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adwinmon")
                    .field("moncomb", &self.moncomb())
                    .field("moncmpa", &self.moncmpa())
                    .field("moncmpb", &self.moncmpb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adwinmon {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Adwinmon {{ moncomb: {:?}, moncmpa: {:?}, moncmpb: {:?} }}",
                    self.moncomb(),
                    self.moncmpa(),
                    self.moncmpb()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ace {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ace {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ace {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ace {
            #[inline(always)]
            fn from(val: u8) -> Ace {
                Ace::from_bits(val)
            }
        }
        impl From<Ace> for u8 {
            #[inline(always)]
            fn from(val: Ace) -> u8 {
                Ace::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Adc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adc {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adc {
            #[inline(always)]
            fn from(val: u8) -> Adc {
                Adc::from_bits(val)
            }
        }
        impl From<Adc> for u8 {
            #[inline(always)]
            fn from(val: Adc) -> u8 {
                Adc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Adcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adcs {
            #[inline(always)]
            fn from(val: u8) -> Adcs {
                Adcs::from_bits(val)
            }
        }
        impl From<Adcs> for u8 {
            #[inline(always)]
            fn from(val: Adcs) -> u8 {
                Adcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adhsc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adhsc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adhsc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adhsc {
            #[inline(always)]
            fn from(val: u8) -> Adhsc {
                Adhsc::from_bits(val)
            }
        }
        impl From<Adhsc> for u8 {
            #[inline(always)]
            fn from(val: Adhsc) -> u8 {
                Adhsc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adndis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Adndis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adndis {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adndis {
            #[inline(always)]
            fn from(val: u8) -> Adndis {
                Adndis::from_bits(val)
            }
        }
        impl From<Adndis> for u8 {
            #[inline(always)]
            fn from(val: Adndis) -> u8 {
                Adndis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adrfmt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adrfmt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adrfmt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adrfmt {
            #[inline(always)]
            fn from(val: u8) -> Adrfmt {
                Adrfmt::from_bits(val)
            }
        }
        impl From<Adrfmt> for u8 {
            #[inline(always)]
            fn from(val: Adrfmt) -> u8 {
                Adrfmt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads00 {
            #[inline(always)]
            fn from(val: u8) -> Ads00 {
                Ads00::from_bits(val)
            }
        }
        impl From<Ads00> for u8 {
            #[inline(always)]
            fn from(val: Ads00) -> u8 {
                Ads00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads01 {
            #[inline(always)]
            fn from(val: u8) -> Ads01 {
                Ads01::from_bits(val)
            }
        }
        impl From<Ads01> for u8 {
            #[inline(always)]
            fn from(val: Ads01) -> u8 {
                Ads01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads02 {
            #[inline(always)]
            fn from(val: u8) -> Ads02 {
                Ads02::from_bits(val)
            }
        }
        impl From<Ads02> for u8 {
            #[inline(always)]
            fn from(val: Ads02) -> u8 {
                Ads02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads03 {
            #[inline(always)]
            fn from(val: u8) -> Ads03 {
                Ads03::from_bits(val)
            }
        }
        impl From<Ads03> for u8 {
            #[inline(always)]
            fn from(val: Ads03) -> u8 {
                Ads03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads04 {
            #[inline(always)]
            fn from(val: u8) -> Ads04 {
                Ads04::from_bits(val)
            }
        }
        impl From<Ads04> for u8 {
            #[inline(always)]
            fn from(val: Ads04) -> u8 {
                Ads04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads05 {
            #[inline(always)]
            fn from(val: u8) -> Ads05 {
                Ads05::from_bits(val)
            }
        }
        impl From<Ads05> for u8 {
            #[inline(always)]
            fn from(val: Ads05) -> u8 {
                Ads05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads06 {
            #[inline(always)]
            fn from(val: u8) -> Ads06 {
                Ads06::from_bits(val)
            }
        }
        impl From<Ads06> for u8 {
            #[inline(always)]
            fn from(val: Ads06) -> u8 {
                Ads06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads07 {
            #[inline(always)]
            fn from(val: u8) -> Ads07 {
                Ads07::from_bits(val)
            }
        }
        impl From<Ads07> for u8 {
            #[inline(always)]
            fn from(val: Ads07) -> u8 {
                Ads07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads08 {
            #[inline(always)]
            fn from(val: u8) -> Ads08 {
                Ads08::from_bits(val)
            }
        }
        impl From<Ads08> for u8 {
            #[inline(always)]
            fn from(val: Ads08) -> u8 {
                Ads08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads09 {
            #[inline(always)]
            fn from(val: u8) -> Ads09 {
                Ads09::from_bits(val)
            }
        }
        impl From<Ads09> for u8 {
            #[inline(always)]
            fn from(val: Ads09) -> u8 {
                Ads09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads10 {
            #[inline(always)]
            fn from(val: u8) -> Ads10 {
                Ads10::from_bits(val)
            }
        }
        impl From<Ads10> for u8 {
            #[inline(always)]
            fn from(val: Ads10) -> u8 {
                Ads10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads11 {
            #[inline(always)]
            fn from(val: u8) -> Ads11 {
                Ads11::from_bits(val)
            }
        }
        impl From<Ads11> for u8 {
            #[inline(always)]
            fn from(val: Ads11) -> u8 {
                Ads11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads12 {
            #[inline(always)]
            fn from(val: u8) -> Ads12 {
                Ads12::from_bits(val)
            }
        }
        impl From<Ads12> for u8 {
            #[inline(always)]
            fn from(val: Ads12) -> u8 {
                Ads12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads13 {
            #[inline(always)]
            fn from(val: u8) -> Ads13 {
                Ads13::from_bits(val)
            }
        }
        impl From<Ads13> for u8 {
            #[inline(always)]
            fn from(val: Ads13) -> u8 {
                Ads13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads14 {
            #[inline(always)]
            fn from(val: u8) -> Ads14 {
                Ads14::from_bits(val)
            }
        }
        impl From<Ads14> for u8 {
            #[inline(always)]
            fn from(val: Ads14) -> u8 {
                Ads14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads15 {
            #[inline(always)]
            fn from(val: u8) -> Ads15 {
                Ads15::from_bits(val)
            }
        }
        impl From<Ads15> for u8 {
            #[inline(always)]
            fn from(val: Ads15) -> u8 {
                Ads15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads16 {
            #[inline(always)]
            fn from(val: u8) -> Ads16 {
                Ads16::from_bits(val)
            }
        }
        impl From<Ads16> for u8 {
            #[inline(always)]
            fn from(val: Ads16) -> u8 {
                Ads16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads17 {
            #[inline(always)]
            fn from(val: u8) -> Ads17 {
                Ads17::from_bits(val)
            }
        }
        impl From<Ads17> for u8 {
            #[inline(always)]
            fn from(val: Ads17) -> u8 {
                Ads17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads18 {
            #[inline(always)]
            fn from(val: u8) -> Ads18 {
                Ads18::from_bits(val)
            }
        }
        impl From<Ads18> for u8 {
            #[inline(always)]
            fn from(val: Ads18) -> u8 {
                Ads18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads19 {
            #[inline(always)]
            fn from(val: u8) -> Ads19 {
                Ads19::from_bits(val)
            }
        }
        impl From<Ads19> for u8 {
            #[inline(always)]
            fn from(val: Ads19) -> u8 {
                Ads19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads20 {
            #[inline(always)]
            fn from(val: u8) -> Ads20 {
                Ads20::from_bits(val)
            }
        }
        impl From<Ads20> for u8 {
            #[inline(always)]
            fn from(val: Ads20) -> u8 {
                Ads20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads21 {
            #[inline(always)]
            fn from(val: u8) -> Ads21 {
                Ads21::from_bits(val)
            }
        }
        impl From<Ads21> for u8 {
            #[inline(always)]
            fn from(val: Ads21) -> u8 {
                Ads21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads22 {
            #[inline(always)]
            fn from(val: u8) -> Ads22 {
                Ads22::from_bits(val)
            }
        }
        impl From<Ads22> for u8 {
            #[inline(always)]
            fn from(val: Ads22) -> u8 {
                Ads22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads23 {
            #[inline(always)]
            fn from(val: u8) -> Ads23 {
                Ads23::from_bits(val)
            }
        }
        impl From<Ads23> for u8 {
            #[inline(always)]
            fn from(val: Ads23) -> u8 {
                Ads23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads24 {
            #[inline(always)]
            fn from(val: u8) -> Ads24 {
                Ads24::from_bits(val)
            }
        }
        impl From<Ads24> for u8 {
            #[inline(always)]
            fn from(val: Ads24) -> u8 {
                Ads24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads25 {
            #[inline(always)]
            fn from(val: u8) -> Ads25 {
                Ads25::from_bits(val)
            }
        }
        impl From<Ads25> for u8 {
            #[inline(always)]
            fn from(val: Ads25) -> u8 {
                Ads25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads26 {
            #[inline(always)]
            fn from(val: u8) -> Ads26 {
                Ads26::from_bits(val)
            }
        }
        impl From<Ads26> for u8 {
            #[inline(always)]
            fn from(val: Ads26) -> u8 {
                Ads26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads27 {
            #[inline(always)]
            fn from(val: u8) -> Ads27 {
                Ads27::from_bits(val)
            }
        }
        impl From<Ads27> for u8 {
            #[inline(always)]
            fn from(val: Ads27) -> u8 {
                Ads27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads28 {
            #[inline(always)]
            fn from(val: u8) -> Ads28 {
                Ads28::from_bits(val)
            }
        }
        impl From<Ads28> for u8 {
            #[inline(always)]
            fn from(val: Ads28) -> u8 {
                Ads28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads29 {
            #[inline(always)]
            fn from(val: u8) -> Ads29 {
                Ads29::from_bits(val)
            }
        }
        impl From<Ads29> for u8 {
            #[inline(always)]
            fn from(val: Ads29) -> u8 {
                Ads29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads30 {
            #[inline(always)]
            fn from(val: u8) -> Ads30 {
                Ads30::from_bits(val)
            }
        }
        impl From<Ads30> for u8 {
            #[inline(always)]
            fn from(val: Ads30) -> u8 {
                Ads30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ads31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ads31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ads31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ads31 {
            #[inline(always)]
            fn from(val: u8) -> Ads31 {
                Ads31::from_bits(val)
            }
        }
        impl From<Ads31> for u8 {
            #[inline(always)]
            fn from(val: Ads31) -> u8 {
                Ads31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adsac {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adsac {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adsac {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adsac {
            #[inline(always)]
            fn from(val: u8) -> Adsac {
                Adsac::from_bits(val)
            }
        }
        impl From<Adsac> for u8 {
            #[inline(always)]
            fn from(val: Adsac) -> u8 {
                Adsac::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adslp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adslp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adslp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adslp {
            #[inline(always)]
            fn from(val: u8) -> Adslp {
                Adslp::from_bits(val)
            }
        }
        impl From<Adslp> for u8 {
            #[inline(always)]
            fn from(val: Adslp) -> u8 {
                Adslp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Adst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Adst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Adst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Adst {
            #[inline(always)]
            fn from(val: u8) -> Adst {
                Adst::from_bits(val)
            }
        }
        impl From<Adst> for u8 {
            #[inline(always)]
            fn from(val: Adst) -> u8 {
                Adst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa00 {
            #[inline(always)]
            fn from(val: u8) -> Ansa00 {
                Ansa00::from_bits(val)
            }
        }
        impl From<Ansa00> for u8 {
            #[inline(always)]
            fn from(val: Ansa00) -> u8 {
                Ansa00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa01 {
            #[inline(always)]
            fn from(val: u8) -> Ansa01 {
                Ansa01::from_bits(val)
            }
        }
        impl From<Ansa01> for u8 {
            #[inline(always)]
            fn from(val: Ansa01) -> u8 {
                Ansa01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa02 {
            #[inline(always)]
            fn from(val: u8) -> Ansa02 {
                Ansa02::from_bits(val)
            }
        }
        impl From<Ansa02> for u8 {
            #[inline(always)]
            fn from(val: Ansa02) -> u8 {
                Ansa02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa03 {
            #[inline(always)]
            fn from(val: u8) -> Ansa03 {
                Ansa03::from_bits(val)
            }
        }
        impl From<Ansa03> for u8 {
            #[inline(always)]
            fn from(val: Ansa03) -> u8 {
                Ansa03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa04 {
            #[inline(always)]
            fn from(val: u8) -> Ansa04 {
                Ansa04::from_bits(val)
            }
        }
        impl From<Ansa04> for u8 {
            #[inline(always)]
            fn from(val: Ansa04) -> u8 {
                Ansa04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa05 {
            #[inline(always)]
            fn from(val: u8) -> Ansa05 {
                Ansa05::from_bits(val)
            }
        }
        impl From<Ansa05> for u8 {
            #[inline(always)]
            fn from(val: Ansa05) -> u8 {
                Ansa05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa06 {
            #[inline(always)]
            fn from(val: u8) -> Ansa06 {
                Ansa06::from_bits(val)
            }
        }
        impl From<Ansa06> for u8 {
            #[inline(always)]
            fn from(val: Ansa06) -> u8 {
                Ansa06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa07 {
            #[inline(always)]
            fn from(val: u8) -> Ansa07 {
                Ansa07::from_bits(val)
            }
        }
        impl From<Ansa07> for u8 {
            #[inline(always)]
            fn from(val: Ansa07) -> u8 {
                Ansa07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa08 {
            #[inline(always)]
            fn from(val: u8) -> Ansa08 {
                Ansa08::from_bits(val)
            }
        }
        impl From<Ansa08> for u8 {
            #[inline(always)]
            fn from(val: Ansa08) -> u8 {
                Ansa08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa09 {
            #[inline(always)]
            fn from(val: u8) -> Ansa09 {
                Ansa09::from_bits(val)
            }
        }
        impl From<Ansa09> for u8 {
            #[inline(always)]
            fn from(val: Ansa09) -> u8 {
                Ansa09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa10 {
            #[inline(always)]
            fn from(val: u8) -> Ansa10 {
                Ansa10::from_bits(val)
            }
        }
        impl From<Ansa10> for u8 {
            #[inline(always)]
            fn from(val: Ansa10) -> u8 {
                Ansa10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa11 {
            #[inline(always)]
            fn from(val: u8) -> Ansa11 {
                Ansa11::from_bits(val)
            }
        }
        impl From<Ansa11> for u8 {
            #[inline(always)]
            fn from(val: Ansa11) -> u8 {
                Ansa11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa12 {
            #[inline(always)]
            fn from(val: u8) -> Ansa12 {
                Ansa12::from_bits(val)
            }
        }
        impl From<Ansa12> for u8 {
            #[inline(always)]
            fn from(val: Ansa12) -> u8 {
                Ansa12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa13 {
            #[inline(always)]
            fn from(val: u8) -> Ansa13 {
                Ansa13::from_bits(val)
            }
        }
        impl From<Ansa13> for u8 {
            #[inline(always)]
            fn from(val: Ansa13) -> u8 {
                Ansa13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa14 {
            #[inline(always)]
            fn from(val: u8) -> Ansa14 {
                Ansa14::from_bits(val)
            }
        }
        impl From<Ansa14> for u8 {
            #[inline(always)]
            fn from(val: Ansa14) -> u8 {
                Ansa14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa15 {
            #[inline(always)]
            fn from(val: u8) -> Ansa15 {
                Ansa15::from_bits(val)
            }
        }
        impl From<Ansa15> for u8 {
            #[inline(always)]
            fn from(val: Ansa15) -> u8 {
                Ansa15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa16 {
            #[inline(always)]
            fn from(val: u8) -> Ansa16 {
                Ansa16::from_bits(val)
            }
        }
        impl From<Ansa16> for u8 {
            #[inline(always)]
            fn from(val: Ansa16) -> u8 {
                Ansa16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa17 {
            #[inline(always)]
            fn from(val: u8) -> Ansa17 {
                Ansa17::from_bits(val)
            }
        }
        impl From<Ansa17> for u8 {
            #[inline(always)]
            fn from(val: Ansa17) -> u8 {
                Ansa17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa18 {
            #[inline(always)]
            fn from(val: u8) -> Ansa18 {
                Ansa18::from_bits(val)
            }
        }
        impl From<Ansa18> for u8 {
            #[inline(always)]
            fn from(val: Ansa18) -> u8 {
                Ansa18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa19 {
            #[inline(always)]
            fn from(val: u8) -> Ansa19 {
                Ansa19::from_bits(val)
            }
        }
        impl From<Ansa19> for u8 {
            #[inline(always)]
            fn from(val: Ansa19) -> u8 {
                Ansa19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa20 {
            #[inline(always)]
            fn from(val: u8) -> Ansa20 {
                Ansa20::from_bits(val)
            }
        }
        impl From<Ansa20> for u8 {
            #[inline(always)]
            fn from(val: Ansa20) -> u8 {
                Ansa20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa21 {
            #[inline(always)]
            fn from(val: u8) -> Ansa21 {
                Ansa21::from_bits(val)
            }
        }
        impl From<Ansa21> for u8 {
            #[inline(always)]
            fn from(val: Ansa21) -> u8 {
                Ansa21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa22 {
            #[inline(always)]
            fn from(val: u8) -> Ansa22 {
                Ansa22::from_bits(val)
            }
        }
        impl From<Ansa22> for u8 {
            #[inline(always)]
            fn from(val: Ansa22) -> u8 {
                Ansa22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa23 {
            #[inline(always)]
            fn from(val: u8) -> Ansa23 {
                Ansa23::from_bits(val)
            }
        }
        impl From<Ansa23> for u8 {
            #[inline(always)]
            fn from(val: Ansa23) -> u8 {
                Ansa23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa24 {
            #[inline(always)]
            fn from(val: u8) -> Ansa24 {
                Ansa24::from_bits(val)
            }
        }
        impl From<Ansa24> for u8 {
            #[inline(always)]
            fn from(val: Ansa24) -> u8 {
                Ansa24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa25 {
            #[inline(always)]
            fn from(val: u8) -> Ansa25 {
                Ansa25::from_bits(val)
            }
        }
        impl From<Ansa25> for u8 {
            #[inline(always)]
            fn from(val: Ansa25) -> u8 {
                Ansa25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa26 {
            #[inline(always)]
            fn from(val: u8) -> Ansa26 {
                Ansa26::from_bits(val)
            }
        }
        impl From<Ansa26> for u8 {
            #[inline(always)]
            fn from(val: Ansa26) -> u8 {
                Ansa26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa27 {
            #[inline(always)]
            fn from(val: u8) -> Ansa27 {
                Ansa27::from_bits(val)
            }
        }
        impl From<Ansa27> for u8 {
            #[inline(always)]
            fn from(val: Ansa27) -> u8 {
                Ansa27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa28 {
            #[inline(always)]
            fn from(val: u8) -> Ansa28 {
                Ansa28::from_bits(val)
            }
        }
        impl From<Ansa28> for u8 {
            #[inline(always)]
            fn from(val: Ansa28) -> u8 {
                Ansa28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa29 {
            #[inline(always)]
            fn from(val: u8) -> Ansa29 {
                Ansa29::from_bits(val)
            }
        }
        impl From<Ansa29> for u8 {
            #[inline(always)]
            fn from(val: Ansa29) -> u8 {
                Ansa29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa30 {
            #[inline(always)]
            fn from(val: u8) -> Ansa30 {
                Ansa30::from_bits(val)
            }
        }
        impl From<Ansa30> for u8 {
            #[inline(always)]
            fn from(val: Ansa30) -> u8 {
                Ansa30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansa31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansa31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansa31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansa31 {
            #[inline(always)]
            fn from(val: u8) -> Ansa31 {
                Ansa31::from_bits(val)
            }
        }
        impl From<Ansa31> for u8 {
            #[inline(always)]
            fn from(val: Ansa31) -> u8 {
                Ansa31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb00 {
            #[inline(always)]
            fn from(val: u8) -> Ansb00 {
                Ansb00::from_bits(val)
            }
        }
        impl From<Ansb00> for u8 {
            #[inline(always)]
            fn from(val: Ansb00) -> u8 {
                Ansb00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb01 {
            #[inline(always)]
            fn from(val: u8) -> Ansb01 {
                Ansb01::from_bits(val)
            }
        }
        impl From<Ansb01> for u8 {
            #[inline(always)]
            fn from(val: Ansb01) -> u8 {
                Ansb01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb02 {
            #[inline(always)]
            fn from(val: u8) -> Ansb02 {
                Ansb02::from_bits(val)
            }
        }
        impl From<Ansb02> for u8 {
            #[inline(always)]
            fn from(val: Ansb02) -> u8 {
                Ansb02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb03 {
            #[inline(always)]
            fn from(val: u8) -> Ansb03 {
                Ansb03::from_bits(val)
            }
        }
        impl From<Ansb03> for u8 {
            #[inline(always)]
            fn from(val: Ansb03) -> u8 {
                Ansb03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb04 {
            #[inline(always)]
            fn from(val: u8) -> Ansb04 {
                Ansb04::from_bits(val)
            }
        }
        impl From<Ansb04> for u8 {
            #[inline(always)]
            fn from(val: Ansb04) -> u8 {
                Ansb04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb05 {
            #[inline(always)]
            fn from(val: u8) -> Ansb05 {
                Ansb05::from_bits(val)
            }
        }
        impl From<Ansb05> for u8 {
            #[inline(always)]
            fn from(val: Ansb05) -> u8 {
                Ansb05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb06 {
            #[inline(always)]
            fn from(val: u8) -> Ansb06 {
                Ansb06::from_bits(val)
            }
        }
        impl From<Ansb06> for u8 {
            #[inline(always)]
            fn from(val: Ansb06) -> u8 {
                Ansb06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb07 {
            #[inline(always)]
            fn from(val: u8) -> Ansb07 {
                Ansb07::from_bits(val)
            }
        }
        impl From<Ansb07> for u8 {
            #[inline(always)]
            fn from(val: Ansb07) -> u8 {
                Ansb07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb08 {
            #[inline(always)]
            fn from(val: u8) -> Ansb08 {
                Ansb08::from_bits(val)
            }
        }
        impl From<Ansb08> for u8 {
            #[inline(always)]
            fn from(val: Ansb08) -> u8 {
                Ansb08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb09 {
            #[inline(always)]
            fn from(val: u8) -> Ansb09 {
                Ansb09::from_bits(val)
            }
        }
        impl From<Ansb09> for u8 {
            #[inline(always)]
            fn from(val: Ansb09) -> u8 {
                Ansb09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb10 {
            #[inline(always)]
            fn from(val: u8) -> Ansb10 {
                Ansb10::from_bits(val)
            }
        }
        impl From<Ansb10> for u8 {
            #[inline(always)]
            fn from(val: Ansb10) -> u8 {
                Ansb10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb11 {
            #[inline(always)]
            fn from(val: u8) -> Ansb11 {
                Ansb11::from_bits(val)
            }
        }
        impl From<Ansb11> for u8 {
            #[inline(always)]
            fn from(val: Ansb11) -> u8 {
                Ansb11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb12 {
            #[inline(always)]
            fn from(val: u8) -> Ansb12 {
                Ansb12::from_bits(val)
            }
        }
        impl From<Ansb12> for u8 {
            #[inline(always)]
            fn from(val: Ansb12) -> u8 {
                Ansb12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb13 {
            #[inline(always)]
            fn from(val: u8) -> Ansb13 {
                Ansb13::from_bits(val)
            }
        }
        impl From<Ansb13> for u8 {
            #[inline(always)]
            fn from(val: Ansb13) -> u8 {
                Ansb13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb14 {
            #[inline(always)]
            fn from(val: u8) -> Ansb14 {
                Ansb14::from_bits(val)
            }
        }
        impl From<Ansb14> for u8 {
            #[inline(always)]
            fn from(val: Ansb14) -> u8 {
                Ansb14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb15 {
            #[inline(always)]
            fn from(val: u8) -> Ansb15 {
                Ansb15::from_bits(val)
            }
        }
        impl From<Ansb15> for u8 {
            #[inline(always)]
            fn from(val: Ansb15) -> u8 {
                Ansb15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb16 {
            #[inline(always)]
            fn from(val: u8) -> Ansb16 {
                Ansb16::from_bits(val)
            }
        }
        impl From<Ansb16> for u8 {
            #[inline(always)]
            fn from(val: Ansb16) -> u8 {
                Ansb16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb17 {
            #[inline(always)]
            fn from(val: u8) -> Ansb17 {
                Ansb17::from_bits(val)
            }
        }
        impl From<Ansb17> for u8 {
            #[inline(always)]
            fn from(val: Ansb17) -> u8 {
                Ansb17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb18 {
            #[inline(always)]
            fn from(val: u8) -> Ansb18 {
                Ansb18::from_bits(val)
            }
        }
        impl From<Ansb18> for u8 {
            #[inline(always)]
            fn from(val: Ansb18) -> u8 {
                Ansb18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb19 {
            #[inline(always)]
            fn from(val: u8) -> Ansb19 {
                Ansb19::from_bits(val)
            }
        }
        impl From<Ansb19> for u8 {
            #[inline(always)]
            fn from(val: Ansb19) -> u8 {
                Ansb19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb20 {
            #[inline(always)]
            fn from(val: u8) -> Ansb20 {
                Ansb20::from_bits(val)
            }
        }
        impl From<Ansb20> for u8 {
            #[inline(always)]
            fn from(val: Ansb20) -> u8 {
                Ansb20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb21 {
            #[inline(always)]
            fn from(val: u8) -> Ansb21 {
                Ansb21::from_bits(val)
            }
        }
        impl From<Ansb21> for u8 {
            #[inline(always)]
            fn from(val: Ansb21) -> u8 {
                Ansb21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb22 {
            #[inline(always)]
            fn from(val: u8) -> Ansb22 {
                Ansb22::from_bits(val)
            }
        }
        impl From<Ansb22> for u8 {
            #[inline(always)]
            fn from(val: Ansb22) -> u8 {
                Ansb22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb23 {
            #[inline(always)]
            fn from(val: u8) -> Ansb23 {
                Ansb23::from_bits(val)
            }
        }
        impl From<Ansb23> for u8 {
            #[inline(always)]
            fn from(val: Ansb23) -> u8 {
                Ansb23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb24 {
            #[inline(always)]
            fn from(val: u8) -> Ansb24 {
                Ansb24::from_bits(val)
            }
        }
        impl From<Ansb24> for u8 {
            #[inline(always)]
            fn from(val: Ansb24) -> u8 {
                Ansb24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb25 {
            #[inline(always)]
            fn from(val: u8) -> Ansb25 {
                Ansb25::from_bits(val)
            }
        }
        impl From<Ansb25> for u8 {
            #[inline(always)]
            fn from(val: Ansb25) -> u8 {
                Ansb25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb26 {
            #[inline(always)]
            fn from(val: u8) -> Ansb26 {
                Ansb26::from_bits(val)
            }
        }
        impl From<Ansb26> for u8 {
            #[inline(always)]
            fn from(val: Ansb26) -> u8 {
                Ansb26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb27 {
            #[inline(always)]
            fn from(val: u8) -> Ansb27 {
                Ansb27::from_bits(val)
            }
        }
        impl From<Ansb27> for u8 {
            #[inline(always)]
            fn from(val: Ansb27) -> u8 {
                Ansb27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb28 {
            #[inline(always)]
            fn from(val: u8) -> Ansb28 {
                Ansb28::from_bits(val)
            }
        }
        impl From<Ansb28> for u8 {
            #[inline(always)]
            fn from(val: Ansb28) -> u8 {
                Ansb28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb29 {
            #[inline(always)]
            fn from(val: u8) -> Ansb29 {
                Ansb29::from_bits(val)
            }
        }
        impl From<Ansb29> for u8 {
            #[inline(always)]
            fn from(val: Ansb29) -> u8 {
                Ansb29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb30 {
            #[inline(always)]
            fn from(val: u8) -> Ansb30 {
                Ansb30::from_bits(val)
            }
        }
        impl From<Ansb30> for u8 {
            #[inline(always)]
            fn from(val: Ansb30) -> u8 {
                Ansb30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ansb31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ansb31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ansb31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ansb31 {
            #[inline(always)]
            fn from(val: u8) -> Ansb31 {
                Ansb31::from_bits(val)
            }
        }
        impl From<Ansb31> for u8 {
            #[inline(always)]
            fn from(val: Ansb31) -> u8 {
                Ansb31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Avee {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Avee {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Avee {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Avee {
            #[inline(always)]
            fn from(val: u8) -> Avee {
                Avee::from_bits(val)
            }
        }
        impl From<Avee> for u8 {
            #[inline(always)]
            fn from(val: Avee) -> u8 {
                Avee::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpab {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cmpab {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpab {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpab {
            #[inline(always)]
            fn from(val: u8) -> Cmpab {
                Cmpab::from_bits(val)
            }
        }
        impl From<Cmpab> for u8 {
            #[inline(always)]
            fn from(val: Cmpab) -> u8 {
                Cmpab::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpae {
            #[inline(always)]
            fn from(val: u8) -> Cmpae {
                Cmpae::from_bits(val)
            }
        }
        impl From<Cmpae> for u8 {
            #[inline(always)]
            fn from(val: Cmpae) -> u8 {
                Cmpae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpaie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpaie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpaie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpaie {
            #[inline(always)]
            fn from(val: u8) -> Cmpaie {
                Cmpaie::from_bits(val)
            }
        }
        impl From<Cmpaie> for u8 {
            #[inline(always)]
            fn from(val: Cmpaie) -> u8 {
                Cmpaie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpbe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpbe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpbe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpbe {
            #[inline(always)]
            fn from(val: u8) -> Cmpbe {
                Cmpbe::from_bits(val)
            }
        }
        impl From<Cmpbe> for u8 {
            #[inline(always)]
            fn from(val: Cmpbe) -> u8 {
                Cmpbe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpbie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpbie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpbie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpbie {
            #[inline(always)]
            fn from(val: u8) -> Cmpbie {
                Cmpbie::from_bits(val)
            }
        }
        impl From<Cmpbie> for u8 {
            #[inline(always)]
            fn from(val: Cmpbie) -> u8 {
                Cmpbie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha00 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha00 {
                Cmpcha00::from_bits(val)
            }
        }
        impl From<Cmpcha00> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha00) -> u8 {
                Cmpcha00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha01 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha01 {
                Cmpcha01::from_bits(val)
            }
        }
        impl From<Cmpcha01> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha01) -> u8 {
                Cmpcha01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha02 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha02 {
                Cmpcha02::from_bits(val)
            }
        }
        impl From<Cmpcha02> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha02) -> u8 {
                Cmpcha02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha03 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha03 {
                Cmpcha03::from_bits(val)
            }
        }
        impl From<Cmpcha03> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha03) -> u8 {
                Cmpcha03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha04 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha04 {
                Cmpcha04::from_bits(val)
            }
        }
        impl From<Cmpcha04> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha04) -> u8 {
                Cmpcha04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha05 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha05 {
                Cmpcha05::from_bits(val)
            }
        }
        impl From<Cmpcha05> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha05) -> u8 {
                Cmpcha05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha06 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha06 {
                Cmpcha06::from_bits(val)
            }
        }
        impl From<Cmpcha06> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha06) -> u8 {
                Cmpcha06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha07 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha07 {
                Cmpcha07::from_bits(val)
            }
        }
        impl From<Cmpcha07> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha07) -> u8 {
                Cmpcha07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha08 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha08 {
                Cmpcha08::from_bits(val)
            }
        }
        impl From<Cmpcha08> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha08) -> u8 {
                Cmpcha08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha09 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha09 {
                Cmpcha09::from_bits(val)
            }
        }
        impl From<Cmpcha09> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha09) -> u8 {
                Cmpcha09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha10 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha10 {
                Cmpcha10::from_bits(val)
            }
        }
        impl From<Cmpcha10> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha10) -> u8 {
                Cmpcha10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha11 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha11 {
                Cmpcha11::from_bits(val)
            }
        }
        impl From<Cmpcha11> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha11) -> u8 {
                Cmpcha11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha12 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha12 {
                Cmpcha12::from_bits(val)
            }
        }
        impl From<Cmpcha12> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha12) -> u8 {
                Cmpcha12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha13 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha13 {
                Cmpcha13::from_bits(val)
            }
        }
        impl From<Cmpcha13> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha13) -> u8 {
                Cmpcha13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha14 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha14 {
                Cmpcha14::from_bits(val)
            }
        }
        impl From<Cmpcha14> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha14) -> u8 {
                Cmpcha14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha15 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha15 {
                Cmpcha15::from_bits(val)
            }
        }
        impl From<Cmpcha15> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha15) -> u8 {
                Cmpcha15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha16 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha16 {
                Cmpcha16::from_bits(val)
            }
        }
        impl From<Cmpcha16> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha16) -> u8 {
                Cmpcha16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha17 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha17 {
                Cmpcha17::from_bits(val)
            }
        }
        impl From<Cmpcha17> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha17) -> u8 {
                Cmpcha17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha18 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha18 {
                Cmpcha18::from_bits(val)
            }
        }
        impl From<Cmpcha18> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha18) -> u8 {
                Cmpcha18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha19 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha19 {
                Cmpcha19::from_bits(val)
            }
        }
        impl From<Cmpcha19> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha19) -> u8 {
                Cmpcha19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha20 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha20 {
                Cmpcha20::from_bits(val)
            }
        }
        impl From<Cmpcha20> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha20) -> u8 {
                Cmpcha20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha21 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha21 {
                Cmpcha21::from_bits(val)
            }
        }
        impl From<Cmpcha21> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha21) -> u8 {
                Cmpcha21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha22 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha22 {
                Cmpcha22::from_bits(val)
            }
        }
        impl From<Cmpcha22> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha22) -> u8 {
                Cmpcha22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha23 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha23 {
                Cmpcha23::from_bits(val)
            }
        }
        impl From<Cmpcha23> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha23) -> u8 {
                Cmpcha23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha24 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha24 {
                Cmpcha24::from_bits(val)
            }
        }
        impl From<Cmpcha24> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha24) -> u8 {
                Cmpcha24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha25 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha25 {
                Cmpcha25::from_bits(val)
            }
        }
        impl From<Cmpcha25> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha25) -> u8 {
                Cmpcha25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha26 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha26 {
                Cmpcha26::from_bits(val)
            }
        }
        impl From<Cmpcha26> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha26) -> u8 {
                Cmpcha26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha27 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha27 {
                Cmpcha27::from_bits(val)
            }
        }
        impl From<Cmpcha27> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha27) -> u8 {
                Cmpcha27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha28 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha28 {
                Cmpcha28::from_bits(val)
            }
        }
        impl From<Cmpcha28> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha28) -> u8 {
                Cmpcha28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha29 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha29 {
                Cmpcha29::from_bits(val)
            }
        }
        impl From<Cmpcha29> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha29) -> u8 {
                Cmpcha29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha30 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha30 {
                Cmpcha30::from_bits(val)
            }
        }
        impl From<Cmpcha30> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha30) -> u8 {
                Cmpcha30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpcha31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpcha31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpcha31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpcha31 {
            #[inline(always)]
            fn from(val: u8) -> Cmpcha31 {
                Cmpcha31::from_bits(val)
            }
        }
        impl From<Cmpcha31> for u8 {
            #[inline(always)]
            fn from(val: Cmpcha31) -> u8 {
                Cmpcha31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplb {
            #[inline(always)]
            fn from(val: u8) -> Cmplb {
                Cmplb::from_bits(val)
            }
        }
        impl From<Cmplb> for u8 {
            #[inline(always)]
            fn from(val: Cmplb) -> u8 {
                Cmplb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha00 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha00 {
                Cmplcha00::from_bits(val)
            }
        }
        impl From<Cmplcha00> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha00) -> u8 {
                Cmplcha00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha01 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha01 {
                Cmplcha01::from_bits(val)
            }
        }
        impl From<Cmplcha01> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha01) -> u8 {
                Cmplcha01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha02 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha02 {
                Cmplcha02::from_bits(val)
            }
        }
        impl From<Cmplcha02> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha02) -> u8 {
                Cmplcha02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha03 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha03 {
                Cmplcha03::from_bits(val)
            }
        }
        impl From<Cmplcha03> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha03) -> u8 {
                Cmplcha03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha04 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha04 {
                Cmplcha04::from_bits(val)
            }
        }
        impl From<Cmplcha04> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha04) -> u8 {
                Cmplcha04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha05 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha05 {
                Cmplcha05::from_bits(val)
            }
        }
        impl From<Cmplcha05> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha05) -> u8 {
                Cmplcha05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha06 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha06 {
                Cmplcha06::from_bits(val)
            }
        }
        impl From<Cmplcha06> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha06) -> u8 {
                Cmplcha06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha07 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha07 {
                Cmplcha07::from_bits(val)
            }
        }
        impl From<Cmplcha07> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha07) -> u8 {
                Cmplcha07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha08 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha08 {
                Cmplcha08::from_bits(val)
            }
        }
        impl From<Cmplcha08> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha08) -> u8 {
                Cmplcha08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha09 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha09 {
                Cmplcha09::from_bits(val)
            }
        }
        impl From<Cmplcha09> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha09) -> u8 {
                Cmplcha09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha10 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha10 {
                Cmplcha10::from_bits(val)
            }
        }
        impl From<Cmplcha10> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha10) -> u8 {
                Cmplcha10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha11 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha11 {
                Cmplcha11::from_bits(val)
            }
        }
        impl From<Cmplcha11> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha11) -> u8 {
                Cmplcha11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha12 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha12 {
                Cmplcha12::from_bits(val)
            }
        }
        impl From<Cmplcha12> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha12) -> u8 {
                Cmplcha12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha13 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha13 {
                Cmplcha13::from_bits(val)
            }
        }
        impl From<Cmplcha13> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha13) -> u8 {
                Cmplcha13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha14 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha14 {
                Cmplcha14::from_bits(val)
            }
        }
        impl From<Cmplcha14> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha14) -> u8 {
                Cmplcha14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha15 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha15 {
                Cmplcha15::from_bits(val)
            }
        }
        impl From<Cmplcha15> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha15) -> u8 {
                Cmplcha15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha16 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha16 {
                Cmplcha16::from_bits(val)
            }
        }
        impl From<Cmplcha16> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha16) -> u8 {
                Cmplcha16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha17 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha17 {
                Cmplcha17::from_bits(val)
            }
        }
        impl From<Cmplcha17> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha17) -> u8 {
                Cmplcha17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha18 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha18 {
                Cmplcha18::from_bits(val)
            }
        }
        impl From<Cmplcha18> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha18) -> u8 {
                Cmplcha18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha19 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha19 {
                Cmplcha19::from_bits(val)
            }
        }
        impl From<Cmplcha19> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha19) -> u8 {
                Cmplcha19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha20 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha20 {
                Cmplcha20::from_bits(val)
            }
        }
        impl From<Cmplcha20> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha20) -> u8 {
                Cmplcha20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha21 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha21 {
                Cmplcha21::from_bits(val)
            }
        }
        impl From<Cmplcha21> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha21) -> u8 {
                Cmplcha21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha22 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha22 {
                Cmplcha22::from_bits(val)
            }
        }
        impl From<Cmplcha22> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha22) -> u8 {
                Cmplcha22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha23 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha23 {
                Cmplcha23::from_bits(val)
            }
        }
        impl From<Cmplcha23> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha23) -> u8 {
                Cmplcha23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha24 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha24 {
                Cmplcha24::from_bits(val)
            }
        }
        impl From<Cmplcha24> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha24) -> u8 {
                Cmplcha24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha25 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha25 {
                Cmplcha25::from_bits(val)
            }
        }
        impl From<Cmplcha25> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha25) -> u8 {
                Cmplcha25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha26 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha26 {
                Cmplcha26::from_bits(val)
            }
        }
        impl From<Cmplcha26> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha26) -> u8 {
                Cmplcha26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha27 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha27 {
                Cmplcha27::from_bits(val)
            }
        }
        impl From<Cmplcha27> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha27) -> u8 {
                Cmplcha27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha28 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha28 {
                Cmplcha28::from_bits(val)
            }
        }
        impl From<Cmplcha28> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha28) -> u8 {
                Cmplcha28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha29 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha29 {
                Cmplcha29::from_bits(val)
            }
        }
        impl From<Cmplcha29> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha29) -> u8 {
                Cmplcha29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha30 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha30 {
                Cmplcha30::from_bits(val)
            }
        }
        impl From<Cmplcha30> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha30) -> u8 {
                Cmplcha30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmplcha31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmplcha31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmplcha31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmplcha31 {
            #[inline(always)]
            fn from(val: u8) -> Cmplcha31 {
                Cmplcha31::from_bits(val)
            }
        }
        impl From<Cmplcha31> for u8 {
            #[inline(always)]
            fn from(val: Cmplcha31) -> u8 {
                Cmplcha31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmploca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmploca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmploca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmploca {
            #[inline(always)]
            fn from(val: u8) -> Cmploca {
                Cmploca::from_bits(val)
            }
        }
        impl From<Cmploca> for u8 {
            #[inline(always)]
            fn from(val: Cmploca) -> u8 {
                Cmploca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpltsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpltsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpltsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpltsa {
            #[inline(always)]
            fn from(val: u8) -> Cmpltsa {
                Cmpltsa::from_bits(val)
            }
        }
        impl From<Cmpltsa> for u8 {
            #[inline(always)]
            fn from(val: Cmpltsa) -> u8 {
                Cmpltsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpoca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpoca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpoca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpoca {
            #[inline(always)]
            fn from(val: u8) -> Cmpoca {
                Cmpoca::from_bits(val)
            }
        }
        impl From<Cmpoca> for u8 {
            #[inline(always)]
            fn from(val: Cmpoca) -> u8 {
                Cmpoca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstb {
            #[inline(always)]
            fn from(val: u8) -> Cmpstb {
                Cmpstb::from_bits(val)
            }
        }
        impl From<Cmpstb> for u8 {
            #[inline(always)]
            fn from(val: Cmpstb) -> u8 {
                Cmpstb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha00 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha00 {
                Cmpstcha00::from_bits(val)
            }
        }
        impl From<Cmpstcha00> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha00) -> u8 {
                Cmpstcha00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha01 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha01 {
                Cmpstcha01::from_bits(val)
            }
        }
        impl From<Cmpstcha01> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha01) -> u8 {
                Cmpstcha01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha02 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha02 {
                Cmpstcha02::from_bits(val)
            }
        }
        impl From<Cmpstcha02> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha02) -> u8 {
                Cmpstcha02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha03 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha03 {
                Cmpstcha03::from_bits(val)
            }
        }
        impl From<Cmpstcha03> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha03) -> u8 {
                Cmpstcha03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha04 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha04 {
                Cmpstcha04::from_bits(val)
            }
        }
        impl From<Cmpstcha04> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha04) -> u8 {
                Cmpstcha04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha05 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha05 {
                Cmpstcha05::from_bits(val)
            }
        }
        impl From<Cmpstcha05> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha05) -> u8 {
                Cmpstcha05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha06 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha06 {
                Cmpstcha06::from_bits(val)
            }
        }
        impl From<Cmpstcha06> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha06) -> u8 {
                Cmpstcha06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha07 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha07 {
                Cmpstcha07::from_bits(val)
            }
        }
        impl From<Cmpstcha07> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha07) -> u8 {
                Cmpstcha07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha08 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha08 {
                Cmpstcha08::from_bits(val)
            }
        }
        impl From<Cmpstcha08> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha08) -> u8 {
                Cmpstcha08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha09 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha09 {
                Cmpstcha09::from_bits(val)
            }
        }
        impl From<Cmpstcha09> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha09) -> u8 {
                Cmpstcha09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha10 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha10 {
                Cmpstcha10::from_bits(val)
            }
        }
        impl From<Cmpstcha10> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha10) -> u8 {
                Cmpstcha10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha11 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha11 {
                Cmpstcha11::from_bits(val)
            }
        }
        impl From<Cmpstcha11> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha11) -> u8 {
                Cmpstcha11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha12 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha12 {
                Cmpstcha12::from_bits(val)
            }
        }
        impl From<Cmpstcha12> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha12) -> u8 {
                Cmpstcha12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha13 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha13 {
                Cmpstcha13::from_bits(val)
            }
        }
        impl From<Cmpstcha13> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha13) -> u8 {
                Cmpstcha13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha14 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha14 {
                Cmpstcha14::from_bits(val)
            }
        }
        impl From<Cmpstcha14> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha14) -> u8 {
                Cmpstcha14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha15 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha15 {
                Cmpstcha15::from_bits(val)
            }
        }
        impl From<Cmpstcha15> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha15) -> u8 {
                Cmpstcha15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha16 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha16 {
                Cmpstcha16::from_bits(val)
            }
        }
        impl From<Cmpstcha16> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha16) -> u8 {
                Cmpstcha16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha17 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha17 {
                Cmpstcha17::from_bits(val)
            }
        }
        impl From<Cmpstcha17> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha17) -> u8 {
                Cmpstcha17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha18 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha18 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha18 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha18 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha18 {
                Cmpstcha18::from_bits(val)
            }
        }
        impl From<Cmpstcha18> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha18) -> u8 {
                Cmpstcha18::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha19 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha19 {
                Cmpstcha19::from_bits(val)
            }
        }
        impl From<Cmpstcha19> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha19) -> u8 {
                Cmpstcha19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha20 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha20 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha20 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha20 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha20 {
                Cmpstcha20::from_bits(val)
            }
        }
        impl From<Cmpstcha20> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha20) -> u8 {
                Cmpstcha20::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha21 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha21 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha21 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha21 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha21 {
                Cmpstcha21::from_bits(val)
            }
        }
        impl From<Cmpstcha21> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha21) -> u8 {
                Cmpstcha21::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha22 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha22 {
                Cmpstcha22::from_bits(val)
            }
        }
        impl From<Cmpstcha22> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha22) -> u8 {
                Cmpstcha22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha23 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha23 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha23 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha23 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha23 {
                Cmpstcha23::from_bits(val)
            }
        }
        impl From<Cmpstcha23> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha23) -> u8 {
                Cmpstcha23::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha24 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha24 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha24 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha24 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha24 {
                Cmpstcha24::from_bits(val)
            }
        }
        impl From<Cmpstcha24> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha24) -> u8 {
                Cmpstcha24::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha25 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha25 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha25 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha25 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha25 {
                Cmpstcha25::from_bits(val)
            }
        }
        impl From<Cmpstcha25> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha25) -> u8 {
                Cmpstcha25::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha26 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha26 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha26 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha26 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha26 {
                Cmpstcha26::from_bits(val)
            }
        }
        impl From<Cmpstcha26> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha26) -> u8 {
                Cmpstcha26::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha27 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha27 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha27 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha27 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha27 {
                Cmpstcha27::from_bits(val)
            }
        }
        impl From<Cmpstcha27> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha27) -> u8 {
                Cmpstcha27::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha28 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha28 {
                Cmpstcha28::from_bits(val)
            }
        }
        impl From<Cmpstcha28> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha28) -> u8 {
                Cmpstcha28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha29 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha29 {
                Cmpstcha29::from_bits(val)
            }
        }
        impl From<Cmpstcha29> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha29) -> u8 {
                Cmpstcha29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha30 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha30 {
                Cmpstcha30::from_bits(val)
            }
        }
        impl From<Cmpstcha30> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha30) -> u8 {
                Cmpstcha30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstcha31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstcha31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstcha31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstcha31 {
            #[inline(always)]
            fn from(val: u8) -> Cmpstcha31 {
                Cmpstcha31::from_bits(val)
            }
        }
        impl From<Cmpstcha31> for u8 {
            #[inline(always)]
            fn from(val: Cmpstcha31) -> u8 {
                Cmpstcha31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpstoca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpstoca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpstoca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpstoca {
            #[inline(always)]
            fn from(val: u8) -> Cmpstoca {
                Cmpstoca::from_bits(val)
            }
        }
        impl From<Cmpstoca> for u8 {
            #[inline(always)]
            fn from(val: Cmpstoca) -> u8 {
                Cmpstoca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmpsttsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmpsttsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmpsttsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmpsttsa {
            #[inline(always)]
            fn from(val: u8) -> Cmpsttsa {
                Cmpsttsa::from_bits(val)
            }
        }
        impl From<Cmpsttsa> for u8 {
            #[inline(always)]
            fn from(val: Cmpsttsa) -> u8 {
                Cmpsttsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmptsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmptsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmptsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmptsa {
            #[inline(always)]
            fn from(val: u8) -> Cmptsa {
                Cmptsa::from_bits(val)
            }
        }
        impl From<Cmptsa> for u8 {
            #[inline(always)]
            fn from(val: Cmptsa) -> u8 {
                Cmptsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dble {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dble {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dble {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dble {
            #[inline(always)]
            fn from(val: u8) -> Dble {
                Dble::from_bits(val)
            }
        }
        impl From<Dble> for u8 {
            #[inline(always)]
            fn from(val: Dble) -> u8 {
                Dble::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Diagld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagld {
            #[inline(always)]
            fn from(val: u8) -> Diagld {
                Diagld::from_bits(val)
            }
        }
        impl From<Diagld> for u8 {
            #[inline(always)]
            fn from(val: Diagld) -> u8 {
                Diagld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Diagm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagm {
            #[inline(always)]
            fn from(val: u8) -> Diagm {
                Diagm::from_bits(val)
            }
        }
        impl From<Diagm> for u8 {
            #[inline(always)]
            fn from(val: Diagm) -> u8 {
                Diagm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Diagst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagst {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagst {
            #[inline(always)]
            fn from(val: u8) -> Diagst {
                Diagst::from_bits(val)
            }
        }
        impl From<Diagst> for u8 {
            #[inline(always)]
            fn from(val: Diagst) -> u8 {
                Diagst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diagval {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Diagval {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diagval {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diagval {
            #[inline(always)]
            fn from(val: u8) -> Diagval {
                Diagval::from_bits(val)
            }
        }
        impl From<Diagval> for u8 {
            #[inline(always)]
            fn from(val: Diagval) -> u8 {
                Diagval::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extrg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Extrg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extrg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extrg {
            #[inline(always)]
            fn from(val: u8) -> Extrg {
                Extrg::from_bits(val)
            }
        }
        impl From<Extrg> for u8 {
            #[inline(always)]
            fn from(val: Extrg) -> u8 {
                Extrg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbadie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbadie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbadie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbadie {
            #[inline(always)]
            fn from(val: u8) -> Gbadie {
                Gbadie::from_bits(val)
            }
        }
        impl From<Gbadie> for u8 {
            #[inline(always)]
            fn from(val: Gbadie) -> u8 {
                Gbadie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbrp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbrp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbrp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbrp {
            #[inline(always)]
            fn from(val: u8) -> Gbrp {
                Gbrp::from_bits(val)
            }
        }
        impl From<Gbrp> for u8 {
            #[inline(always)]
            fn from(val: Gbrp) -> u8 {
                Gbrp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gbrscn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gbrscn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gbrscn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gbrscn {
            #[inline(always)]
            fn from(val: u8) -> Gbrscn {
                Gbrscn::from_bits(val)
            }
        }
        impl From<Gbrscn> for u8 {
            #[inline(always)]
            fn from(val: Gbrscn) -> u8 {
                Gbrscn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hvsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Hvsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hvsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hvsel {
            #[inline(always)]
            fn from(val: u8) -> Hvsel {
                Hvsel::from_bits(val)
            }
        }
        impl From<Hvsel> for u8 {
            #[inline(always)]
            fn from(val: Hvsel) -> u8 {
                Hvsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvsel {
            #[inline(always)]
            fn from(val: u8) -> Lvsel {
                Lvsel::from_bits(val)
            }
        }
        impl From<Lvsel> for u8 {
            #[inline(always)]
            fn from(val: Lvsel) -> u8 {
                Lvsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncmpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncmpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncmpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncmpa {
            #[inline(always)]
            fn from(val: u8) -> Moncmpa {
                Moncmpa::from_bits(val)
            }
        }
        impl From<Moncmpa> for u8 {
            #[inline(always)]
            fn from(val: Moncmpa) -> u8 {
                Moncmpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncmpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncmpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncmpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncmpb {
            #[inline(always)]
            fn from(val: u8) -> Moncmpb {
                Moncmpb::from_bits(val)
            }
        }
        impl From<Moncmpb> for u8 {
            #[inline(always)]
            fn from(val: Moncmpb) -> u8 {
                Moncmpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moncomb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moncomb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moncomb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moncomb {
            #[inline(always)]
            fn from(val: u8) -> Moncomb {
                Moncomb::from_bits(val)
            }
        }
        impl From<Moncomb> for u8 {
            #[inline(always)]
            fn from(val: Moncomb) -> u8 {
                Moncomb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ocsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ocsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ocsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ocsa {
            #[inline(always)]
            fn from(val: u8) -> Ocsa {
                Ocsa::from_bits(val)
            }
        }
        impl From<Ocsa> for u8 {
            #[inline(always)]
            fn from(val: Ocsa) -> u8 {
                Ocsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ocsad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ocsad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ocsad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ocsad {
            #[inline(always)]
            fn from(val: u8) -> Ocsad {
                Ocsad::from_bits(val)
            }
        }
        impl From<Ocsad> for u8 {
            #[inline(always)]
            fn from(val: Ocsad) -> u8 {
                Ocsad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pchg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pchg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pchg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pchg {
            #[inline(always)]
            fn from(val: u8) -> Pchg {
                Pchg::from_bits(val)
            }
        }
        impl From<Pchg> for u8 {
            #[inline(always)]
            fn from(val: Pchg) -> u8 {
                Pchg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pgs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pgs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pgs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pgs {
            #[inline(always)]
            fn from(val: u8) -> Pgs {
                Pgs::from_bits(val)
            }
        }
        impl From<Pgs> for u8 {
            #[inline(always)]
            fn from(val: Pgs) -> u8 {
                Pgs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trge {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trge {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trge {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trge {
            #[inline(always)]
            fn from(val: u8) -> Trge {
                Trge::from_bits(val)
            }
        }
        impl From<Trge> for u8 {
            #[inline(always)]
            fn from(val: Trge) -> u8 {
                Trge::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tssa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tssa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tssa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tssa {
            #[inline(always)]
            fn from(val: u8) -> Tssa {
                Tssa::from_bits(val)
            }
        }
        impl From<Tssa> for u8 {
            #[inline(always)]
            fn from(val: Tssa) -> u8 {
                Tssa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tssad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tssad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tssad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tssad {
            #[inline(always)]
            fn from(val: u8) -> Tssad {
                Tssad::from_bits(val)
            }
        }
        impl From<Tssad> for u8 {
            #[inline(always)]
            fn from(val: Tssad) -> u8 {
                Tssad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wcmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wcmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wcmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wcmpe {
            #[inline(always)]
            fn from(val: u8) -> Wcmpe {
                Wcmpe::from_bits(val)
            }
        }
        impl From<Wcmpe> for u8 {
            #[inline(always)]
            fn from(val: Wcmpe) -> u8 {
                Wcmpe::to_bits(val)
            }
        }
    }
}
pub mod agtw0 {
    #[doc = "Low Power Asynchronous General Purpose Timer 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Agtw0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Agtw0 {}
    unsafe impl Sync for Agtw0 {}
    impl Agtw0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "AGT Counter Register"]
        #[inline(always)]
        pub const fn agt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "AGT CounterCompare Match A Register"]
        #[inline(always)]
        pub const fn agtcma(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "AGT CounterCompare Match B Register"]
        #[inline(always)]
        pub const fn agtcmb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "AGT Control Register"]
        #[inline(always)]
        pub const fn agtcr(self) -> crate::common::Reg<regs::Agtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "AGT Mode Register 1"]
        #[inline(always)]
        pub const fn agtmr1(self) -> crate::common::Reg<regs::Agtmr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "AGT Mode Register 2"]
        #[inline(always)]
        pub const fn agtmr2(self) -> crate::common::Reg<regs::Agtmr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "AGT Pin Select Register"]
        #[inline(always)]
        pub const fn agtiosel(self) -> crate::common::Reg<regs::Agtiosel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
        #[doc = "AGT I/O Control Register"]
        #[inline(always)]
        pub const fn agtioc(self) -> crate::common::Reg<regs::Agtioc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "AGT Event Pin Select Register"]
        #[inline(always)]
        pub const fn agtisr(self) -> crate::common::Reg<regs::Agtisr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x11usize) as _) }
        }
        #[doc = "AGT Compare Match Function Select Register"]
        #[inline(always)]
        pub const fn agtcmsr(self) -> crate::common::Reg<regs::Agtcmsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "AGT Compare Match Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcmsr(pub u8);
        impl Agtcmsr {
            #[doc = "AGT Compare Match A Register Enable"]
            #[inline(always)]
            pub const fn tcmea(&self) -> super::vals::Tcmea {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tcmea::from_bits(val as u8)
            }
            #[doc = "AGT Compare Match A Register Enable"]
            #[inline(always)]
            pub fn set_tcmea(&mut self, val: super::vals::Tcmea) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AGTOAn Pin Output Enable"]
            #[inline(always)]
            pub const fn toea(&self) -> super::vals::Toea {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Toea::from_bits(val as u8)
            }
            #[doc = "AGTOAn Pin Output Enable"]
            #[inline(always)]
            pub fn set_toea(&mut self, val: super::vals::Toea) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AGTOAn Pin Polarity Select"]
            #[inline(always)]
            pub const fn topola(&self) -> super::vals::Topola {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Topola::from_bits(val as u8)
            }
            #[doc = "AGTOAn Pin Polarity Select"]
            #[inline(always)]
            pub fn set_topola(&mut self, val: super::vals::Topola) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "AGT Compare Match B Register Enable"]
            #[inline(always)]
            pub const fn tcmeb(&self) -> super::vals::Tcmeb {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tcmeb::from_bits(val as u8)
            }
            #[doc = "AGT Compare Match B Register Enable"]
            #[inline(always)]
            pub fn set_tcmeb(&mut self, val: super::vals::Tcmeb) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "AGTOBn Pin Output Enable"]
            #[inline(always)]
            pub const fn toeb(&self) -> super::vals::Toeb {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Toeb::from_bits(val as u8)
            }
            #[doc = "AGTOBn Pin Output Enable"]
            #[inline(always)]
            pub fn set_toeb(&mut self, val: super::vals::Toeb) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "AGTOBn Pin Polarity Select"]
            #[inline(always)]
            pub const fn topolb(&self) -> super::vals::Topolb {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Topolb::from_bits(val as u8)
            }
            #[doc = "AGTOBn Pin Polarity Select"]
            #[inline(always)]
            pub fn set_topolb(&mut self, val: super::vals::Topolb) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Agtcmsr {
            #[inline(always)]
            fn default() -> Agtcmsr {
                Agtcmsr(0)
            }
        }
        impl core::fmt::Debug for Agtcmsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcmsr")
                    .field("tcmea", &self.tcmea())
                    .field("toea", &self.toea())
                    .field("topola", &self.topola())
                    .field("tcmeb", &self.tcmeb())
                    .field("toeb", &self.toeb())
                    .field("topolb", &self.topolb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcmsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtcmsr {{ tcmea: {:?}, toea: {:?}, topola: {:?}, tcmeb: {:?}, toeb: {:?}, topolb: {:?} }}" , self . tcmea () , self . toea () , self . topola () , self . tcmeb () , self . toeb () , self . topolb ())
            }
        }
        #[doc = "AGT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtcr(pub u8);
        impl Agtcr {
            #[doc = "AGT Count Start"]
            #[inline(always)]
            pub const fn tstart(&self) -> super::vals::Tstart {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tstart::from_bits(val as u8)
            }
            #[doc = "AGT Count Start"]
            #[inline(always)]
            pub fn set_tstart(&mut self, val: super::vals::Tstart) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "AGT Count Status Flag"]
            #[inline(always)]
            pub const fn tcstf(&self) -> super::vals::Tcstf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tcstf::from_bits(val as u8)
            }
            #[doc = "AGT Count Status Flag"]
            #[inline(always)]
            pub fn set_tcstf(&mut self, val: super::vals::Tcstf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "AGT Count Forced Stop"]
            #[inline(always)]
            pub const fn tstop(&self) -> super::vals::Tstop {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tstop::from_bits(val as u8)
            }
            #[doc = "AGT Count Forced Stop"]
            #[inline(always)]
            pub fn set_tstop(&mut self, val: super::vals::Tstop) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Active Edge Judgment Flag"]
            #[inline(always)]
            pub const fn tedgf(&self) -> super::vals::Tedgf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tedgf::from_bits(val as u8)
            }
            #[doc = "Active Edge Judgment Flag"]
            #[inline(always)]
            pub fn set_tedgf(&mut self, val: super::vals::Tedgf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn tundf(&self) -> super::vals::Tundf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tundf::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_tundf(&mut self, val: super::vals::Tundf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Compare Match A Flag"]
            #[inline(always)]
            pub const fn tcmaf(&self) -> super::vals::Tcmaf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tcmaf::from_bits(val as u8)
            }
            #[doc = "Compare Match A Flag"]
            #[inline(always)]
            pub fn set_tcmaf(&mut self, val: super::vals::Tcmaf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Compare Match B Flag"]
            #[inline(always)]
            pub const fn tcmbf(&self) -> super::vals::Tcmbf {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcmbf::from_bits(val as u8)
            }
            #[doc = "Compare Match B Flag"]
            #[inline(always)]
            pub fn set_tcmbf(&mut self, val: super::vals::Tcmbf) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtcr {
            #[inline(always)]
            fn default() -> Agtcr {
                Agtcr(0)
            }
        }
        impl core::fmt::Debug for Agtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtcr")
                    .field("tstart", &self.tstart())
                    .field("tcstf", &self.tcstf())
                    .field("tstop", &self.tstop())
                    .field("tedgf", &self.tedgf())
                    .field("tundf", &self.tundf())
                    .field("tcmaf", &self.tcmaf())
                    .field("tcmbf", &self.tcmbf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Agtcr {{ tstart: {:?}, tcstf: {:?}, tstop: {:?}, tedgf: {:?}, tundf: {:?}, tcmaf: {:?}, tcmbf: {:?} }}" , self . tstart () , self . tcstf () , self . tstop () , self . tedgf () , self . tundf () , self . tcmaf () , self . tcmbf ())
            }
        }
        #[doc = "AGT I/O Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtioc(pub u8);
        impl Agtioc {
            #[doc = "I/O Polarity Switch"]
            #[inline(always)]
            pub const fn tedgsel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "I/O Polarity Switch"]
            #[inline(always)]
            pub fn set_tedgsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "AGTOn pin Output Enable"]
            #[inline(always)]
            pub const fn toe(&self) -> super::vals::Toe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Toe::from_bits(val as u8)
            }
            #[doc = "AGTOn pin Output Enable"]
            #[inline(always)]
            pub fn set_toe(&mut self, val: super::vals::Toe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Input Filter"]
            #[inline(always)]
            pub const fn tipf(&self) -> super::vals::Tipf {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Tipf::from_bits(val as u8)
            }
            #[doc = "Input Filter"]
            #[inline(always)]
            pub fn set_tipf(&mut self, val: super::vals::Tipf) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Count Control"]
            #[inline(always)]
            pub const fn tiogt(&self) -> super::vals::Tiogt {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tiogt::from_bits(val as u8)
            }
            #[doc = "Count Control"]
            #[inline(always)]
            pub fn set_tiogt(&mut self, val: super::vals::Tiogt) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Agtioc {
            #[inline(always)]
            fn default() -> Agtioc {
                Agtioc(0)
            }
        }
        impl core::fmt::Debug for Agtioc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtioc")
                    .field("tedgsel", &self.tedgsel())
                    .field("toe", &self.toe())
                    .field("tipf", &self.tipf())
                    .field("tiogt", &self.tiogt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtioc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtioc {{ tedgsel: {=bool:?}, toe: {:?}, tipf: {:?}, tiogt: {:?} }}",
                    self.tedgsel(),
                    self.toe(),
                    self.tipf(),
                    self.tiogt()
                )
            }
        }
        #[doc = "AGT Pin Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtiosel(pub u8);
        impl Agtiosel {
            #[doc = "AGTIOn Pin Input Enable"]
            #[inline(always)]
            pub const fn ties(&self) -> super::vals::Ties {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ties::from_bits(val as u8)
            }
            #[doc = "AGTIOn Pin Input Enable"]
            #[inline(always)]
            pub fn set_ties(&mut self, val: super::vals::Ties) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Agtiosel {
            #[inline(always)]
            fn default() -> Agtiosel {
                Agtiosel(0)
            }
        }
        impl core::fmt::Debug for Agtiosel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtiosel")
                    .field("ties", &self.ties())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtiosel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agtiosel {{ ties: {:?} }}", self.ties())
            }
        }
        #[doc = "AGT Event Pin Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtisr(pub u8);
        impl Agtisr {
            #[doc = "AGTEEn Polarity Selection"]
            #[inline(always)]
            pub const fn eeps(&self) -> super::vals::Eeps {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Eeps::from_bits(val as u8)
            }
            #[doc = "AGTEEn Polarity Selection"]
            #[inline(always)]
            pub fn set_eeps(&mut self, val: super::vals::Eeps) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Agtisr {
            #[inline(always)]
            fn default() -> Agtisr {
                Agtisr(0)
            }
        }
        impl core::fmt::Debug for Agtisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtisr")
                    .field("eeps", &self.eeps())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Agtisr {{ eeps: {:?} }}", self.eeps())
            }
        }
        #[doc = "AGT Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtmr1(pub u8);
        impl Agtmr1 {
            #[doc = "Operating Mode"]
            #[inline(always)]
            pub const fn tmod(&self) -> super::vals::Tmod {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Tmod::from_bits(val as u8)
            }
            #[doc = "Operating Mode"]
            #[inline(always)]
            pub fn set_tmod(&mut self, val: super::vals::Tmod) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Edge Polarity"]
            #[inline(always)]
            pub const fn tedgpl(&self) -> super::vals::Tedgpl {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tedgpl::from_bits(val as u8)
            }
            #[doc = "Edge Polarity"]
            #[inline(always)]
            pub fn set_tedgpl(&mut self, val: super::vals::Tedgpl) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Count Source"]
            #[inline(always)]
            pub const fn tck(&self) -> super::vals::Tck {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Tck::from_bits(val as u8)
            }
            #[doc = "Count Source"]
            #[inline(always)]
            pub fn set_tck(&mut self, val: super::vals::Tck) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
        }
        impl Default for Agtmr1 {
            #[inline(always)]
            fn default() -> Agtmr1 {
                Agtmr1(0)
            }
        }
        impl core::fmt::Debug for Agtmr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtmr1")
                    .field("tmod", &self.tmod())
                    .field("tedgpl", &self.tedgpl())
                    .field("tck", &self.tck())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtmr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtmr1 {{ tmod: {:?}, tedgpl: {:?}, tck: {:?} }}",
                    self.tmod(),
                    self.tedgpl(),
                    self.tck()
                )
            }
        }
        #[doc = "AGT Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Agtmr2(pub u8);
        impl Agtmr2 {
            #[doc = "AGTLCLK Count Source Clock Frequency Division Ratio"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "AGTLCLK Count Source Clock Frequency Division Ratio"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Low Power Mode"]
            #[inline(always)]
            pub const fn lpm(&self) -> super::vals::Lpm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lpm::from_bits(val as u8)
            }
            #[doc = "Low Power Mode"]
            #[inline(always)]
            pub fn set_lpm(&mut self, val: super::vals::Lpm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Agtmr2 {
            #[inline(always)]
            fn default() -> Agtmr2 {
                Agtmr2(0)
            }
        }
        impl core::fmt::Debug for Agtmr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Agtmr2")
                    .field("cks", &self.cks())
                    .field("lpm", &self.lpm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Agtmr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Agtmr2 {{ cks: {:?}, lpm: {:?} }}",
                    self.cks(),
                    self.lpm()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eeps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eeps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eeps {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eeps {
            #[inline(always)]
            fn from(val: u8) -> Eeps {
                Eeps::from_bits(val)
            }
        }
        impl From<Eeps> for u8 {
            #[inline(always)]
            fn from(val: Eeps) -> u8 {
                Eeps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lpm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpm {
            #[inline(always)]
            fn from(val: u8) -> Lpm {
                Lpm::from_bits(val)
            }
        }
        impl From<Lpm> for u8 {
            #[inline(always)]
            fn from(val: Lpm) -> u8 {
                Lpm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tck {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tck {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tck {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tck {
            #[inline(always)]
            fn from(val: u8) -> Tck {
                Tck::from_bits(val)
            }
        }
        impl From<Tck> for u8 {
            #[inline(always)]
            fn from(val: Tck) -> u8 {
                Tck::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmaf {
            #[inline(always)]
            fn from(val: u8) -> Tcmaf {
                Tcmaf::from_bits(val)
            }
        }
        impl From<Tcmaf> for u8 {
            #[inline(always)]
            fn from(val: Tcmaf) -> u8 {
                Tcmaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmbf {
            #[inline(always)]
            fn from(val: u8) -> Tcmbf {
                Tcmbf::from_bits(val)
            }
        }
        impl From<Tcmbf> for u8 {
            #[inline(always)]
            fn from(val: Tcmbf) -> u8 {
                Tcmbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmea {
            #[inline(always)]
            fn from(val: u8) -> Tcmea {
                Tcmea::from_bits(val)
            }
        }
        impl From<Tcmea> for u8 {
            #[inline(always)]
            fn from(val: Tcmea) -> u8 {
                Tcmea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcmeb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcmeb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcmeb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcmeb {
            #[inline(always)]
            fn from(val: u8) -> Tcmeb {
                Tcmeb::from_bits(val)
            }
        }
        impl From<Tcmeb> for u8 {
            #[inline(always)]
            fn from(val: Tcmeb) -> u8 {
                Tcmeb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcstf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcstf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcstf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcstf {
            #[inline(always)]
            fn from(val: u8) -> Tcstf {
                Tcstf::from_bits(val)
            }
        }
        impl From<Tcstf> for u8 {
            #[inline(always)]
            fn from(val: Tcstf) -> u8 {
                Tcstf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tedgf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tedgf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tedgf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tedgf {
            #[inline(always)]
            fn from(val: u8) -> Tedgf {
                Tedgf::from_bits(val)
            }
        }
        impl From<Tedgf> for u8 {
            #[inline(always)]
            fn from(val: Tedgf) -> u8 {
                Tedgf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tedgpl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tedgpl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tedgpl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tedgpl {
            #[inline(always)]
            fn from(val: u8) -> Tedgpl {
                Tedgpl::from_bits(val)
            }
        }
        impl From<Tedgpl> for u8 {
            #[inline(always)]
            fn from(val: Tedgpl) -> u8 {
                Tedgpl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ties {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ties {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ties {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ties {
            #[inline(always)]
            fn from(val: u8) -> Ties {
                Ties::from_bits(val)
            }
        }
        impl From<Ties> for u8 {
            #[inline(always)]
            fn from(val: Ties) -> u8 {
                Ties::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tiogt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tiogt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tiogt {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tiogt {
            #[inline(always)]
            fn from(val: u8) -> Tiogt {
                Tiogt::from_bits(val)
            }
        }
        impl From<Tiogt> for u8 {
            #[inline(always)]
            fn from(val: Tiogt) -> u8 {
                Tiogt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tipf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tipf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tipf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tipf {
            #[inline(always)]
            fn from(val: u8) -> Tipf {
                Tipf::from_bits(val)
            }
        }
        impl From<Tipf> for u8 {
            #[inline(always)]
            fn from(val: Tipf) -> u8 {
                Tipf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tmod {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tmod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tmod {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tmod {
            #[inline(always)]
            fn from(val: u8) -> Tmod {
                Tmod::from_bits(val)
            }
        }
        impl From<Tmod> for u8 {
            #[inline(always)]
            fn from(val: Tmod) -> u8 {
                Tmod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toe {
            #[inline(always)]
            fn from(val: u8) -> Toe {
                Toe::from_bits(val)
            }
        }
        impl From<Toe> for u8 {
            #[inline(always)]
            fn from(val: Toe) -> u8 {
                Toe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toea {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toea {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toea {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toea {
            #[inline(always)]
            fn from(val: u8) -> Toea {
                Toea::from_bits(val)
            }
        }
        impl From<Toea> for u8 {
            #[inline(always)]
            fn from(val: Toea) -> u8 {
                Toea::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toeb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Toeb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toeb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toeb {
            #[inline(always)]
            fn from(val: u8) -> Toeb {
                Toeb::from_bits(val)
            }
        }
        impl From<Toeb> for u8 {
            #[inline(always)]
            fn from(val: Toeb) -> u8 {
                Toeb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Topola {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Topola {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Topola {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Topola {
            #[inline(always)]
            fn from(val: u8) -> Topola {
                Topola::from_bits(val)
            }
        }
        impl From<Topola> for u8 {
            #[inline(always)]
            fn from(val: Topola) -> u8 {
                Topola::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Topolb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Topolb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Topolb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Topolb {
            #[inline(always)]
            fn from(val: u8) -> Topolb {
                Topolb::from_bits(val)
            }
        }
        impl From<Topolb> for u8 {
            #[inline(always)]
            fn from(val: Topolb) -> u8 {
                Topolb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstart {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstart {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstart {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstart {
            #[inline(always)]
            fn from(val: u8) -> Tstart {
                Tstart::from_bits(val)
            }
        }
        impl From<Tstart> for u8 {
            #[inline(always)]
            fn from(val: Tstart) -> u8 {
                Tstart::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstop {
            #[inline(always)]
            fn from(val: u8) -> Tstop {
                Tstop::from_bits(val)
            }
        }
        impl From<Tstop> for u8 {
            #[inline(always)]
            fn from(val: Tstop) -> u8 {
                Tstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tundf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tundf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tundf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tundf {
            #[inline(always)]
            fn from(val: u8) -> Tundf {
                Tundf::from_bits(val)
            }
        }
        impl From<Tundf> for u8 {
            #[inline(always)]
            fn from(val: Tundf) -> u8 {
                Tundf::to_bits(val)
            }
        }
    }
}
pub mod bus {
    #[doc = "BUS Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bus {
        ptr: *mut u8,
    }
    unsafe impl Send for Bus {}
    unsafe impl Sync for Bus {}
    impl Bus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Master Bus Control Register SYS"]
        #[inline(always)]
        pub const fn busmcntsys(self) -> crate::common::Reg<regs::Busmcntsys, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1008usize) as _) }
        }
        #[doc = "Master Bus Control Register DMA"]
        #[inline(always)]
        pub const fn busmcntdma(self) -> crate::common::Reg<regs::Busmcntdma, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x100cusize) as _) }
        }
        #[doc = "Bus Error Address Register 3"]
        #[inline(always)]
        pub const fn bus3erradd(self) -> crate::common::Reg<regs::Bus3erradd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1820usize) as _) }
        }
        #[doc = "BUS Error Status Register 3"]
        #[inline(always)]
        pub const fn bus3errstat(self) -> crate::common::Reg<regs::Bus3errstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1824usize) as _) }
        }
        #[doc = "Bus Error Address Register 4"]
        #[inline(always)]
        pub const fn bus4erradd(self) -> crate::common::Reg<regs::Bus4erradd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1830usize) as _) }
        }
        #[doc = "BUS Error Status Register 4"]
        #[inline(always)]
        pub const fn bus4errstat(self) -> crate::common::Reg<regs::Bus4errstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1834usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bus Error Address Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus3erradd(pub u32);
        impl Bus3erradd {
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub const fn berad(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub fn set_berad(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bus3erradd {
            #[inline(always)]
            fn default() -> Bus3erradd {
                Bus3erradd(0)
            }
        }
        impl core::fmt::Debug for Bus3erradd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus3erradd")
                    .field("berad", &self.berad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus3erradd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bus3erradd {{ berad: {=u32:?} }}", self.berad())
            }
        }
        #[doc = "BUS Error Status Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus3errstat(pub u8);
        impl Bus3errstat {
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub const fn accstat(&self) -> super::vals::Bus3errstatAccstat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bus3errstatAccstat::from_bits(val as u8)
            }
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub fn set_accstat(&mut self, val: super::vals::Bus3errstatAccstat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub const fn errstat(&self) -> super::vals::Bus3errstatErrstat {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bus3errstatErrstat::from_bits(val as u8)
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub fn set_errstat(&mut self, val: super::vals::Bus3errstatErrstat) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Bus3errstat {
            #[inline(always)]
            fn default() -> Bus3errstat {
                Bus3errstat(0)
            }
        }
        impl core::fmt::Debug for Bus3errstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus3errstat")
                    .field("accstat", &self.accstat())
                    .field("errstat", &self.errstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus3errstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bus3errstat {{ accstat: {:?}, errstat: {:?} }}",
                    self.accstat(),
                    self.errstat()
                )
            }
        }
        #[doc = "Bus Error Address Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus4erradd(pub u32);
        impl Bus4erradd {
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub const fn berad(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Bus Error Address"]
            #[inline(always)]
            pub fn set_berad(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Bus4erradd {
            #[inline(always)]
            fn default() -> Bus4erradd {
                Bus4erradd(0)
            }
        }
        impl core::fmt::Debug for Bus4erradd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus4erradd")
                    .field("berad", &self.berad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus4erradd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bus4erradd {{ berad: {=u32:?} }}", self.berad())
            }
        }
        #[doc = "BUS Error Status Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bus4errstat(pub u8);
        impl Bus4errstat {
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub const fn accstat(&self) -> super::vals::Bus4errstatAccstat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bus4errstatAccstat::from_bits(val as u8)
            }
            #[doc = "Error Access Status flag"]
            #[inline(always)]
            pub fn set_accstat(&mut self, val: super::vals::Bus4errstatAccstat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub const fn errstat(&self) -> super::vals::Bus4errstatErrstat {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bus4errstatErrstat::from_bits(val as u8)
            }
            #[doc = "Bus Error Status flag"]
            #[inline(always)]
            pub fn set_errstat(&mut self, val: super::vals::Bus4errstatErrstat) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Bus4errstat {
            #[inline(always)]
            fn default() -> Bus4errstat {
                Bus4errstat(0)
            }
        }
        impl core::fmt::Debug for Bus4errstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bus4errstat")
                    .field("accstat", &self.accstat())
                    .field("errstat", &self.errstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bus4errstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bus4errstat {{ accstat: {:?}, errstat: {:?} }}",
                    self.accstat(),
                    self.errstat()
                )
            }
        }
        #[doc = "Master Bus Control Register DMA"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busmcntdma(pub u16);
        impl Busmcntdma {
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub const fn ieres(&self) -> super::vals::BusmcntdmaIeres {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::BusmcntdmaIeres::from_bits(val as u8)
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub fn set_ieres(&mut self, val: super::vals::BusmcntdmaIeres) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Busmcntdma {
            #[inline(always)]
            fn default() -> Busmcntdma {
                Busmcntdma(0)
            }
        }
        impl core::fmt::Debug for Busmcntdma {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busmcntdma")
                    .field("ieres", &self.ieres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busmcntdma {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Busmcntdma {{ ieres: {:?} }}", self.ieres())
            }
        }
        #[doc = "Master Bus Control Register SYS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Busmcntsys(pub u16);
        impl Busmcntsys {
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub const fn ieres(&self) -> super::vals::BusmcntsysIeres {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::BusmcntsysIeres::from_bits(val as u8)
            }
            #[doc = "Ignore Error Responses"]
            #[inline(always)]
            pub fn set_ieres(&mut self, val: super::vals::BusmcntsysIeres) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Busmcntsys {
            #[inline(always)]
            fn default() -> Busmcntsys {
                Busmcntsys(0)
            }
        }
        impl core::fmt::Debug for Busmcntsys {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Busmcntsys")
                    .field("ieres", &self.ieres())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Busmcntsys {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Busmcntsys {{ ieres: {:?} }}", self.ieres())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus3errstatAccstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus3errstatAccstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus3errstatAccstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus3errstatAccstat {
            #[inline(always)]
            fn from(val: u8) -> Bus3errstatAccstat {
                Bus3errstatAccstat::from_bits(val)
            }
        }
        impl From<Bus3errstatAccstat> for u8 {
            #[inline(always)]
            fn from(val: Bus3errstatAccstat) -> u8 {
                Bus3errstatAccstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus3errstatErrstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus3errstatErrstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus3errstatErrstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus3errstatErrstat {
            #[inline(always)]
            fn from(val: u8) -> Bus3errstatErrstat {
                Bus3errstatErrstat::from_bits(val)
            }
        }
        impl From<Bus3errstatErrstat> for u8 {
            #[inline(always)]
            fn from(val: Bus3errstatErrstat) -> u8 {
                Bus3errstatErrstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus4errstatAccstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus4errstatAccstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus4errstatAccstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus4errstatAccstat {
            #[inline(always)]
            fn from(val: u8) -> Bus4errstatAccstat {
                Bus4errstatAccstat::from_bits(val)
            }
        }
        impl From<Bus4errstatAccstat> for u8 {
            #[inline(always)]
            fn from(val: Bus4errstatAccstat) -> u8 {
                Bus4errstatAccstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bus4errstatErrstat {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bus4errstatErrstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bus4errstatErrstat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bus4errstatErrstat {
            #[inline(always)]
            fn from(val: u8) -> Bus4errstatErrstat {
                Bus4errstatErrstat::from_bits(val)
            }
        }
        impl From<Bus4errstatErrstat> for u8 {
            #[inline(always)]
            fn from(val: Bus4errstatErrstat) -> u8 {
                Bus4errstatErrstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusmcntdmaIeres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl BusmcntdmaIeres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusmcntdmaIeres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusmcntdmaIeres {
            #[inline(always)]
            fn from(val: u8) -> BusmcntdmaIeres {
                BusmcntdmaIeres::from_bits(val)
            }
        }
        impl From<BusmcntdmaIeres> for u8 {
            #[inline(always)]
            fn from(val: BusmcntdmaIeres) -> u8 {
                BusmcntdmaIeres::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum BusmcntsysIeres {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl BusmcntsysIeres {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> BusmcntsysIeres {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for BusmcntsysIeres {
            #[inline(always)]
            fn from(val: u8) -> BusmcntsysIeres {
                BusmcntsysIeres::from_bits(val)
            }
        }
        impl From<BusmcntsysIeres> for u8 {
            #[inline(always)]
            fn from(val: BusmcntsysIeres) -> u8 {
                BusmcntsysIeres::to_bits(val)
            }
        }
    }
}
pub mod cac {
    #[doc = "Clock Frequency Accuracy Measurement Circuit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cac {
        ptr: *mut u8,
    }
    unsafe impl Send for Cac {}
    unsafe impl Sync for Cac {}
    impl Cac {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CAC Control Register 0"]
        #[inline(always)]
        pub const fn cacr0(self) -> crate::common::Reg<regs::Cacr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CAC Control Register 1"]
        #[inline(always)]
        pub const fn cacr1(self) -> crate::common::Reg<regs::Cacr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "CAC Control Register 2"]
        #[inline(always)]
        pub const fn cacr2(self) -> crate::common::Reg<regs::Cacr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "CAC Interrupt Control Register"]
        #[inline(always)]
        pub const fn caicr(self) -> crate::common::Reg<regs::Caicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "CAC Status Register"]
        #[inline(always)]
        pub const fn castr(self) -> crate::common::Reg<regs::Castr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CAC Upper,Limit Value Setting Register"]
        #[inline(always)]
        pub const fn caulvr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "CAC Lower,Limit Value Setting Register"]
        #[inline(always)]
        pub const fn callvr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CAC Counter Buffer Register"]
        #[inline(always)]
        pub const fn cacntbr(self) -> crate::common::Reg<u16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CAC Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr0(pub u8);
        impl Cacr0 {
            #[doc = "Clock Frequency Measurement Enable"]
            #[inline(always)]
            pub const fn cfme(&self) -> super::vals::Cfme {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cfme::from_bits(val as u8)
            }
            #[doc = "Clock Frequency Measurement Enable"]
            #[inline(always)]
            pub fn set_cfme(&mut self, val: super::vals::Cfme) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Cacr0 {
            #[inline(always)]
            fn default() -> Cacr0 {
                Cacr0(0)
            }
        }
        impl core::fmt::Debug for Cacr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr0").field("cfme", &self.cfme()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cacr0 {{ cfme: {:?} }}", self.cfme())
            }
        }
        #[doc = "CAC Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr1(pub u8);
        impl Cacr1 {
            #[doc = "CACREF Pin Input Enable"]
            #[inline(always)]
            pub const fn cacrefe(&self) -> super::vals::Cacrefe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cacrefe::from_bits(val as u8)
            }
            #[doc = "CACREF Pin Input Enable"]
            #[inline(always)]
            pub fn set_cacrefe(&mut self, val: super::vals::Cacrefe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement Target Clock Select"]
            #[inline(always)]
            pub const fn fmcs(&self) -> super::vals::Fmcs {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Fmcs::from_bits(val as u8)
            }
            #[doc = "Measurement Target Clock Select"]
            #[inline(always)]
            pub fn set_fmcs(&mut self, val: super::vals::Fmcs) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u8) & 0x07) << 1usize);
            }
            #[doc = "Timer Count Clock Source Select"]
            #[inline(always)]
            pub const fn tcss(&self) -> super::vals::Tcss {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Tcss::from_bits(val as u8)
            }
            #[doc = "Timer Count Clock Source Select"]
            #[inline(always)]
            pub fn set_tcss(&mut self, val: super::vals::Tcss) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Valid Edge Select"]
            #[inline(always)]
            pub const fn edges(&self) -> super::vals::Edges {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Edges::from_bits(val as u8)
            }
            #[doc = "Valid Edge Select"]
            #[inline(always)]
            pub fn set_edges(&mut self, val: super::vals::Edges) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Cacr1 {
            #[inline(always)]
            fn default() -> Cacr1 {
                Cacr1(0)
            }
        }
        impl core::fmt::Debug for Cacr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr1")
                    .field("cacrefe", &self.cacrefe())
                    .field("fmcs", &self.fmcs())
                    .field("tcss", &self.tcss())
                    .field("edges", &self.edges())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cacr1 {{ cacrefe: {:?}, fmcs: {:?}, tcss: {:?}, edges: {:?} }}",
                    self.cacrefe(),
                    self.fmcs(),
                    self.tcss(),
                    self.edges()
                )
            }
        }
        #[doc = "CAC Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cacr2(pub u8);
        impl Cacr2 {
            #[doc = "Reference Signal Select"]
            #[inline(always)]
            pub const fn rps(&self) -> super::vals::Rps {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rps::from_bits(val as u8)
            }
            #[doc = "Reference Signal Select"]
            #[inline(always)]
            pub fn set_rps(&mut self, val: super::vals::Rps) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement Reference Clock Select"]
            #[inline(always)]
            pub const fn rscs(&self) -> super::vals::Rscs {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::Rscs::from_bits(val as u8)
            }
            #[doc = "Measurement Reference Clock Select"]
            #[inline(always)]
            pub fn set_rscs(&mut self, val: super::vals::Rscs) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u8) & 0x07) << 1usize);
            }
            #[doc = "Measurement Reference Clock Frequency Division Ratio Select"]
            #[inline(always)]
            pub const fn rcds(&self) -> super::vals::Rcds {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Rcds::from_bits(val as u8)
            }
            #[doc = "Measurement Reference Clock Frequency Division Ratio Select"]
            #[inline(always)]
            pub fn set_rcds(&mut self, val: super::vals::Rcds) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "Digital Filter Select"]
            #[inline(always)]
            pub const fn dfs(&self) -> super::vals::Dfs {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Dfs::from_bits(val as u8)
            }
            #[doc = "Digital Filter Select"]
            #[inline(always)]
            pub fn set_dfs(&mut self, val: super::vals::Dfs) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Cacr2 {
            #[inline(always)]
            fn default() -> Cacr2 {
                Cacr2(0)
            }
        }
        impl core::fmt::Debug for Cacr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cacr2")
                    .field("rps", &self.rps())
                    .field("rscs", &self.rscs())
                    .field("rcds", &self.rcds())
                    .field("dfs", &self.dfs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cacr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cacr2 {{ rps: {:?}, rscs: {:?}, rcds: {:?}, dfs: {:?} }}",
                    self.rps(),
                    self.rscs(),
                    self.rcds(),
                    self.dfs()
                )
            }
        }
        #[doc = "CAC Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Caicr(pub u8);
        impl Caicr {
            #[doc = "Frequency Error Interrupt Request Enable"]
            #[inline(always)]
            pub const fn ferrie(&self) -> super::vals::Ferrie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ferrie::from_bits(val as u8)
            }
            #[doc = "Frequency Error Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_ferrie(&mut self, val: super::vals::Ferrie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement End Interrupt Request Enable"]
            #[inline(always)]
            pub const fn mendie(&self) -> super::vals::Mendie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mendie::from_bits(val as u8)
            }
            #[doc = "Measurement End Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_mendie(&mut self, val: super::vals::Mendie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Overflow Interrupt Request Enable"]
            #[inline(always)]
            pub const fn ovfie(&self) -> super::vals::Ovfie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ovfie::from_bits(val as u8)
            }
            #[doc = "Overflow Interrupt Request Enable"]
            #[inline(always)]
            pub fn set_ovfie(&mut self, val: super::vals::Ovfie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "FERRF Clear"]
            #[inline(always)]
            pub const fn ferrfcl(&self) -> super::vals::Ferrfcl {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ferrfcl::from_bits(val as u8)
            }
            #[doc = "FERRF Clear"]
            #[inline(always)]
            pub fn set_ferrfcl(&mut self, val: super::vals::Ferrfcl) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "MENDF Clear"]
            #[inline(always)]
            pub const fn mendfcl(&self) -> super::vals::Mendfcl {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Mendfcl::from_bits(val as u8)
            }
            #[doc = "MENDF Clear"]
            #[inline(always)]
            pub fn set_mendfcl(&mut self, val: super::vals::Mendfcl) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "OVFF Clear"]
            #[inline(always)]
            pub const fn ovffcl(&self) -> super::vals::Ovffcl {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ovffcl::from_bits(val as u8)
            }
            #[doc = "OVFF Clear"]
            #[inline(always)]
            pub fn set_ovffcl(&mut self, val: super::vals::Ovffcl) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Caicr {
            #[inline(always)]
            fn default() -> Caicr {
                Caicr(0)
            }
        }
        impl core::fmt::Debug for Caicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Caicr")
                    .field("ferrie", &self.ferrie())
                    .field("mendie", &self.mendie())
                    .field("ovfie", &self.ovfie())
                    .field("ferrfcl", &self.ferrfcl())
                    .field("mendfcl", &self.mendfcl())
                    .field("ovffcl", &self.ovffcl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Caicr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Caicr {{ ferrie: {:?}, mendie: {:?}, ovfie: {:?}, ferrfcl: {:?}, mendfcl: {:?}, ovffcl: {:?} }}" , self . ferrie () , self . mendie () , self . ovfie () , self . ferrfcl () , self . mendfcl () , self . ovffcl ())
            }
        }
        #[doc = "CAC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Castr(pub u8);
        impl Castr {
            #[doc = "Frequency Error Flag"]
            #[inline(always)]
            pub const fn ferrf(&self) -> super::vals::Ferrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ferrf::from_bits(val as u8)
            }
            #[doc = "Frequency Error Flag"]
            #[inline(always)]
            pub fn set_ferrf(&mut self, val: super::vals::Ferrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Measurement End Flag"]
            #[inline(always)]
            pub const fn mendf(&self) -> super::vals::Mendf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mendf::from_bits(val as u8)
            }
            #[doc = "Measurement End Flag"]
            #[inline(always)]
            pub fn set_mendf(&mut self, val: super::vals::Mendf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub const fn ovff(&self) -> super::vals::Ovff {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ovff::from_bits(val as u8)
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub fn set_ovff(&mut self, val: super::vals::Ovff) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Castr {
            #[inline(always)]
            fn default() -> Castr {
                Castr(0)
            }
        }
        impl core::fmt::Debug for Castr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Castr")
                    .field("ferrf", &self.ferrf())
                    .field("mendf", &self.mendf())
                    .field("ovff", &self.ovff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Castr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Castr {{ ferrf: {:?}, mendf: {:?}, ovff: {:?} }}",
                    self.ferrf(),
                    self.mendf(),
                    self.ovff()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cacrefe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cacrefe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cacrefe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cacrefe {
            #[inline(always)]
            fn from(val: u8) -> Cacrefe {
                Cacrefe::from_bits(val)
            }
        }
        impl From<Cacrefe> for u8 {
            #[inline(always)]
            fn from(val: Cacrefe) -> u8 {
                Cacrefe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cfme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cfme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cfme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cfme {
            #[inline(always)]
            fn from(val: u8) -> Cfme {
                Cfme::from_bits(val)
            }
        }
        impl From<Cfme> for u8 {
            #[inline(always)]
            fn from(val: Cfme) -> u8 {
                Cfme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dfs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfs {
            #[inline(always)]
            fn from(val: u8) -> Dfs {
                Dfs::from_bits(val)
            }
        }
        impl From<Dfs> for u8 {
            #[inline(always)]
            fn from(val: Dfs) -> u8 {
                Dfs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edges {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Edges {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edges {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edges {
            #[inline(always)]
            fn from(val: u8) -> Edges {
                Edges::from_bits(val)
            }
        }
        impl From<Edges> for u8 {
            #[inline(always)]
            fn from(val: Edges) -> u8 {
                Edges::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrf {
            #[inline(always)]
            fn from(val: u8) -> Ferrf {
                Ferrf::from_bits(val)
            }
        }
        impl From<Ferrf> for u8 {
            #[inline(always)]
            fn from(val: Ferrf) -> u8 {
                Ferrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrfcl {
            #[inline(always)]
            fn from(val: u8) -> Ferrfcl {
                Ferrfcl::from_bits(val)
            }
        }
        impl From<Ferrfcl> for u8 {
            #[inline(always)]
            fn from(val: Ferrfcl) -> u8 {
                Ferrfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ferrie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ferrie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ferrie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ferrie {
            #[inline(always)]
            fn from(val: u8) -> Ferrie {
                Ferrie::from_bits(val)
            }
        }
        impl From<Ferrie> for u8 {
            #[inline(always)]
            fn from(val: Ferrie) -> u8 {
                Ferrie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fmcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fmcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fmcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fmcs {
            #[inline(always)]
            fn from(val: u8) -> Fmcs {
                Fmcs::from_bits(val)
            }
        }
        impl From<Fmcs> for u8 {
            #[inline(always)]
            fn from(val: Fmcs) -> u8 {
                Fmcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendf {
            #[inline(always)]
            fn from(val: u8) -> Mendf {
                Mendf::from_bits(val)
            }
        }
        impl From<Mendf> for u8 {
            #[inline(always)]
            fn from(val: Mendf) -> u8 {
                Mendf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendfcl {
            #[inline(always)]
            fn from(val: u8) -> Mendfcl {
                Mendfcl::from_bits(val)
            }
        }
        impl From<Mendfcl> for u8 {
            #[inline(always)]
            fn from(val: Mendfcl) -> u8 {
                Mendfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mendie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mendie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mendie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mendie {
            #[inline(always)]
            fn from(val: u8) -> Mendie {
                Mendie::from_bits(val)
            }
        }
        impl From<Mendie> for u8 {
            #[inline(always)]
            fn from(val: Mendie) -> u8 {
                Mendie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovff {
            #[inline(always)]
            fn from(val: u8) -> Ovff {
                Ovff::from_bits(val)
            }
        }
        impl From<Ovff> for u8 {
            #[inline(always)]
            fn from(val: Ovff) -> u8 {
                Ovff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovffcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovffcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovffcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovffcl {
            #[inline(always)]
            fn from(val: u8) -> Ovffcl {
                Ovffcl::from_bits(val)
            }
        }
        impl From<Ovffcl> for u8 {
            #[inline(always)]
            fn from(val: Ovffcl) -> u8 {
                Ovffcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovfie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovfie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovfie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovfie {
            #[inline(always)]
            fn from(val: u8) -> Ovfie {
                Ovfie::from_bits(val)
            }
        }
        impl From<Ovfie> for u8 {
            #[inline(always)]
            fn from(val: Ovfie) -> u8 {
                Ovfie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rcds {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rcds {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rcds {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rcds {
            #[inline(always)]
            fn from(val: u8) -> Rcds {
                Rcds::from_bits(val)
            }
        }
        impl From<Rcds> for u8 {
            #[inline(always)]
            fn from(val: Rcds) -> u8 {
                Rcds::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rps {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rps {
            #[inline(always)]
            fn from(val: u8) -> Rps {
                Rps::from_bits(val)
            }
        }
        impl From<Rps> for u8 {
            #[inline(always)]
            fn from(val: Rps) -> u8 {
                Rps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rscs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rscs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rscs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rscs {
            #[inline(always)]
            fn from(val: u8) -> Rscs {
                Rscs::from_bits(val)
            }
        }
        impl From<Rscs> for u8 {
            #[inline(always)]
            fn from(val: Rscs) -> u8 {
                Rscs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tcss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcss {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcss {
            #[inline(always)]
            fn from(val: u8) -> Tcss {
                Tcss::from_bits(val)
            }
        }
        impl From<Tcss> for u8 {
            #[inline(always)]
            fn from(val: Tcss) -> u8 {
                Tcss::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = Default::default();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = self.read();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
}
pub mod crc {
    #[doc = "Cyclic Redundancy Check Calculator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Crc {
        ptr: *mut u8,
    }
    unsafe impl Send for Crc {}
    unsafe impl Sync for Crc {}
    impl Crc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CRC Control Register 0"]
        #[inline(always)]
        pub const fn crccr0(self) -> crate::common::Reg<regs::Crccr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "CRC Control Register 1"]
        #[inline(always)]
        pub const fn crccr1(self) -> crate::common::Reg<regs::Crccr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "CRC Data Input Register"]
        #[inline(always)]
        pub const fn crcdir(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CRC Data Input Register"]
        #[inline(always)]
        pub const fn crcdir_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "CRC Data Output Register"]
        #[inline(always)]
        pub const fn crcdor_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Snoop Address Register"]
        #[inline(always)]
        pub const fn crcsar(self) -> crate::common::Reg<regs::Crcsar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CRC Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccr0(pub u8);
        impl Crccr0 {
            #[doc = "CRC Generating Polynomial Switching"]
            #[inline(always)]
            pub const fn gps(&self) -> super::vals::Gps {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Gps::from_bits(val as u8)
            }
            #[doc = "CRC Generating Polynomial Switching"]
            #[inline(always)]
            pub fn set_gps(&mut self, val: super::vals::Gps) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "CRC Calculation Switching"]
            #[inline(always)]
            pub const fn lms(&self) -> super::vals::Lms {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lms::from_bits(val as u8)
            }
            #[doc = "CRC Calculation Switching"]
            #[inline(always)]
            pub fn set_lms(&mut self, val: super::vals::Lms) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "CRCDOR/CRCDOR_HA/CRCDOR_BY Register Clear"]
            #[inline(always)]
            pub const fn dorclr(&self) -> super::vals::Dorclr {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dorclr::from_bits(val as u8)
            }
            #[doc = "CRCDOR/CRCDOR_HA/CRCDOR_BY Register Clear"]
            #[inline(always)]
            pub fn set_dorclr(&mut self, val: super::vals::Dorclr) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Crccr0 {
            #[inline(always)]
            fn default() -> Crccr0 {
                Crccr0(0)
            }
        }
        impl core::fmt::Debug for Crccr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccr0")
                    .field("gps", &self.gps())
                    .field("lms", &self.lms())
                    .field("dorclr", &self.dorclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccr0 {{ gps: {:?}, lms: {:?}, dorclr: {:?} }}",
                    self.gps(),
                    self.lms(),
                    self.dorclr()
                )
            }
        }
        #[doc = "CRC Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccr1(pub u8);
        impl Crccr1 {
            #[doc = "Snoop,On,Write/Read Switch"]
            #[inline(always)]
            pub const fn crcswr(&self) -> super::vals::Crcswr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Crcswr::from_bits(val as u8)
            }
            #[doc = "Snoop,On,Write/Read Switch"]
            #[inline(always)]
            pub fn set_crcswr(&mut self, val: super::vals::Crcswr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Snoop Enable"]
            #[inline(always)]
            pub const fn crcsen(&self) -> super::vals::Crcsen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Crcsen::from_bits(val as u8)
            }
            #[doc = "Snoop Enable"]
            #[inline(always)]
            pub fn set_crcsen(&mut self, val: super::vals::Crcsen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Crccr1 {
            #[inline(always)]
            fn default() -> Crccr1 {
                Crccr1(0)
            }
        }
        impl core::fmt::Debug for Crccr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccr1")
                    .field("crcswr", &self.crcswr())
                    .field("crcsen", &self.crcsen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccr1 {{ crcswr: {:?}, crcsen: {:?} }}",
                    self.crcswr(),
                    self.crcsen()
                )
            }
        }
        #[doc = "Snoop Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcsar(pub u16);
        impl Crcsar {
            #[doc = "Register Snoop Address"]
            #[inline(always)]
            pub const fn crcsa(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Register Snoop Address"]
            #[inline(always)]
            pub fn set_crcsa(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
        }
        impl Default for Crcsar {
            #[inline(always)]
            fn default() -> Crcsar {
                Crcsar(0)
            }
        }
        impl core::fmt::Debug for Crcsar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcsar")
                    .field("crcsa", &self.crcsa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcsar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcsar {{ crcsa: {=u16:?} }}", self.crcsa())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcsen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Crcsen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcsen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcsen {
            #[inline(always)]
            fn from(val: u8) -> Crcsen {
                Crcsen::from_bits(val)
            }
        }
        impl From<Crcsen> for u8 {
            #[inline(always)]
            fn from(val: Crcsen) -> u8 {
                Crcsen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcswr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Crcswr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcswr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcswr {
            #[inline(always)]
            fn from(val: u8) -> Crcswr {
                Crcswr::from_bits(val)
            }
        }
        impl From<Crcswr> for u8 {
            #[inline(always)]
            fn from(val: Crcswr) -> u8 {
                Crcswr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dorclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dorclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dorclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dorclr {
            #[inline(always)]
            fn from(val: u8) -> Dorclr {
                Dorclr::from_bits(val)
            }
        }
        impl From<Dorclr> for u8 {
            #[inline(always)]
            fn from(val: Dorclr) -> u8 {
                Dorclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gps {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Gps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gps {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gps {
            #[inline(always)]
            fn from(val: u8) -> Gps {
                Gps::from_bits(val)
            }
        }
        impl From<Gps> for u8 {
            #[inline(always)]
            fn from(val: Gps) -> u8 {
                Gps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lms {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lms {
            #[inline(always)]
            fn from(val: u8) -> Lms {
                Lms::from_bits(val)
            }
        }
        impl From<Lms> for u8 {
            #[inline(always)]
            fn from(val: Lms) -> u8 {
                Lms::to_bits(val)
            }
        }
    }
}
pub mod dbg {
    #[doc = "Debug Function"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dbg {
        ptr: *mut u8,
    }
    unsafe impl Send for Dbg {}
    unsafe impl Sync for Dbg {}
    impl Dbg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Debug Status Register"]
        #[inline(always)]
        pub const fn dbgstr(self) -> crate::common::Reg<regs::Dbgstr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Debug Stop Control Register"]
        #[inline(always)]
        pub const fn dbgstopcr(self) -> crate::common::Reg<regs::Dbgstopcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug Stop Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgstopcr(pub u32);
        impl Dbgstopcr {
            #[doc = "Mask bit for IWDT reset/interrupt in the OCD run mode"]
            #[inline(always)]
            pub const fn dbgstop_iwdt(&self) -> super::vals::DbgstopIwdt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DbgstopIwdt::from_bits(val as u8)
            }
            #[doc = "Mask bit for IWDT reset/interrupt in the OCD run mode"]
            #[inline(always)]
            pub fn set_dbgstop_iwdt(&mut self, val: super::vals::DbgstopIwdt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Mask bit for WDT reset/interrupt in the OCD run mode"]
            #[inline(always)]
            pub const fn dbgstop_wdt(&self) -> super::vals::DbgstopWdt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::DbgstopWdt::from_bits(val as u8)
            }
            #[doc = "Mask bit for WDT reset/interrupt in the OCD run mode"]
            #[inline(always)]
            pub fn set_dbgstop_wdt(&mut self, val: super::vals::DbgstopWdt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Mask bit for LVD0 reset"]
            #[inline(always)]
            pub const fn dbgstop_lvd0(&self) -> super::vals::DbgstopLvd0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::DbgstopLvd0::from_bits(val as u8)
            }
            #[doc = "Mask bit for LVD0 reset"]
            #[inline(always)]
            pub fn set_dbgstop_lvd0(&mut self, val: super::vals::DbgstopLvd0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Mask bit for LVD1 reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_lvd1(&self) -> super::vals::DbgstopLvd1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::DbgstopLvd1::from_bits(val as u8)
            }
            #[doc = "Mask bit for LVD1 reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_lvd1(&mut self, val: super::vals::DbgstopLvd1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Mask bit for LVD2 reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_lvd2(&self) -> super::vals::DbgstopLvd2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::DbgstopLvd2::from_bits(val as u8)
            }
            #[doc = "Mask bit for LVD2 reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_lvd2(&mut self, val: super::vals::DbgstopLvd2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Mask bit for SRAM parity error reset/interrupt"]
            #[inline(always)]
            pub const fn dbgstop_rper(&self) -> super::vals::DbgstopRper {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::DbgstopRper::from_bits(val as u8)
            }
            #[doc = "Mask bit for SRAM parity error reset/interrupt"]
            #[inline(always)]
            pub fn set_dbgstop_rper(&mut self, val: super::vals::DbgstopRper) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Dbgstopcr {
            #[inline(always)]
            fn default() -> Dbgstopcr {
                Dbgstopcr(0)
            }
        }
        impl core::fmt::Debug for Dbgstopcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgstopcr")
                    .field("dbgstop_iwdt", &self.dbgstop_iwdt())
                    .field("dbgstop_wdt", &self.dbgstop_wdt())
                    .field("dbgstop_lvd0", &self.dbgstop_lvd0())
                    .field("dbgstop_lvd1", &self.dbgstop_lvd1())
                    .field("dbgstop_lvd2", &self.dbgstop_lvd2())
                    .field("dbgstop_rper", &self.dbgstop_rper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgstopcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dbgstopcr {{ dbgstop_iwdt: {:?}, dbgstop_wdt: {:?}, dbgstop_lvd0: {:?}, dbgstop_lvd1: {:?}, dbgstop_lvd2: {:?}, dbgstop_rper: {:?} }}" , self . dbgstop_iwdt () , self . dbgstop_wdt () , self . dbgstop_lvd0 () , self . dbgstop_lvd1 () , self . dbgstop_lvd2 () , self . dbgstop_rper ())
            }
        }
        #[doc = "Debug Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgstr(pub u32);
        impl Dbgstr {
            #[doc = "Debug power,up request"]
            #[inline(always)]
            pub const fn cdbgpwrupreq(&self) -> super::vals::Cdbgpwrupreq {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Cdbgpwrupreq::from_bits(val as u8)
            }
            #[doc = "Debug power,up request"]
            #[inline(always)]
            pub fn set_cdbgpwrupreq(&mut self, val: super::vals::Cdbgpwrupreq) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Debug power,up acknowledge"]
            #[inline(always)]
            pub const fn cdbgpwrupack(&self) -> super::vals::Cdbgpwrupack {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Cdbgpwrupack::from_bits(val as u8)
            }
            #[doc = "Debug power,up acknowledge"]
            #[inline(always)]
            pub fn set_cdbgpwrupack(&mut self, val: super::vals::Cdbgpwrupack) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Dbgstr {
            #[inline(always)]
            fn default() -> Dbgstr {
                Dbgstr(0)
            }
        }
        impl core::fmt::Debug for Dbgstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgstr")
                    .field("cdbgpwrupreq", &self.cdbgpwrupreq())
                    .field("cdbgpwrupack", &self.cdbgpwrupack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgstr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dbgstr {{ cdbgpwrupreq: {:?}, cdbgpwrupack: {:?} }}",
                    self.cdbgpwrupreq(),
                    self.cdbgpwrupack()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdbgpwrupack {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdbgpwrupack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdbgpwrupack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdbgpwrupack {
            #[inline(always)]
            fn from(val: u8) -> Cdbgpwrupack {
                Cdbgpwrupack::from_bits(val)
            }
        }
        impl From<Cdbgpwrupack> for u8 {
            #[inline(always)]
            fn from(val: Cdbgpwrupack) -> u8 {
                Cdbgpwrupack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdbgpwrupreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cdbgpwrupreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdbgpwrupreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdbgpwrupreq {
            #[inline(always)]
            fn from(val: u8) -> Cdbgpwrupreq {
                Cdbgpwrupreq::from_bits(val)
            }
        }
        impl From<Cdbgpwrupreq> for u8 {
            #[inline(always)]
            fn from(val: Cdbgpwrupreq) -> u8 {
                Cdbgpwrupreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopIwdt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopIwdt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopIwdt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopIwdt {
            #[inline(always)]
            fn from(val: u8) -> DbgstopIwdt {
                DbgstopIwdt::from_bits(val)
            }
        }
        impl From<DbgstopIwdt> for u8 {
            #[inline(always)]
            fn from(val: DbgstopIwdt) -> u8 {
                DbgstopIwdt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopLvd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopLvd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopLvd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopLvd0 {
            #[inline(always)]
            fn from(val: u8) -> DbgstopLvd0 {
                DbgstopLvd0::from_bits(val)
            }
        }
        impl From<DbgstopLvd0> for u8 {
            #[inline(always)]
            fn from(val: DbgstopLvd0) -> u8 {
                DbgstopLvd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopLvd1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopLvd1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopLvd1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopLvd1 {
            #[inline(always)]
            fn from(val: u8) -> DbgstopLvd1 {
                DbgstopLvd1::from_bits(val)
            }
        }
        impl From<DbgstopLvd1> for u8 {
            #[inline(always)]
            fn from(val: DbgstopLvd1) -> u8 {
                DbgstopLvd1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopLvd2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopLvd2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopLvd2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopLvd2 {
            #[inline(always)]
            fn from(val: u8) -> DbgstopLvd2 {
                DbgstopLvd2::from_bits(val)
            }
        }
        impl From<DbgstopLvd2> for u8 {
            #[inline(always)]
            fn from(val: DbgstopLvd2) -> u8 {
                DbgstopLvd2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopRper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopRper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopRper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopRper {
            #[inline(always)]
            fn from(val: u8) -> DbgstopRper {
                DbgstopRper::from_bits(val)
            }
        }
        impl From<DbgstopRper> for u8 {
            #[inline(always)]
            fn from(val: DbgstopRper) -> u8 {
                DbgstopRper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DbgstopWdt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl DbgstopWdt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DbgstopWdt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DbgstopWdt {
            #[inline(always)]
            fn from(val: u8) -> DbgstopWdt {
                DbgstopWdt::from_bits(val)
            }
        }
        impl From<DbgstopWdt> for u8 {
            #[inline(always)]
            fn from(val: DbgstopWdt) -> u8 {
                DbgstopWdt::to_bits(val)
            }
        }
    }
}
pub mod doc {
    #[doc = "Data Operation Circuit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Doc {
        ptr: *mut u8,
    }
    unsafe impl Send for Doc {}
    unsafe impl Sync for Doc {}
    impl Doc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "DOC Control Register"]
        #[inline(always)]
        pub const fn docr(self) -> crate::common::Reg<regs::Docr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "DOC Data Input Register"]
        #[inline(always)]
        pub const fn dodir(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "DOC Data Setting Register"]
        #[inline(always)]
        pub const fn dodsr(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "DOC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Docr(pub u8);
        impl Docr {
            #[doc = "Operating Mode Select"]
            #[inline(always)]
            pub const fn oms(&self) -> super::vals::Oms {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Oms::from_bits(val as u8)
            }
            #[doc = "Operating Mode Select"]
            #[inline(always)]
            pub fn set_oms(&mut self, val: super::vals::Oms) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Detection Condition Select"]
            #[inline(always)]
            pub const fn dcsel(&self) -> super::vals::Dcsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dcsel::from_bits(val as u8)
            }
            #[doc = "Detection Condition Select"]
            #[inline(always)]
            pub fn set_dcsel(&mut self, val: super::vals::Dcsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "DOC Flag"]
            #[inline(always)]
            pub const fn dopcf(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "DOC Flag"]
            #[inline(always)]
            pub fn set_dopcf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "DOPCF Clear"]
            #[inline(always)]
            pub const fn dopcfcl(&self) -> super::vals::Dopcfcl {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Dopcfcl::from_bits(val as u8)
            }
            #[doc = "DOPCF Clear"]
            #[inline(always)]
            pub fn set_dopcfcl(&mut self, val: super::vals::Dopcfcl) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Docr {
            #[inline(always)]
            fn default() -> Docr {
                Docr(0)
            }
        }
        impl core::fmt::Debug for Docr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Docr")
                    .field("oms", &self.oms())
                    .field("dcsel", &self.dcsel())
                    .field("dopcf", &self.dopcf())
                    .field("dopcfcl", &self.dopcfcl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Docr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Docr {{ oms: {:?}, dcsel: {:?}, dopcf: {=bool:?}, dopcfcl: {:?} }}",
                    self.oms(),
                    self.dcsel(),
                    self.dopcf(),
                    self.dopcfcl()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcsel {
            #[inline(always)]
            fn from(val: u8) -> Dcsel {
                Dcsel::from_bits(val)
            }
        }
        impl From<Dcsel> for u8 {
            #[inline(always)]
            fn from(val: Dcsel) -> u8 {
                Dcsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dopcfcl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dopcfcl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dopcfcl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dopcfcl {
            #[inline(always)]
            fn from(val: u8) -> Dopcfcl {
                Dopcfcl::from_bits(val)
            }
        }
        impl From<Dopcfcl> for u8 {
            #[inline(always)]
            fn from(val: Dopcfcl) -> u8 {
                Dopcfcl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oms {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oms {
            #[inline(always)]
            fn from(val: u8) -> Oms {
                Oms::from_bits(val)
            }
        }
        impl From<Oms> for u8 {
            #[inline(always)]
            fn from(val: Oms) -> u8 {
                Oms::to_bits(val)
            }
        }
    }
}
pub mod dtc {
    #[doc = "Data Transfer Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Dtc {}
    unsafe impl Sync for Dtc {}
    impl Dtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "DTC Control Register"]
        #[inline(always)]
        pub const fn dtccr(self) -> crate::common::Reg<regs::Dtccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "DTC Vector Base Register"]
        #[inline(always)]
        pub const fn dtcvbr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "DTC Module Start Register"]
        #[inline(always)]
        pub const fn dtcst(self) -> crate::common::Reg<regs::Dtcst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "DTC Status Register"]
        #[inline(always)]
        pub const fn dtcsts(self) -> crate::common::Reg<regs::Dtcsts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "DTC Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtccr(pub u8);
        impl Dtccr {
            #[doc = "DTC Transfer Information Read Skip Enable"]
            #[inline(always)]
            pub const fn rrs(&self) -> super::vals::Rrs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rrs::from_bits(val as u8)
            }
            #[doc = "DTC Transfer Information Read Skip Enable"]
            #[inline(always)]
            pub fn set_rrs(&mut self, val: super::vals::Rrs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Dtccr {
            #[inline(always)]
            fn default() -> Dtccr {
                Dtccr(0)
            }
        }
        impl core::fmt::Debug for Dtccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtccr").field("rrs", &self.rrs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dtccr {{ rrs: {:?} }}", self.rrs())
            }
        }
        #[doc = "DTC Module Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcst(pub u8);
        impl Dtcst {
            #[doc = "DTC Module Start"]
            #[inline(always)]
            pub const fn dtcst(&self) -> super::vals::Dtcst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dtcst::from_bits(val as u8)
            }
            #[doc = "DTC Module Start"]
            #[inline(always)]
            pub fn set_dtcst(&mut self, val: super::vals::Dtcst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Dtcst {
            #[inline(always)]
            fn default() -> Dtcst {
                Dtcst(0)
            }
        }
        impl core::fmt::Debug for Dtcst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcst")
                    .field("dtcst", &self.dtcst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dtcst {{ dtcst: {:?} }}", self.dtcst())
            }
        }
        #[doc = "DTC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtcsts(pub u16);
        impl Dtcsts {
            #[doc = "DTC,Activating Vector Number Monitoring"]
            #[inline(always)]
            pub const fn vecn(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DTC,Activating Vector Number Monitoring"]
            #[inline(always)]
            pub fn set_vecn(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
            #[doc = "DTC Active Flag"]
            #[inline(always)]
            pub const fn act(&self) -> super::vals::Act {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Act::from_bits(val as u8)
            }
            #[doc = "DTC Active Flag"]
            #[inline(always)]
            pub fn set_act(&mut self, val: super::vals::Act) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Dtcsts {
            #[inline(always)]
            fn default() -> Dtcsts {
                Dtcsts(0)
            }
        }
        impl core::fmt::Debug for Dtcsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtcsts")
                    .field("vecn", &self.vecn())
                    .field("act", &self.act())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtcsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtcsts {{ vecn: {=u8:?}, act: {:?} }}",
                    self.vecn(),
                    self.act()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Act {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Act {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Act {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Act {
            #[inline(always)]
            fn from(val: u8) -> Act {
                Act::from_bits(val)
            }
        }
        impl From<Act> for u8 {
            #[inline(always)]
            fn from(val: Act) -> u8 {
                Act::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtcst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtcst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtcst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtcst {
            #[inline(always)]
            fn from(val: u8) -> Dtcst {
                Dtcst::from_bits(val)
            }
        }
        impl From<Dtcst> for u8 {
            #[inline(always)]
            fn from(val: Dtcst) -> u8 {
                Dtcst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rrs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rrs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rrs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rrs {
            #[inline(always)]
            fn from(val: u8) -> Rrs {
                Rrs::from_bits(val)
            }
        }
        impl From<Rrs> for u8 {
            #[inline(always)]
            fn from(val: Rrs) -> u8 {
                Rrs::to_bits(val)
            }
        }
    }
}
pub mod elc {
    #[doc = "Event Link Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Elc {
        ptr: *mut u8,
    }
    unsafe impl Send for Elc {}
    unsafe impl Sync for Elc {}
    impl Elc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Event Link Controller Register"]
        #[inline(always)]
        pub const fn elcr(self) -> crate::common::Reg<regs::Elcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Event Link Software Event Generation Register %s"]
        #[inline(always)]
        pub const fn elsegr(self, n: usize) -> crate::common::Reg<regs::Elsegr, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize + n * 2usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr(self, n: usize) -> crate::common::Reg<regs::Elsr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr_1(self, n: usize) -> crate::common::Reg<regs::Elsr1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
        #[doc = "Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn elsr_2(self, n: usize) -> crate::common::Reg<regs::Elsr2, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Event Link Controller Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elcr(pub u8);
        impl Elcr {
            #[doc = "All Event Link Enable"]
            #[inline(always)]
            pub const fn elcon(&self) -> super::vals::Elcon {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Elcon::from_bits(val as u8)
            }
            #[doc = "All Event Link Enable"]
            #[inline(always)]
            pub fn set_elcon(&mut self, val: super::vals::Elcon) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Elcr {
            #[inline(always)]
            fn default() -> Elcr {
                Elcr(0)
            }
        }
        impl core::fmt::Debug for Elcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elcr")
                    .field("elcon", &self.elcon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elcr {{ elcon: {:?} }}", self.elcon())
            }
        }
        #[doc = "Event Link Software Event Generation Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsegr(pub u8);
        impl Elsegr {
            #[doc = "Software Event Generation"]
            #[inline(always)]
            pub const fn seg(&self) -> super::vals::Seg {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Seg::from_bits(val as u8)
            }
            #[doc = "Software Event Generation"]
            #[inline(always)]
            pub fn set_seg(&mut self, val: super::vals::Seg) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SEG Bit Write Enable"]
            #[inline(always)]
            pub const fn we(&self) -> super::vals::We {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::We::from_bits(val as u8)
            }
            #[doc = "SEG Bit Write Enable"]
            #[inline(always)]
            pub fn set_we(&mut self, val: super::vals::We) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "ELSEGR Register Write Disable"]
            #[inline(always)]
            pub const fn wi(&self) -> super::vals::Wi {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wi::from_bits(val as u8)
            }
            #[doc = "ELSEGR Register Write Disable"]
            #[inline(always)]
            pub fn set_wi(&mut self, val: super::vals::Wi) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Elsegr {
            #[inline(always)]
            fn default() -> Elsegr {
                Elsegr(0)
            }
        }
        impl core::fmt::Debug for Elsegr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsegr")
                    .field("seg", &self.seg())
                    .field("we", &self.we())
                    .field("wi", &self.wi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsegr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Elsegr {{ seg: {:?}, we: {:?}, wi: {:?} }}",
                    self.seg(),
                    self.we(),
                    self.wi()
                )
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr(pub u16);
        impl Elsr {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
        }
        impl Default for Elsr {
            #[inline(always)]
            fn default() -> Elsr {
                Elsr(0)
            }
        }
        impl core::fmt::Debug for Elsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr").field("els", &self.els()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elsr {{ els: {=u8:?} }}", self.els())
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr1(pub u16);
        impl Elsr1 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
        }
        impl Default for Elsr1 {
            #[inline(always)]
            fn default() -> Elsr1 {
                Elsr1(0)
            }
        }
        impl core::fmt::Debug for Elsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr1").field("els", &self.els()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elsr1 {{ els: {=u8:?} }}", self.els())
            }
        }
        #[doc = "Event Link Setting Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Elsr2(pub u16);
        impl Elsr2 {
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub const fn els(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Event Link Select"]
            #[inline(always)]
            pub fn set_els(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u16) & 0xff) << 0usize);
            }
        }
        impl Default for Elsr2 {
            #[inline(always)]
            fn default() -> Elsr2 {
                Elsr2(0)
            }
        }
        impl core::fmt::Debug for Elsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Elsr2").field("els", &self.els()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Elsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Elsr2 {{ els: {=u8:?} }}", self.els())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Elcon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Elcon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Elcon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Elcon {
            #[inline(always)]
            fn from(val: u8) -> Elcon {
                Elcon::from_bits(val)
            }
        }
        impl From<Elcon> for u8 {
            #[inline(always)]
            fn from(val: Elcon) -> u8 {
                Elcon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Seg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Seg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Seg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Seg {
            #[inline(always)]
            fn from(val: u8) -> Seg {
                Seg::from_bits(val)
            }
        }
        impl From<Seg> for u8 {
            #[inline(always)]
            fn from(val: Seg) -> u8 {
                Seg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum We {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl We {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> We {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for We {
            #[inline(always)]
            fn from(val: u8) -> We {
                We::from_bits(val)
            }
        }
        impl From<We> for u8 {
            #[inline(always)]
            fn from(val: We) -> u8 {
                We::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wi {
            #[inline(always)]
            fn from(val: u8) -> Wi {
                Wi::from_bits(val)
            }
        }
        impl From<Wi> for u8 {
            #[inline(always)]
            fn from(val: Wi) -> u8 {
                Wi::to_bits(val)
            }
        }
    }
}
pub mod flcn {
    #[doc = "Flash I/O Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Flcn {
        ptr: *mut u8,
    }
    unsafe impl Send for Flcn {}
    unsafe impl Sync for Flcn {}
    impl Flcn {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data Flash Control Register"]
        #[inline(always)]
        pub const fn dflctl(self) -> crate::common::Reg<regs::Dflctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Flash P/E Mode Control Register"]
        #[inline(always)]
        pub const fn fpmcr(self) -> crate::common::Reg<regs::Fpmcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Flash Area Select Register"]
        #[inline(always)]
        pub const fn fasr(self) -> crate::common::Reg<regs::Fasr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Flash Processing Start Address Register L"]
        #[inline(always)]
        pub const fn fsarl(self) -> crate::common::Reg<regs::Fsarl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Flash Processing Start Address Register H"]
        #[inline(always)]
        pub const fn fsarh(self) -> crate::common::Reg<regs::Fsarh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Flash Control Register"]
        #[inline(always)]
        pub const fn fcr(self) -> crate::common::Reg<regs::Fcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Flash Processing End Address Register L"]
        #[inline(always)]
        pub const fn fearl(self) -> crate::common::Reg<regs::Fearl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Flash Processing End Address Register H"]
        #[inline(always)]
        pub const fn fearh(self) -> crate::common::Reg<regs::Fearh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Flash Reset Register"]
        #[inline(always)]
        pub const fn fresetr(self) -> crate::common::Reg<regs::Fresetr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Flash Status Register 1"]
        #[inline(always)]
        pub const fn fstatr1(self) -> crate::common::Reg<regs::Fstatr1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "Flash Write Buffer Register L0"]
        #[inline(always)]
        pub const fn fwbl0(self) -> crate::common::Reg<regs::Fwbl0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Flash Write Buffer Register H0"]
        #[inline(always)]
        pub const fn fwbh0(self) -> crate::common::Reg<regs::Fwbh0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Protection Unlock Register"]
        #[inline(always)]
        pub const fn fpr(self) -> crate::common::Reg<regs::Fpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Protection Unlock Status Register"]
        #[inline(always)]
        pub const fn fpsr(self) -> crate::common::Reg<regs::Fpsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Flash Read Buffer Register L0"]
        #[inline(always)]
        pub const fn frbl0(self) -> crate::common::Reg<regs::Frbl0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Flash Read Buffer Register H0"]
        #[inline(always)]
        pub const fn frbh0(self) -> crate::common::Reg<regs::Frbh0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Flash Start,Up Setting Monitor Register"]
        #[inline(always)]
        pub const fn fscmr(self) -> crate::common::Reg<regs::Fscmr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "Flash Access Window Start Address Monitor Register"]
        #[inline(always)]
        pub const fn fawsmr(self) -> crate::common::Reg<regs::Fawsmr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c8usize) as _) }
        }
        #[doc = "Flash Access Window End Address Monitor Register"]
        #[inline(always)]
        pub const fn fawemr(self) -> crate::common::Reg<regs::Fawemr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d0usize) as _) }
        }
        #[doc = "Flash Initial Setting Register"]
        #[inline(always)]
        pub const fn fisr(self) -> crate::common::Reg<regs::Fisr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d8usize) as _) }
        }
        #[doc = "Flash Extra Area Control Register"]
        #[inline(always)]
        pub const fn fexcr(self) -> crate::common::Reg<regs::Fexcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01dcusize) as _) }
        }
        #[doc = "Flash Error Address Monitor Register L"]
        #[inline(always)]
        pub const fn feaml(self) -> crate::common::Reg<regs::Feaml, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e0usize) as _) }
        }
        #[doc = "Flash Error Address Monitor Register H"]
        #[inline(always)]
        pub const fn feamh(self) -> crate::common::Reg<regs::Feamh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e8usize) as _) }
        }
        #[doc = "Flash Status Register 2"]
        #[inline(always)]
        pub const fn fstatr2(self) -> crate::common::Reg<regs::Fstatr2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01f0usize) as _) }
        }
        #[doc = "Temperature Sensor Calibration Data Register"]
        #[inline(always)]
        pub const fn tscdr(self) -> crate::common::Reg<regs::Tscdr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0228usize) as _) }
        }
        #[doc = "Flash P/E Mode Entry Register"]
        #[inline(always)]
        pub const fn fentryr(self) -> crate::common::Reg<regs::Fentryr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3fb0usize) as _) }
        }
        #[doc = "Memory Wait Cycle Control Register for Data Flash"]
        #[inline(always)]
        pub const fn fldwaitr(self) -> crate::common::Reg<regs::Fldwaitr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3fc4usize) as _) }
        }
        #[doc = "Prefetch Buffer Enable Register"]
        #[inline(always)]
        pub const fn pfber(self) -> crate::common::Reg<regs::Pfber, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3fc8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Data Flash Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dflctl(pub u8);
        impl Dflctl {
            #[doc = "Data Flash Access Enable"]
            #[inline(always)]
            pub const fn dflen(&self) -> super::vals::Dflen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dflen::from_bits(val as u8)
            }
            #[doc = "Data Flash Access Enable"]
            #[inline(always)]
            pub fn set_dflen(&mut self, val: super::vals::Dflen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Dflctl {
            #[inline(always)]
            fn default() -> Dflctl {
                Dflctl(0)
            }
        }
        impl core::fmt::Debug for Dflctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dflctl")
                    .field("dflen", &self.dflen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dflctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dflctl {{ dflen: {:?} }}", self.dflen())
            }
        }
        #[doc = "Flash Area Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fasr(pub u8);
        impl Fasr {
            #[doc = "Extra Area Select"]
            #[inline(always)]
            pub const fn exs(&self) -> super::vals::Exs {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Exs::from_bits(val as u8)
            }
            #[doc = "Extra Area Select"]
            #[inline(always)]
            pub fn set_exs(&mut self, val: super::vals::Exs) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fasr {
            #[inline(always)]
            fn default() -> Fasr {
                Fasr(0)
            }
        }
        impl core::fmt::Debug for Fasr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fasr").field("exs", &self.exs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fasr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fasr {{ exs: {:?} }}", self.exs())
            }
        }
        #[doc = "Flash Access Window End Address Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fawemr(pub u16);
        impl Fawemr {
            #[doc = "Access Window End Address"]
            #[inline(always)]
            pub const fn fawe(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Access Window End Address"]
            #[inline(always)]
            pub fn set_fawe(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u16) & 0x07ff) << 0usize);
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub const fn sasmf(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub fn set_sasmf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Fawemr {
            #[inline(always)]
            fn default() -> Fawemr {
                Fawemr(0)
            }
        }
        impl core::fmt::Debug for Fawemr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fawemr")
                    .field("fawe", &self.fawe())
                    .field("sasmf", &self.sasmf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fawemr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fawemr {{ fawe: {=u16:?}, sasmf: {=bool:?} }}",
                    self.fawe(),
                    self.sasmf()
                )
            }
        }
        #[doc = "Flash Access Window Start Address Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fawsmr(pub u16);
        impl Fawsmr {
            #[doc = "Access Window Start Address"]
            #[inline(always)]
            pub const fn faws(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Access Window Start Address"]
            #[inline(always)]
            pub fn set_faws(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u16) & 0x07ff) << 0usize);
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub const fn fspr(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub fn set_fspr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Fawsmr {
            #[inline(always)]
            fn default() -> Fawsmr {
                Fawsmr(0)
            }
        }
        impl core::fmt::Debug for Fawsmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fawsmr")
                    .field("faws", &self.faws())
                    .field("fspr", &self.fspr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fawsmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fawsmr {{ faws: {=u16:?}, fspr: {=bool:?} }}",
                    self.faws(),
                    self.fspr()
                )
            }
        }
        #[doc = "Flash Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fcr(pub u8);
        impl Fcr {
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub const fn cmd(&self) -> super::vals::FcrCmd {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::FcrCmd::from_bits(val as u8)
            }
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub fn set_cmd(&mut self, val: super::vals::FcrCmd) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u8) & 0x0f) << 0usize);
            }
            #[doc = "Data Read Completion"]
            #[inline(always)]
            pub const fn drc(&self) -> super::vals::Drc {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Drc::from_bits(val as u8)
            }
            #[doc = "Data Read Completion"]
            #[inline(always)]
            pub fn set_drc(&mut self, val: super::vals::Drc) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Forced Processing Stop"]
            #[inline(always)]
            pub const fn stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Forced Processing Stop"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u8) & 0x01) << 6usize);
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub const fn opst(&self) -> super::vals::FcrOpst {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::FcrOpst::from_bits(val as u8)
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub fn set_opst(&mut self, val: super::vals::FcrOpst) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fcr {
            #[inline(always)]
            fn default() -> Fcr {
                Fcr(0)
            }
        }
        impl core::fmt::Debug for Fcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fcr")
                    .field("cmd", &self.cmd())
                    .field("drc", &self.drc())
                    .field("stop", &self.stop())
                    .field("opst", &self.opst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fcr {{ cmd: {:?}, drc: {:?}, stop: {=bool:?}, opst: {:?} }}",
                    self.cmd(),
                    self.drc(),
                    self.stop(),
                    self.opst()
                )
            }
        }
        #[doc = "Flash Error Address Monitor Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feamh(pub u16);
        impl Feamh {
            #[doc = "Flash Error Address Monitor Register H"]
            #[inline(always)]
            pub const fn feamh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Error Address Monitor Register H"]
            #[inline(always)]
            pub fn set_feamh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Feamh {
            #[inline(always)]
            fn default() -> Feamh {
                Feamh(0)
            }
        }
        impl core::fmt::Debug for Feamh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feamh")
                    .field("feamh", &self.feamh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feamh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Feamh {{ feamh: {=u16:?} }}", self.feamh())
            }
        }
        #[doc = "Flash Error Address Monitor Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feaml(pub u16);
        impl Feaml {
            #[doc = "Flash Error Address Monitor Register L"]
            #[inline(always)]
            pub const fn feaml(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Error Address Monitor Register L"]
            #[inline(always)]
            pub fn set_feaml(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Feaml {
            #[inline(always)]
            fn default() -> Feaml {
                Feaml(0)
            }
        }
        impl core::fmt::Debug for Feaml {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feaml")
                    .field("feaml", &self.feaml())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feaml {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Feaml {{ feaml: {=u16:?} }}", self.feaml())
            }
        }
        #[doc = "Flash Processing End Address Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fearh(pub u16);
        impl Fearh {
            #[doc = "Flash Processing End Address H"]
            #[inline(always)]
            pub const fn fearh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing End Address H"]
            #[inline(always)]
            pub fn set_fearh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fearh {
            #[inline(always)]
            fn default() -> Fearh {
                Fearh(0)
            }
        }
        impl core::fmt::Debug for Fearh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fearh")
                    .field("fearh", &self.fearh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fearh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fearh {{ fearh: {=u16:?} }}", self.fearh())
            }
        }
        #[doc = "Flash Processing End Address Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fearl(pub u16);
        impl Fearl {
            #[doc = "Flash Processing End Address L"]
            #[inline(always)]
            pub const fn fearl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing End Address L"]
            #[inline(always)]
            pub fn set_fearl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fearl {
            #[inline(always)]
            fn default() -> Fearl {
                Fearl(0)
            }
        }
        impl core::fmt::Debug for Fearl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fearl")
                    .field("fearl", &self.fearl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fearl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fearl {{ fearl: {=u16:?} }}", self.fearl())
            }
        }
        #[doc = "Flash P/E Mode Entry Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fentryr(pub u16);
        impl Fentryr {
            #[doc = "Code Flash P/E Mode Entry 0"]
            #[inline(always)]
            pub const fn fentry0(&self) -> super::vals::Fentry0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fentry0::from_bits(val as u8)
            }
            #[doc = "Code Flash P/E Mode Entry 0"]
            #[inline(always)]
            pub fn set_fentry0(&mut self, val: super::vals::Fentry0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Data Flash P/E Mode Entry"]
            #[inline(always)]
            pub const fn fentryd(&self) -> super::vals::Fentryd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Fentryd::from_bits(val as u8)
            }
            #[doc = "Data Flash P/E Mode Entry"]
            #[inline(always)]
            pub fn set_fentryd(&mut self, val: super::vals::Fentryd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn fekey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_fekey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Fentryr {
            #[inline(always)]
            fn default() -> Fentryr {
                Fentryr(0)
            }
        }
        impl core::fmt::Debug for Fentryr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fentryr")
                    .field("fentry0", &self.fentry0())
                    .field("fentryd", &self.fentryd())
                    .field("fekey", &self.fekey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fentryr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fentryr {{ fentry0: {:?}, fentryd: {:?}, fekey: {=u8:?} }}",
                    self.fentry0(),
                    self.fentryd(),
                    self.fekey()
                )
            }
        }
        #[doc = "Flash Extra Area Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fexcr(pub u8);
        impl Fexcr {
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub const fn cmd(&self) -> super::vals::FexcrCmd {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::FexcrCmd::from_bits(val as u8)
            }
            #[doc = "Software Command Setting"]
            #[inline(always)]
            pub fn set_cmd(&mut self, val: super::vals::FexcrCmd) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub const fn opst(&self) -> super::vals::FexcrOpst {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::FexcrOpst::from_bits(val as u8)
            }
            #[doc = "Processing Start"]
            #[inline(always)]
            pub fn set_opst(&mut self, val: super::vals::FexcrOpst) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fexcr {
            #[inline(always)]
            fn default() -> Fexcr {
                Fexcr(0)
            }
        }
        impl core::fmt::Debug for Fexcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fexcr")
                    .field("cmd", &self.cmd())
                    .field("opst", &self.opst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fexcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fexcr {{ cmd: {:?}, opst: {:?} }}",
                    self.cmd(),
                    self.opst()
                )
            }
        }
        #[doc = "Flash Initial Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fisr(pub u8);
        impl Fisr {
            #[doc = "Flash,IF Clock Notification"]
            #[inline(always)]
            pub const fn pcka(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Flash,IF Clock Notification"]
            #[inline(always)]
            pub fn set_pcka(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u8) & 0x3f) << 0usize);
            }
            #[doc = "Startup Area Select"]
            #[inline(always)]
            pub const fn sas(&self) -> super::vals::Sas {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Sas::from_bits(val as u8)
            }
            #[doc = "Startup Area Select"]
            #[inline(always)]
            pub fn set_sas(&mut self, val: super::vals::Sas) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Fisr {
            #[inline(always)]
            fn default() -> Fisr {
                Fisr(0)
            }
        }
        impl core::fmt::Debug for Fisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fisr")
                    .field("pcka", &self.pcka())
                    .field("sas", &self.sas())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fisr {{ pcka: {=u8:?}, sas: {:?} }}",
                    self.pcka(),
                    self.sas()
                )
            }
        }
        #[doc = "Memory Wait Cycle Control Register for Data Flash"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fldwaitr(pub u8);
        impl Fldwaitr {
            #[doc = "Memory Wait Cycle Select for Data Flash"]
            #[inline(always)]
            pub const fn fldwait1(&self) -> super::vals::Fldwait1 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Fldwait1::from_bits(val as u8)
            }
            #[doc = "Memory Wait Cycle Select for Data Flash"]
            #[inline(always)]
            pub fn set_fldwait1(&mut self, val: super::vals::Fldwait1) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fldwaitr {
            #[inline(always)]
            fn default() -> Fldwaitr {
                Fldwaitr(0)
            }
        }
        impl core::fmt::Debug for Fldwaitr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fldwaitr")
                    .field("fldwait1", &self.fldwait1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fldwaitr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fldwaitr {{ fldwait1: {:?} }}", self.fldwait1())
            }
        }
        #[doc = "Flash P/E Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpmcr(pub u8);
        impl Fpmcr {
            #[doc = "Flash Operating Mode Select 0"]
            #[inline(always)]
            pub const fn fms0(&self) -> super::vals::Fms0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Fms0::from_bits(val as u8)
            }
            #[doc = "Flash Operating Mode Select 0"]
            #[inline(always)]
            pub fn set_fms0(&mut self, val: super::vals::Fms0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Code Flash P/E Disable"]
            #[inline(always)]
            pub const fn rpdis(&self) -> super::vals::Rpdis {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rpdis::from_bits(val as u8)
            }
            #[doc = "Code Flash P/E Disable"]
            #[inline(always)]
            pub fn set_rpdis(&mut self, val: super::vals::Rpdis) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Flash Operating Mode Select 1"]
            #[inline(always)]
            pub const fn fms1(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Flash Operating Mode Select 1"]
            #[inline(always)]
            pub fn set_fms1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Fpmcr {
            #[inline(always)]
            fn default() -> Fpmcr {
                Fpmcr(0)
            }
        }
        impl core::fmt::Debug for Fpmcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpmcr")
                    .field("fms0", &self.fms0())
                    .field("rpdis", &self.rpdis())
                    .field("fms1", &self.fms1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpmcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fpmcr {{ fms0: {:?}, rpdis: {:?}, fms1: {=bool:?} }}",
                    self.fms0(),
                    self.rpdis(),
                    self.fms1()
                )
            }
        }
        #[doc = "Protection Unlock Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpr(pub u8);
        impl Fpr {
            #[doc = "Protection Unlock"]
            #[inline(always)]
            pub const fn fpr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Protection Unlock"]
            #[inline(always)]
            pub fn set_fpr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Fpr {
            #[inline(always)]
            fn default() -> Fpr {
                Fpr(0)
            }
        }
        impl core::fmt::Debug for Fpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpr").field("fpr", &self.fpr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fpr {{ fpr: {=u8:?} }}", self.fpr())
            }
        }
        #[doc = "Protection Unlock Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fpsr(pub u8);
        impl Fpsr {
            #[doc = "Protect Error Flag"]
            #[inline(always)]
            pub const fn perr(&self) -> super::vals::Perr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Perr::from_bits(val as u8)
            }
            #[doc = "Protect Error Flag"]
            #[inline(always)]
            pub fn set_perr(&mut self, val: super::vals::Perr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fpsr {
            #[inline(always)]
            fn default() -> Fpsr {
                Fpsr(0)
            }
        }
        impl core::fmt::Debug for Fpsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fpsr").field("perr", &self.perr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fpsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fpsr {{ perr: {:?} }}", self.perr())
            }
        }
        #[doc = "Flash Read Buffer Register H0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frbh0(pub u16);
        impl Frbh0 {
            #[doc = "Flash Read Buffer H0"]
            #[inline(always)]
            pub const fn rdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Read Buffer H0"]
            #[inline(always)]
            pub fn set_rdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Frbh0 {
            #[inline(always)]
            fn default() -> Frbh0 {
                Frbh0(0)
            }
        }
        impl core::fmt::Debug for Frbh0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frbh0")
                    .field("rdata", &self.rdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frbh0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frbh0 {{ rdata: {=u16:?} }}", self.rdata())
            }
        }
        #[doc = "Flash Read Buffer Register L0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frbl0(pub u16);
        impl Frbl0 {
            #[doc = "Flash Read Buffer L0"]
            #[inline(always)]
            pub const fn rdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Read Buffer L0"]
            #[inline(always)]
            pub fn set_rdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Frbl0 {
            #[inline(always)]
            fn default() -> Frbl0 {
                Frbl0(0)
            }
        }
        impl core::fmt::Debug for Frbl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frbl0")
                    .field("rdata", &self.rdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frbl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frbl0 {{ rdata: {=u16:?} }}", self.rdata())
            }
        }
        #[doc = "Flash Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fresetr(pub u8);
        impl Fresetr {
            #[doc = "Software reset of the registers"]
            #[inline(always)]
            pub const fn freset(&self) -> super::vals::Freset {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Freset::from_bits(val as u8)
            }
            #[doc = "Software reset of the registers"]
            #[inline(always)]
            pub fn set_freset(&mut self, val: super::vals::Freset) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Fresetr {
            #[inline(always)]
            fn default() -> Fresetr {
                Fresetr(0)
            }
        }
        impl core::fmt::Debug for Fresetr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fresetr")
                    .field("freset", &self.freset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fresetr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fresetr {{ freset: {:?} }}", self.freset())
            }
        }
        #[doc = "Flash Processing Start Address Register H"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fsarh(pub u16);
        impl Fsarh {
            #[doc = "Flash Processing Start Address H"]
            #[inline(always)]
            pub const fn fsarh(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing Start Address H"]
            #[inline(always)]
            pub fn set_fsarh(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fsarh {
            #[inline(always)]
            fn default() -> Fsarh {
                Fsarh(0)
            }
        }
        impl core::fmt::Debug for Fsarh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fsarh")
                    .field("fsarh", &self.fsarh())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fsarh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fsarh {{ fsarh: {=u16:?} }}", self.fsarh())
            }
        }
        #[doc = "Flash Processing Start Address Register L"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fsarl(pub u16);
        impl Fsarl {
            #[doc = "Flash Processing Start Address L"]
            #[inline(always)]
            pub const fn fsarl(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Processing Start Address L"]
            #[inline(always)]
            pub fn set_fsarl(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fsarl {
            #[inline(always)]
            fn default() -> Fsarl {
                Fsarl(0)
            }
        }
        impl core::fmt::Debug for Fsarl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fsarl")
                    .field("fsarl", &self.fsarl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fsarl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fsarl {{ fsarl: {=u16:?} }}", self.fsarl())
            }
        }
        #[doc = "Flash Start,Up Setting Monitor Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fscmr(pub u16);
        impl Fscmr {
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub const fn sasmf(&self) -> super::vals::Sasmf {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sasmf::from_bits(val as u8)
            }
            #[doc = "Startup Area Setting Monitor Flag"]
            #[inline(always)]
            pub fn set_sasmf(&mut self, val: super::vals::Sasmf) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub const fn fspr(&self) -> super::vals::Fspr {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Fspr::from_bits(val as u8)
            }
            #[doc = "Access Window Protection Flag"]
            #[inline(always)]
            pub fn set_fspr(&mut self, val: super::vals::Fspr) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
        }
        impl Default for Fscmr {
            #[inline(always)]
            fn default() -> Fscmr {
                Fscmr(0)
            }
        }
        impl core::fmt::Debug for Fscmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fscmr")
                    .field("sasmf", &self.sasmf())
                    .field("fspr", &self.fspr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fscmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fscmr {{ sasmf: {:?}, fspr: {:?} }}",
                    self.sasmf(),
                    self.fspr()
                )
            }
        }
        #[doc = "Flash Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fstatr1(pub u8);
        impl Fstatr1 {
            #[doc = "Data Read Ready Flag"]
            #[inline(always)]
            pub const fn drrdy(&self) -> super::vals::Drrdy {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Drrdy::from_bits(val as u8)
            }
            #[doc = "Data Read Ready Flag"]
            #[inline(always)]
            pub fn set_drrdy(&mut self, val: super::vals::Drrdy) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Flash Ready Flag"]
            #[inline(always)]
            pub const fn frdy(&self) -> super::vals::Frdy {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Frdy::from_bits(val as u8)
            }
            #[doc = "Flash Ready Flag"]
            #[inline(always)]
            pub fn set_frdy(&mut self, val: super::vals::Frdy) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Extra Area Ready Flag"]
            #[inline(always)]
            pub const fn exrdy(&self) -> super::vals::Exrdy {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Exrdy::from_bits(val as u8)
            }
            #[doc = "Extra Area Ready Flag"]
            #[inline(always)]
            pub fn set_exrdy(&mut self, val: super::vals::Exrdy) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Fstatr1 {
            #[inline(always)]
            fn default() -> Fstatr1 {
                Fstatr1(0)
            }
        }
        impl core::fmt::Debug for Fstatr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fstatr1")
                    .field("drrdy", &self.drrdy())
                    .field("frdy", &self.frdy())
                    .field("exrdy", &self.exrdy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fstatr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fstatr1 {{ drrdy: {:?}, frdy: {:?}, exrdy: {:?} }}",
                    self.drrdy(),
                    self.frdy(),
                    self.exrdy()
                )
            }
        }
        #[doc = "Flash Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fstatr2(pub u16);
        impl Fstatr2 {
            #[doc = "Erase Error Flag"]
            #[inline(always)]
            pub const fn ererr(&self) -> super::vals::Ererr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ererr::from_bits(val as u8)
            }
            #[doc = "Erase Error Flag"]
            #[inline(always)]
            pub fn set_ererr(&mut self, val: super::vals::Ererr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Program Error Flag"]
            #[inline(always)]
            pub const fn prgerr(&self) -> super::vals::Prgerr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Prgerr::from_bits(val as u8)
            }
            #[doc = "Program Error Flag"]
            #[inline(always)]
            pub fn set_prgerr(&mut self, val: super::vals::Prgerr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Program Error Flag 01"]
            #[inline(always)]
            pub const fn prgerr01(&self) -> super::vals::Prgerr01 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Prgerr01::from_bits(val as u8)
            }
            #[doc = "Program Error Flag 01"]
            #[inline(always)]
            pub fn set_prgerr01(&mut self, val: super::vals::Prgerr01) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Blank Check Error Flag"]
            #[inline(always)]
            pub const fn bcerr(&self) -> super::vals::Bcerr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bcerr::from_bits(val as u8)
            }
            #[doc = "Blank Check Error Flag"]
            #[inline(always)]
            pub fn set_bcerr(&mut self, val: super::vals::Bcerr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Illegal Command Error Flag"]
            #[inline(always)]
            pub const fn ilglerr(&self) -> super::vals::Ilglerr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ilglerr::from_bits(val as u8)
            }
            #[doc = "Illegal Command Error Flag"]
            #[inline(always)]
            pub fn set_ilglerr(&mut self, val: super::vals::Ilglerr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Extra Area Illegal Command Error Flag"]
            #[inline(always)]
            pub const fn eilglerr(&self) -> super::vals::Eilglerr {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Eilglerr::from_bits(val as u8)
            }
            #[doc = "Extra Area Illegal Command Error Flag"]
            #[inline(always)]
            pub fn set_eilglerr(&mut self, val: super::vals::Eilglerr) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
        }
        impl Default for Fstatr2 {
            #[inline(always)]
            fn default() -> Fstatr2 {
                Fstatr2(0)
            }
        }
        impl core::fmt::Debug for Fstatr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fstatr2")
                    .field("ererr", &self.ererr())
                    .field("prgerr", &self.prgerr())
                    .field("prgerr01", &self.prgerr01())
                    .field("bcerr", &self.bcerr())
                    .field("ilglerr", &self.ilglerr())
                    .field("eilglerr", &self.eilglerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fstatr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fstatr2 {{ ererr: {:?}, prgerr: {:?}, prgerr01: {:?}, bcerr: {:?}, ilglerr: {:?}, eilglerr: {:?} }}" , self . ererr () , self . prgerr () , self . prgerr01 () , self . bcerr () , self . ilglerr () , self . eilglerr ())
            }
        }
        #[doc = "Flash Write Buffer Register H0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fwbh0(pub u16);
        impl Fwbh0 {
            #[doc = "Flash Write Buffer H0"]
            #[inline(always)]
            pub const fn wdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Write Buffer H0"]
            #[inline(always)]
            pub fn set_wdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fwbh0 {
            #[inline(always)]
            fn default() -> Fwbh0 {
                Fwbh0(0)
            }
        }
        impl core::fmt::Debug for Fwbh0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fwbh0")
                    .field("wdata", &self.wdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fwbh0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fwbh0 {{ wdata: {=u16:?} }}", self.wdata())
            }
        }
        #[doc = "Flash Write Buffer Register L0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fwbl0(pub u16);
        impl Fwbl0 {
            #[doc = "Flash Write Buffer L0"]
            #[inline(always)]
            pub const fn wdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Flash Write Buffer L0"]
            #[inline(always)]
            pub fn set_wdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Fwbl0 {
            #[inline(always)]
            fn default() -> Fwbl0 {
                Fwbl0(0)
            }
        }
        impl core::fmt::Debug for Fwbl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fwbl0")
                    .field("wdata", &self.wdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fwbl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fwbl0 {{ wdata: {=u16:?} }}", self.wdata())
            }
        }
        #[doc = "Prefetch Buffer Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pfber(pub u8);
        impl Pfber {
            #[doc = "Prefetch Buffer Enable bit"]
            #[inline(always)]
            pub const fn pfbe(&self) -> super::vals::Pfbe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pfbe::from_bits(val as u8)
            }
            #[doc = "Prefetch Buffer Enable bit"]
            #[inline(always)]
            pub fn set_pfbe(&mut self, val: super::vals::Pfbe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Pfber {
            #[inline(always)]
            fn default() -> Pfber {
                Pfber(0)
            }
        }
        impl core::fmt::Debug for Pfber {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pfber").field("pfbe", &self.pfbe()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pfber {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pfber {{ pfbe: {:?} }}", self.pfbe())
            }
        }
        #[doc = "Temperature Sensor Calibration Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tscdr(pub u16);
        impl Tscdr {
            #[doc = "Temperature Sensor Calibration Data"]
            #[inline(always)]
            pub const fn tscdr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Temperature Sensor Calibration Data"]
            #[inline(always)]
            pub fn set_tscdr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize);
            }
        }
        impl Default for Tscdr {
            #[inline(always)]
            fn default() -> Tscdr {
                Tscdr(0)
            }
        }
        impl core::fmt::Debug for Tscdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tscdr")
                    .field("tscdr", &self.tscdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tscdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tscdr {{ tscdr: {=u16:?} }}", self.tscdr())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bcerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bcerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bcerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bcerr {
            #[inline(always)]
            fn from(val: u8) -> Bcerr {
                Bcerr::from_bits(val)
            }
        }
        impl From<Bcerr> for u8 {
            #[inline(always)]
            fn from(val: Bcerr) -> u8 {
                Bcerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dflen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dflen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dflen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dflen {
            #[inline(always)]
            fn from(val: u8) -> Dflen {
                Dflen::from_bits(val)
            }
        }
        impl From<Dflen> for u8 {
            #[inline(always)]
            fn from(val: Dflen) -> u8 {
                Dflen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Drc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Drc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Drc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Drc {
            #[inline(always)]
            fn from(val: u8) -> Drc {
                Drc::from_bits(val)
            }
        }
        impl From<Drc> for u8 {
            #[inline(always)]
            fn from(val: Drc) -> u8 {
                Drc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Drrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Drrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Drrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Drrdy {
            #[inline(always)]
            fn from(val: u8) -> Drrdy {
                Drrdy::from_bits(val)
            }
        }
        impl From<Drrdy> for u8 {
            #[inline(always)]
            fn from(val: Drrdy) -> u8 {
                Drrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eilglerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Eilglerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eilglerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eilglerr {
            #[inline(always)]
            fn from(val: u8) -> Eilglerr {
                Eilglerr::from_bits(val)
            }
        }
        impl From<Eilglerr> for u8 {
            #[inline(always)]
            fn from(val: Eilglerr) -> u8 {
                Eilglerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ererr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ererr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ererr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ererr {
            #[inline(always)]
            fn from(val: u8) -> Ererr {
                Ererr::from_bits(val)
            }
        }
        impl From<Ererr> for u8 {
            #[inline(always)]
            fn from(val: Ererr) -> u8 {
                Ererr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exrdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Exrdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exrdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exrdy {
            #[inline(always)]
            fn from(val: u8) -> Exrdy {
                Exrdy::from_bits(val)
            }
        }
        impl From<Exrdy> for u8 {
            #[inline(always)]
            fn from(val: Exrdy) -> u8 {
                Exrdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Exs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exs {
            #[inline(always)]
            fn from(val: u8) -> Exs {
                Exs::from_bits(val)
            }
        }
        impl From<Exs> for u8 {
            #[inline(always)]
            fn from(val: Exs) -> u8 {
                Exs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FcrCmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl FcrCmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FcrCmd {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FcrCmd {
            #[inline(always)]
            fn from(val: u8) -> FcrCmd {
                FcrCmd::from_bits(val)
            }
        }
        impl From<FcrCmd> for u8 {
            #[inline(always)]
            fn from(val: FcrCmd) -> u8 {
                FcrCmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FcrOpst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FcrOpst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FcrOpst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FcrOpst {
            #[inline(always)]
            fn from(val: u8) -> FcrOpst {
                FcrOpst::from_bits(val)
            }
        }
        impl From<FcrOpst> for u8 {
            #[inline(always)]
            fn from(val: FcrOpst) -> u8 {
                FcrOpst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fentry0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fentry0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fentry0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fentry0 {
            #[inline(always)]
            fn from(val: u8) -> Fentry0 {
                Fentry0::from_bits(val)
            }
        }
        impl From<Fentry0> for u8 {
            #[inline(always)]
            fn from(val: Fentry0) -> u8 {
                Fentry0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fentryd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fentryd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fentryd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fentryd {
            #[inline(always)]
            fn from(val: u8) -> Fentryd {
                Fentryd::from_bits(val)
            }
        }
        impl From<Fentryd> for u8 {
            #[inline(always)]
            fn from(val: Fentryd) -> u8 {
                Fentryd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FexcrCmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl FexcrCmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FexcrCmd {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FexcrCmd {
            #[inline(always)]
            fn from(val: u8) -> FexcrCmd {
                FexcrCmd::from_bits(val)
            }
        }
        impl From<FexcrCmd> for u8 {
            #[inline(always)]
            fn from(val: FexcrCmd) -> u8 {
                FexcrCmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FexcrOpst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl FexcrOpst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FexcrOpst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FexcrOpst {
            #[inline(always)]
            fn from(val: u8) -> FexcrOpst {
                FexcrOpst::from_bits(val)
            }
        }
        impl From<FexcrOpst> for u8 {
            #[inline(always)]
            fn from(val: FexcrOpst) -> u8 {
                FexcrOpst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fldwait1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fldwait1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fldwait1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fldwait1 {
            #[inline(always)]
            fn from(val: u8) -> Fldwait1 {
                Fldwait1::from_bits(val)
            }
        }
        impl From<Fldwait1> for u8 {
            #[inline(always)]
            fn from(val: Fldwait1) -> u8 {
                Fldwait1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fms0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fms0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fms0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fms0 {
            #[inline(always)]
            fn from(val: u8) -> Fms0 {
                Fms0::from_bits(val)
            }
        }
        impl From<Fms0> for u8 {
            #[inline(always)]
            fn from(val: Fms0) -> u8 {
                Fms0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Frdy {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Frdy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Frdy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Frdy {
            #[inline(always)]
            fn from(val: u8) -> Frdy {
                Frdy::from_bits(val)
            }
        }
        impl From<Frdy> for u8 {
            #[inline(always)]
            fn from(val: Frdy) -> u8 {
                Frdy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Freset {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Freset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Freset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Freset {
            #[inline(always)]
            fn from(val: u8) -> Freset {
                Freset::from_bits(val)
            }
        }
        impl From<Freset> for u8 {
            #[inline(always)]
            fn from(val: Freset) -> u8 {
                Freset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fspr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fspr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fspr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fspr {
            #[inline(always)]
            fn from(val: u8) -> Fspr {
                Fspr::from_bits(val)
            }
        }
        impl From<Fspr> for u8 {
            #[inline(always)]
            fn from(val: Fspr) -> u8 {
                Fspr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ilglerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ilglerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ilglerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ilglerr {
            #[inline(always)]
            fn from(val: u8) -> Ilglerr {
                Ilglerr::from_bits(val)
            }
        }
        impl From<Ilglerr> for u8 {
            #[inline(always)]
            fn from(val: Ilglerr) -> u8 {
                Ilglerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Perr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Perr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Perr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Perr {
            #[inline(always)]
            fn from(val: u8) -> Perr {
                Perr::from_bits(val)
            }
        }
        impl From<Perr> for u8 {
            #[inline(always)]
            fn from(val: Perr) -> u8 {
                Perr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pfbe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pfbe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pfbe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pfbe {
            #[inline(always)]
            fn from(val: u8) -> Pfbe {
                Pfbe::from_bits(val)
            }
        }
        impl From<Pfbe> for u8 {
            #[inline(always)]
            fn from(val: Pfbe) -> u8 {
                Pfbe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prgerr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prgerr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prgerr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prgerr {
            #[inline(always)]
            fn from(val: u8) -> Prgerr {
                Prgerr::from_bits(val)
            }
        }
        impl From<Prgerr> for u8 {
            #[inline(always)]
            fn from(val: Prgerr) -> u8 {
                Prgerr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prgerr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prgerr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prgerr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prgerr01 {
            #[inline(always)]
            fn from(val: u8) -> Prgerr01 {
                Prgerr01::from_bits(val)
            }
        }
        impl From<Prgerr01> for u8 {
            #[inline(always)]
            fn from(val: Prgerr01) -> u8 {
                Prgerr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpdis {
            #[inline(always)]
            fn from(val: u8) -> Rpdis {
                Rpdis::from_bits(val)
            }
        }
        impl From<Rpdis> for u8 {
            #[inline(always)]
            fn from(val: Rpdis) -> u8 {
                Rpdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sas {
            #[inline(always)]
            fn from(val: u8) -> Sas {
                Sas::from_bits(val)
            }
        }
        impl From<Sas> for u8 {
            #[inline(always)]
            fn from(val: Sas) -> u8 {
                Sas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sasmf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sasmf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sasmf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sasmf {
            #[inline(always)]
            fn from(val: u8) -> Sasmf {
                Sasmf::from_bits(val)
            }
        }
        impl From<Sasmf> for u8 {
            #[inline(always)]
            fn from(val: Sasmf) -> u8 {
                Sasmf::to_bits(val)
            }
        }
    }
}
pub mod gpt164 {
    #[doc = "General PWM 16-bit Timer 4"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpt164 {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpt164 {}
    unsafe impl Sync for Gpt164 {}
    impl Gpt164 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "General PWM Timer Write,Protection Register"]
        #[inline(always)]
        pub const fn gtwp(self) -> crate::common::Reg<regs::Gtwp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "General PWM Timer Software Start Register"]
        #[inline(always)]
        pub const fn gtstr(self) -> crate::common::Reg<regs::Gtstr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "General PWM Timer Software Stop Register"]
        #[inline(always)]
        pub const fn gtstp(self) -> crate::common::Reg<regs::Gtstp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "General PWM Timer Software Clear Register"]
        #[inline(always)]
        pub const fn gtclr(self) -> crate::common::Reg<regs::Gtclr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "General PWM Timer Start Source Select Register"]
        #[inline(always)]
        pub const fn gtssr(self) -> crate::common::Reg<regs::Gtssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "General PWM Timer Stop Source Select Register"]
        #[inline(always)]
        pub const fn gtpsr(self) -> crate::common::Reg<regs::Gtpsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "General PWM Timer Clear Source Select Register"]
        #[inline(always)]
        pub const fn gtcsr(self) -> crate::common::Reg<regs::Gtcsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "General PWM Timer Up Count Source Select Register"]
        #[inline(always)]
        pub const fn gtupsr(self) -> crate::common::Reg<regs::Gtupsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "General PWM Timer Down Count Source Select Register"]
        #[inline(always)]
        pub const fn gtdnsr(self) -> crate::common::Reg<regs::Gtdnsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register A"]
        #[inline(always)]
        pub const fn gticasr(self) -> crate::common::Reg<regs::Gticasr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register B"]
        #[inline(always)]
        pub const fn gticbsr(self) -> crate::common::Reg<regs::Gticbsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "General PWM Timer Control Register"]
        #[inline(always)]
        pub const fn gtcr(self) -> crate::common::Reg<regs::Gtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "General PWM Timer Count Direction and Duty Setting Register"]
        #[inline(always)]
        pub const fn gtuddtyc(self) -> crate::common::Reg<regs::Gtuddtyc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "General PWM Timer I/O Control Register"]
        #[inline(always)]
        pub const fn gtior(self) -> crate::common::Reg<regs::Gtior, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "General PWM Timer Interrupt Output Setting Register"]
        #[inline(always)]
        pub const fn gtintad(self) -> crate::common::Reg<regs::Gtintad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "General PWM Timer Status Register"]
        #[inline(always)]
        pub const fn gtst(self) -> crate::common::Reg<regs::Gtst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "General PWM Timer Buffer Enable Register"]
        #[inline(always)]
        pub const fn gtber(self) -> crate::common::Reg<regs::Gtber, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "General PWM Timer Counter"]
        #[inline(always)]
        pub const fn gtcnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register A"]
        #[inline(always)]
        pub const fn gtccra(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register B"]
        #[inline(always)]
        pub const fn gtccrb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register C"]
        #[inline(always)]
        pub const fn gtccrc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register E"]
        #[inline(always)]
        pub const fn gtccre(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register D"]
        #[inline(always)]
        pub const fn gtccrd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "General PWM Timer Compare Capture Register F"]
        #[inline(always)]
        pub const fn gtccrf(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "General PWM Timer Cycle Setting Register"]
        #[inline(always)]
        pub const fn gtpr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "General PWM Timer Cycle Setting Buffer Register"]
        #[inline(always)]
        pub const fn gtpbr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "General PWM Timer Dead Time Control Register"]
        #[inline(always)]
        pub const fn gtdtcr(self) -> crate::common::Reg<regs::Gtdtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "General PWM Timer Dead Time Value Register U"]
        #[inline(always)]
        pub const fn gtdvu(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "General PWM Timer Buffer Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtber(pub u32);
        impl Gtber {
            #[doc = "GTCCR Buffer Operation Disable"]
            #[inline(always)]
            pub const fn bd0(&self) -> super::vals::Bd0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bd0::from_bits(val as u8)
            }
            #[doc = "GTCCR Buffer Operation Disable"]
            #[inline(always)]
            pub fn set_bd0(&mut self, val: super::vals::Bd0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTPR Buffer Operation Disable"]
            #[inline(always)]
            pub const fn bd1(&self) -> super::vals::Bd1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Bd1::from_bits(val as u8)
            }
            #[doc = "GTPR Buffer Operation Disable"]
            #[inline(always)]
            pub fn set_bd1(&mut self, val: super::vals::Bd1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTCCRA Buffer Operation"]
            #[inline(always)]
            pub const fn ccra(&self) -> super::vals::Ccra {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Ccra::from_bits(val as u8)
            }
            #[doc = "GTCCRA Buffer Operation"]
            #[inline(always)]
            pub fn set_ccra(&mut self, val: super::vals::Ccra) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "GTCCRB Buffer Operation"]
            #[inline(always)]
            pub const fn ccrb(&self) -> super::vals::Ccrb {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Ccrb::from_bits(val as u8)
            }
            #[doc = "GTCCRB Buffer Operation"]
            #[inline(always)]
            pub fn set_ccrb(&mut self, val: super::vals::Ccrb) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "GTPR Buffer Operation"]
            #[inline(always)]
            pub const fn pr(&self) -> super::vals::Pr {
                let val = (self.0 >> 20usize) & 0x03;
                super::vals::Pr::from_bits(val as u8)
            }
            #[doc = "GTPR Buffer Operation"]
            #[inline(always)]
            pub fn set_pr(&mut self, val: super::vals::Pr) {
                self.0 =
                    (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
            }
            #[doc = "GTCCRA and GTCCRB Forcible Buffer Operation"]
            #[inline(always)]
            pub const fn ccrswt(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "GTCCRA and GTCCRB Forcible Buffer Operation"]
            #[inline(always)]
            pub fn set_ccrswt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Gtber {
            #[inline(always)]
            fn default() -> Gtber {
                Gtber(0)
            }
        }
        impl core::fmt::Debug for Gtber {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtber")
                    .field("bd0", &self.bd0())
                    .field("bd1", &self.bd1())
                    .field("ccra", &self.ccra())
                    .field("ccrb", &self.ccrb())
                    .field("pr", &self.pr())
                    .field("ccrswt", &self.ccrswt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtber {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtber {{ bd0: {:?}, bd1: {:?}, ccra: {:?}, ccrb: {:?}, pr: {:?}, ccrswt: {=bool:?} }}" , self . bd0 () , self . bd1 () , self . ccra () , self . ccrb () , self . pr () , self . ccrswt ())
            }
        }
        #[doc = "General PWM Timer Software Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtclr(pub u32);
        impl Gtclr {
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr0(&self) -> super::vals::Cclr0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cclr0::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr0(&mut self, val: super::vals::Cclr0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr1(&self) -> super::vals::Cclr1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cclr1::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr1(&mut self, val: super::vals::Cclr1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr2(&self) -> super::vals::Cclr2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cclr2::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr2(&mut self, val: super::vals::Cclr2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr3(&self) -> super::vals::Cclr3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cclr3::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr3(&mut self, val: super::vals::Cclr3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr4(&self) -> super::vals::Cclr4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cclr4::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr4(&mut self, val: super::vals::Cclr4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr5(&self) -> super::vals::Cclr5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cclr5::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr5(&mut self, val: super::vals::Cclr5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr6(&self) -> super::vals::Cclr6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cclr6::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr6(&mut self, val: super::vals::Cclr6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr7(&self) -> super::vals::Cclr7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cclr7::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr7(&mut self, val: super::vals::Cclr7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr8(&self) -> super::vals::Cclr8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cclr8::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr8(&mut self, val: super::vals::Cclr8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cclr9(&self) -> super::vals::Cclr9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cclr9::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Clear (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cclr9(&mut self, val: super::vals::Cclr9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Gtclr {
            #[inline(always)]
            fn default() -> Gtclr {
                Gtclr(0)
            }
        }
        impl core::fmt::Debug for Gtclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtclr")
                    .field("cclr0", &self.cclr0())
                    .field("cclr1", &self.cclr1())
                    .field("cclr2", &self.cclr2())
                    .field("cclr3", &self.cclr3())
                    .field("cclr4", &self.cclr4())
                    .field("cclr5", &self.cclr5())
                    .field("cclr6", &self.cclr6())
                    .field("cclr7", &self.cclr7())
                    .field("cclr8", &self.cclr8())
                    .field("cclr9", &self.cclr9())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtclr {{ cclr0: {:?}, cclr1: {:?}, cclr2: {:?}, cclr3: {:?}, cclr4: {:?}, cclr5: {:?}, cclr6: {:?}, cclr7: {:?}, cclr8: {:?}, cclr9: {:?} }}" , self . cclr0 () , self . cclr1 () , self . cclr2 () , self . cclr3 () , self . cclr4 () , self . cclr5 () , self . cclr6 () , self . cclr7 () , self . cclr8 () , self . cclr9 ())
            }
        }
        #[doc = "General PWM Timer Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcr(pub u32);
        impl Gtcr {
            #[doc = "Count Start"]
            #[inline(always)]
            pub const fn cst(&self) -> super::vals::Cst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cst::from_bits(val as u8)
            }
            #[doc = "Count Start"]
            #[inline(always)]
            pub fn set_cst(&mut self, val: super::vals::Cst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Mode Select"]
            #[inline(always)]
            pub const fn md(&self) -> super::vals::Md {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Md::from_bits(val as u8)
            }
            #[doc = "Mode Select"]
            #[inline(always)]
            pub fn set_md(&mut self, val: super::vals::Md) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "Timer Prescaler Select"]
            #[inline(always)]
            pub const fn tpcs(&self) -> super::vals::Tpcs {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Tpcs::from_bits(val as u8)
            }
            #[doc = "Timer Prescaler Select"]
            #[inline(always)]
            pub fn set_tpcs(&mut self, val: super::vals::Tpcs) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Gtcr {
            #[inline(always)]
            fn default() -> Gtcr {
                Gtcr(0)
            }
        }
        impl core::fmt::Debug for Gtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcr")
                    .field("cst", &self.cst())
                    .field("md", &self.md())
                    .field("tpcs", &self.tpcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtcr {{ cst: {:?}, md: {:?}, tpcs: {:?} }}",
                    self.cst(),
                    self.md(),
                    self.tpcs()
                )
            }
        }
        #[doc = "General PWM Timer Clear Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtcsr(pub u32);
        impl Gtcsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgar(&self) -> super::vals::Csgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Csgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgar(&mut self, val: super::vals::Csgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgaf(&self) -> super::vals::Csgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Csgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgaf(&mut self, val: super::vals::Csgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgbr(&self) -> super::vals::Csgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Csgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgbr(&mut self, val: super::vals::Csgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn csgtrgbf(&self) -> super::vals::Csgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Csgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_csgtrgbf(&mut self, val: super::vals::Csgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscarbl(&self) -> super::vals::Cscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscarbl(&mut self, val: super::vals::Cscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscarbh(&self) -> super::vals::Cscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscarbh(&mut self, val: super::vals::Cscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscafbl(&self) -> super::vals::Cscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Cscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscafbl(&mut self, val: super::vals::Cscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscafbh(&self) -> super::vals::Cscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Cscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscafbh(&mut self, val: super::vals::Cscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbral(&self) -> super::vals::Cscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Cscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbral(&mut self, val: super::vals::Cscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbrah(&self) -> super::vals::Cscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Cscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbrah(&mut self, val: super::vals::Cscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbfal(&self) -> super::vals::Cscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Cscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbfal(&mut self, val: super::vals::Cscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cscbfah(&self) -> super::vals::Cscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Cscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cscbfah(&mut self, val: super::vals::Cscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselca(&self) -> super::vals::Cselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Cselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselca(&mut self, val: super::vals::Cselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcb(&self) -> super::vals::Cselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Cselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcb(&mut self, val: super::vals::Cselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcc(&self) -> super::vals::Cselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Cselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcc(&mut self, val: super::vals::Cselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cselcd(&self) -> super::vals::Cselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Cselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cselcd(&mut self, val: super::vals::Cselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Software Source Counter Clear Enable"]
            #[inline(always)]
            pub const fn cclr(&self) -> super::vals::Cclr {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cclr::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Clear Enable"]
            #[inline(always)]
            pub fn set_cclr(&mut self, val: super::vals::Cclr) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtcsr {
            #[inline(always)]
            fn default() -> Gtcsr {
                Gtcsr(0)
            }
        }
        impl core::fmt::Debug for Gtcsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtcsr")
                    .field("csgtrgar", &self.csgtrgar())
                    .field("csgtrgaf", &self.csgtrgaf())
                    .field("csgtrgbr", &self.csgtrgbr())
                    .field("csgtrgbf", &self.csgtrgbf())
                    .field("cscarbl", &self.cscarbl())
                    .field("cscarbh", &self.cscarbh())
                    .field("cscafbl", &self.cscafbl())
                    .field("cscafbh", &self.cscafbh())
                    .field("cscbral", &self.cscbral())
                    .field("cscbrah", &self.cscbrah())
                    .field("cscbfal", &self.cscbfal())
                    .field("cscbfah", &self.cscbfah())
                    .field("cselca", &self.cselca())
                    .field("cselcb", &self.cselcb())
                    .field("cselcc", &self.cselcc())
                    .field("cselcd", &self.cselcd())
                    .field("cclr", &self.cclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtcsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtcsr {{ csgtrgar: {:?}, csgtrgaf: {:?}, csgtrgbr: {:?}, csgtrgbf: {:?}, cscarbl: {:?}, cscarbh: {:?}, cscafbl: {:?}, cscafbh: {:?}, cscbral: {:?}, cscbrah: {:?}, cscbfal: {:?}, cscbfah: {:?}, cselca: {:?}, cselcb: {:?}, cselcc: {:?}, cselcd: {:?}, cclr: {:?} }}" , self . csgtrgar () , self . csgtrgaf () , self . csgtrgbr () , self . csgtrgbf () , self . cscarbl () , self . cscarbh () , self . cscafbl () , self . cscafbh () , self . cscbral () , self . cscbrah () , self . cscbfal () , self . cscbfah () , self . cselca () , self . cselcb () , self . cselcc () , self . cselcd () , self . cclr ())
            }
        }
        #[doc = "General PWM Timer Down Count Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdnsr(pub u32);
        impl Gtdnsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgar(&self) -> super::vals::Dsgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dsgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgar(&mut self, val: super::vals::Dsgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgaf(&self) -> super::vals::Dsgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dsgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgaf(&mut self, val: super::vals::Dsgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgbr(&self) -> super::vals::Dsgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dsgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgbr(&mut self, val: super::vals::Dsgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dsgtrgbf(&self) -> super::vals::Dsgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dsgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dsgtrgbf(&mut self, val: super::vals::Dsgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscarbl(&self) -> super::vals::Dscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Dscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscarbl(&mut self, val: super::vals::Dscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscarbh(&self) -> super::vals::Dscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Dscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscarbh(&mut self, val: super::vals::Dscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscafbl(&self) -> super::vals::Dscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Dscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscafbl(&mut self, val: super::vals::Dscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscafbh(&self) -> super::vals::Dscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Dscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscafbh(&mut self, val: super::vals::Dscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbral(&self) -> super::vals::Dscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Dscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbral(&mut self, val: super::vals::Dscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbrah(&self) -> super::vals::Dscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Dscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbrah(&mut self, val: super::vals::Dscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbfal(&self) -> super::vals::Dscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Dscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbfal(&mut self, val: super::vals::Dscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dscbfah(&self) -> super::vals::Dscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Dscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dscbfah(&mut self, val: super::vals::Dscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselca(&self) -> super::vals::Dselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Dselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselca(&mut self, val: super::vals::Dselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcb(&self) -> super::vals::Dselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Dselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcb(&mut self, val: super::vals::Dselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcc(&self) -> super::vals::Dselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Dselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcc(&mut self, val: super::vals::Dselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub const fn dselcd(&self) -> super::vals::Dselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Dselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Count Down Enable"]
            #[inline(always)]
            pub fn set_dselcd(&mut self, val: super::vals::Dselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gtdnsr {
            #[inline(always)]
            fn default() -> Gtdnsr {
                Gtdnsr(0)
            }
        }
        impl core::fmt::Debug for Gtdnsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdnsr")
                    .field("dsgtrgar", &self.dsgtrgar())
                    .field("dsgtrgaf", &self.dsgtrgaf())
                    .field("dsgtrgbr", &self.dsgtrgbr())
                    .field("dsgtrgbf", &self.dsgtrgbf())
                    .field("dscarbl", &self.dscarbl())
                    .field("dscarbh", &self.dscarbh())
                    .field("dscafbl", &self.dscafbl())
                    .field("dscafbh", &self.dscafbh())
                    .field("dscbral", &self.dscbral())
                    .field("dscbrah", &self.dscbrah())
                    .field("dscbfal", &self.dscbfal())
                    .field("dscbfah", &self.dscbfah())
                    .field("dselca", &self.dselca())
                    .field("dselcb", &self.dselcb())
                    .field("dselcc", &self.dselcc())
                    .field("dselcd", &self.dselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdnsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtdnsr {{ dsgtrgar: {:?}, dsgtrgaf: {:?}, dsgtrgbr: {:?}, dsgtrgbf: {:?}, dscarbl: {:?}, dscarbh: {:?}, dscafbl: {:?}, dscafbh: {:?}, dscbral: {:?}, dscbrah: {:?}, dscbfal: {:?}, dscbfah: {:?}, dselca: {:?}, dselcb: {:?}, dselcc: {:?}, dselcd: {:?} }}" , self . dsgtrgar () , self . dsgtrgaf () , self . dsgtrgbr () , self . dsgtrgbf () , self . dscarbl () , self . dscarbh () , self . dscafbl () , self . dscafbh () , self . dscbral () , self . dscbrah () , self . dscbfal () , self . dscbfah () , self . dselca () , self . dselcb () , self . dselcc () , self . dselcd ())
            }
        }
        #[doc = "General PWM Timer Dead Time Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtdtcr(pub u32);
        impl Gtdtcr {
            #[doc = "Negative,Phase Waveform Setting"]
            #[inline(always)]
            pub const fn tde(&self) -> super::vals::Tde {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tde::from_bits(val as u8)
            }
            #[doc = "Negative,Phase Waveform Setting"]
            #[inline(always)]
            pub fn set_tde(&mut self, val: super::vals::Tde) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Gtdtcr {
            #[inline(always)]
            fn default() -> Gtdtcr {
                Gtdtcr(0)
            }
        }
        impl core::fmt::Debug for Gtdtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtdtcr").field("tde", &self.tde()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtdtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gtdtcr {{ tde: {:?} }}", self.tde())
            }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gticasr(pub u32);
        impl Gticasr {
            #[doc = "GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgar(&self) -> super::vals::Asgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Asgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgar(&mut self, val: super::vals::Asgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgaf(&self) -> super::vals::Asgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Asgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgaf(&mut self, val: super::vals::Asgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgbr(&self) -> super::vals::Asgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Asgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgbr(&mut self, val: super::vals::Asgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn asgtrgbf(&self) -> super::vals::Asgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Asgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_asgtrgbf(&mut self, val: super::vals::Asgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascarbl(&self) -> super::vals::Ascarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Ascarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascarbl(&mut self, val: super::vals::Ascarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascarbh(&self) -> super::vals::Ascarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ascarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascarbh(&mut self, val: super::vals::Ascarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascafbl(&self) -> super::vals::Ascafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ascafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascafbl(&mut self, val: super::vals::Ascafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascafbh(&self) -> super::vals::Ascafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Ascafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascafbh(&mut self, val: super::vals::Ascafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbral(&self) -> super::vals::Ascbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ascbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbral(&mut self, val: super::vals::Ascbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbrah(&self) -> super::vals::Ascbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Ascbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbrah(&mut self, val: super::vals::Ascbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbfal(&self) -> super::vals::Ascbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Ascbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbfal(&mut self, val: super::vals::Ascbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn ascbfah(&self) -> super::vals::Ascbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ascbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_ascbfah(&mut self, val: super::vals::Ascbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselca(&self) -> super::vals::Aselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Aselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselca(&mut self, val: super::vals::Aselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcb(&self) -> super::vals::Aselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Aselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcb(&mut self, val: super::vals::Aselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcc(&self) -> super::vals::Aselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Aselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcc(&mut self, val: super::vals::Aselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub const fn aselcd(&self) -> super::vals::Aselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Aselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source GTCCRA Input Capture Enable"]
            #[inline(always)]
            pub fn set_aselcd(&mut self, val: super::vals::Aselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gticasr {
            #[inline(always)]
            fn default() -> Gticasr {
                Gticasr(0)
            }
        }
        impl core::fmt::Debug for Gticasr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gticasr")
                    .field("asgtrgar", &self.asgtrgar())
                    .field("asgtrgaf", &self.asgtrgaf())
                    .field("asgtrgbr", &self.asgtrgbr())
                    .field("asgtrgbf", &self.asgtrgbf())
                    .field("ascarbl", &self.ascarbl())
                    .field("ascarbh", &self.ascarbh())
                    .field("ascafbl", &self.ascafbl())
                    .field("ascafbh", &self.ascafbh())
                    .field("ascbral", &self.ascbral())
                    .field("ascbrah", &self.ascbrah())
                    .field("ascbfal", &self.ascbfal())
                    .field("ascbfah", &self.ascbfah())
                    .field("aselca", &self.aselca())
                    .field("aselcb", &self.aselcb())
                    .field("aselcc", &self.aselcc())
                    .field("aselcd", &self.aselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gticasr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gticasr {{ asgtrgar: {:?}, asgtrgaf: {:?}, asgtrgbr: {:?}, asgtrgbf: {:?}, ascarbl: {:?}, ascarbh: {:?}, ascafbl: {:?}, ascafbh: {:?}, ascbral: {:?}, ascbrah: {:?}, ascbfal: {:?}, ascbfah: {:?}, aselca: {:?}, aselcb: {:?}, aselcc: {:?}, aselcd: {:?} }}" , self . asgtrgar () , self . asgtrgaf () , self . asgtrgbr () , self . asgtrgbf () , self . ascarbl () , self . ascarbh () , self . ascafbl () , self . ascafbh () , self . ascbral () , self . ascbrah () , self . ascbfal () , self . ascbfah () , self . aselca () , self . aselcb () , self . aselcc () , self . aselcd ())
            }
        }
        #[doc = "General PWM Timer Input Capture Source Select Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gticbsr(pub u32);
        impl Gticbsr {
            #[doc = "GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgar(&self) -> super::vals::Bsgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bsgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgar(&mut self, val: super::vals::Bsgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgaf(&self) -> super::vals::Bsgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Bsgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgaf(&mut self, val: super::vals::Bsgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgbr(&self) -> super::vals::Bsgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Bsgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgbr(&mut self, val: super::vals::Bsgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bsgtrgbf(&self) -> super::vals::Bsgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bsgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bsgtrgbf(&mut self, val: super::vals::Bsgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscarbl(&self) -> super::vals::Bscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Bscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscarbl(&mut self, val: super::vals::Bscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscarbh(&self) -> super::vals::Bscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Bscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscarbh(&mut self, val: super::vals::Bscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscafbl(&self) -> super::vals::Bscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscafbl(&mut self, val: super::vals::Bscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscafbh(&self) -> super::vals::Bscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Bscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscafbh(&mut self, val: super::vals::Bscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbral(&self) -> super::vals::Bscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Bscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbral(&mut self, val: super::vals::Bscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbrah(&self) -> super::vals::Bscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Bscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbrah(&mut self, val: super::vals::Bscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbfal(&self) -> super::vals::Bscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Bscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbfal(&mut self, val: super::vals::Bscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bscbfah(&self) -> super::vals::Bscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Bscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bscbfah(&mut self, val: super::vals::Bscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselca(&self) -> super::vals::Bselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Bselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselca(&mut self, val: super::vals::Bselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcb(&self) -> super::vals::Bselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Bselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcb(&mut self, val: super::vals::Bselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcc(&self) -> super::vals::Bselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Bselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcc(&mut self, val: super::vals::Bselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub const fn bselcd(&self) -> super::vals::Bselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Bselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source GTCCRB Input Capture Enable"]
            #[inline(always)]
            pub fn set_bselcd(&mut self, val: super::vals::Bselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gticbsr {
            #[inline(always)]
            fn default() -> Gticbsr {
                Gticbsr(0)
            }
        }
        impl core::fmt::Debug for Gticbsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gticbsr")
                    .field("bsgtrgar", &self.bsgtrgar())
                    .field("bsgtrgaf", &self.bsgtrgaf())
                    .field("bsgtrgbr", &self.bsgtrgbr())
                    .field("bsgtrgbf", &self.bsgtrgbf())
                    .field("bscarbl", &self.bscarbl())
                    .field("bscarbh", &self.bscarbh())
                    .field("bscafbl", &self.bscafbl())
                    .field("bscafbh", &self.bscafbh())
                    .field("bscbral", &self.bscbral())
                    .field("bscbrah", &self.bscbrah())
                    .field("bscbfal", &self.bscbfal())
                    .field("bscbfah", &self.bscbfah())
                    .field("bselca", &self.bselca())
                    .field("bselcb", &self.bselcb())
                    .field("bselcc", &self.bselcc())
                    .field("bselcd", &self.bselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gticbsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gticbsr {{ bsgtrgar: {:?}, bsgtrgaf: {:?}, bsgtrgbr: {:?}, bsgtrgbf: {:?}, bscarbl: {:?}, bscarbh: {:?}, bscafbl: {:?}, bscafbh: {:?}, bscbral: {:?}, bscbrah: {:?}, bscbfal: {:?}, bscbfah: {:?}, bselca: {:?}, bselcb: {:?}, bselcc: {:?}, bselcd: {:?} }}" , self . bsgtrgar () , self . bsgtrgaf () , self . bsgtrgbr () , self . bsgtrgbf () , self . bscarbl () , self . bscarbh () , self . bscafbl () , self . bscafbh () , self . bscbral () , self . bscbrah () , self . bscbfal () , self . bscbfah () , self . bselca () , self . bselcb () , self . bselcc () , self . bselcd ())
            }
        }
        #[doc = "General PWM Timer Interrupt Output Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtintad(pub u32);
        impl Gtintad {
            #[doc = "Output Disable Source Select"]
            #[inline(always)]
            pub const fn grp(&self) -> super::vals::Grp {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Grp::from_bits(val as u8)
            }
            #[doc = "Output Disable Source Select"]
            #[inline(always)]
            pub fn set_grp(&mut self, val: super::vals::Grp) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub const fn grpabh(&self) -> super::vals::Grpabh {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Grpabh::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level High Disable Request Enable"]
            #[inline(always)]
            pub fn set_grpabh(&mut self, val: super::vals::Grpabh) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub const fn grpabl(&self) -> super::vals::Grpabl {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Grpabl::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level Low Disable Request Enable"]
            #[inline(always)]
            pub fn set_grpabl(&mut self, val: super::vals::Grpabl) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Gtintad {
            #[inline(always)]
            fn default() -> Gtintad {
                Gtintad(0)
            }
        }
        impl core::fmt::Debug for Gtintad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtintad")
                    .field("grp", &self.grp())
                    .field("grpabh", &self.grpabh())
                    .field("grpabl", &self.grpabl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtintad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtintad {{ grp: {:?}, grpabh: {:?}, grpabl: {:?} }}",
                    self.grp(),
                    self.grpabh(),
                    self.grpabl()
                )
            }
        }
        #[doc = "General PWM Timer I/O Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtior(pub u32);
        impl Gtior {
            #[doc = "GTIOCnA Pin Function Select"]
            #[inline(always)]
            pub const fn gtioa(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "GTIOCnA Pin Function Select"]
            #[inline(always)]
            pub fn set_gtioa(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GTIOCnA Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub const fn oadflt(&self) -> super::vals::Oadflt {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Oadflt::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub fn set_oadflt(&mut self, val: super::vals::Oadflt) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "GTIOCnA Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub const fn oahld(&self) -> super::vals::Oahld {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Oahld::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub fn set_oahld(&mut self, val: super::vals::Oahld) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "GTIOCnA Pin Output Enable"]
            #[inline(always)]
            pub const fn oae(&self) -> super::vals::Oae {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Oae::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Output Enable"]
            #[inline(always)]
            pub fn set_oae(&mut self, val: super::vals::Oae) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Disable Value Setting"]
            #[inline(always)]
            pub const fn oadf(&self) -> super::vals::Oadf {
                let val = (self.0 >> 9usize) & 0x03;
                super::vals::Oadf::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Disable Value Setting"]
            #[inline(always)]
            pub fn set_oadf(&mut self, val: super::vals::Oadf) {
                self.0 = (self.0 & !(0x03 << 9usize)) | (((val.to_bits() as u32) & 0x03) << 9usize);
            }
            #[doc = "Noise Filter A Enable"]
            #[inline(always)]
            pub const fn nfaen(&self) -> super::vals::Nfaen {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Nfaen::from_bits(val as u8)
            }
            #[doc = "Noise Filter A Enable"]
            #[inline(always)]
            pub fn set_nfaen(&mut self, val: super::vals::Nfaen) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Noise Filter A Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfcsa(&self) -> super::vals::Nfcsa {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Nfcsa::from_bits(val as u8)
            }
            #[doc = "Noise Filter A Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfcsa(&mut self, val: super::vals::Nfcsa) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u32) & 0x03) << 14usize);
            }
            #[doc = "GTIOCnB Pin Function Select"]
            #[inline(always)]
            pub const fn gtiob(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "GTIOCnB Pin Function Select"]
            #[inline(always)]
            pub fn set_gtiob(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
            #[doc = "GTIOCnB Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub const fn obdflt(&self) -> super::vals::Obdflt {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Obdflt::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Output Value Setting at the Count Stop"]
            #[inline(always)]
            pub fn set_obdflt(&mut self, val: super::vals::Obdflt) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "GTIOCnB Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub const fn obhld(&self) -> super::vals::Obhld {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Obhld::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Output Setting at the Start/Stop Count"]
            #[inline(always)]
            pub fn set_obhld(&mut self, val: super::vals::Obhld) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "GTIOCnB Pin Output Enable"]
            #[inline(always)]
            pub const fn obe(&self) -> super::vals::Obe {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Obe::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Output Enable"]
            #[inline(always)]
            pub fn set_obe(&mut self, val: super::vals::Obe) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "GTIOCnB Pin Disable Value Setting"]
            #[inline(always)]
            pub const fn obdf(&self) -> super::vals::Obdf {
                let val = (self.0 >> 25usize) & 0x03;
                super::vals::Obdf::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Disable Value Setting"]
            #[inline(always)]
            pub fn set_obdf(&mut self, val: super::vals::Obdf) {
                self.0 =
                    (self.0 & !(0x03 << 25usize)) | (((val.to_bits() as u32) & 0x03) << 25usize);
            }
            #[doc = "Noise Filter B Enable"]
            #[inline(always)]
            pub const fn nfben(&self) -> super::vals::Nfben {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Nfben::from_bits(val as u8)
            }
            #[doc = "Noise Filter B Enable"]
            #[inline(always)]
            pub fn set_nfben(&mut self, val: super::vals::Nfben) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter B Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfcsb(&self) -> super::vals::Nfcsb {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Nfcsb::from_bits(val as u8)
            }
            #[doc = "Noise Filter B Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfcsb(&mut self, val: super::vals::Nfcsb) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Gtior {
            #[inline(always)]
            fn default() -> Gtior {
                Gtior(0)
            }
        }
        impl core::fmt::Debug for Gtior {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtior")
                    .field("gtioa", &self.gtioa())
                    .field("oadflt", &self.oadflt())
                    .field("oahld", &self.oahld())
                    .field("oae", &self.oae())
                    .field("oadf", &self.oadf())
                    .field("nfaen", &self.nfaen())
                    .field("nfcsa", &self.nfcsa())
                    .field("gtiob", &self.gtiob())
                    .field("obdflt", &self.obdflt())
                    .field("obhld", &self.obhld())
                    .field("obe", &self.obe())
                    .field("obdf", &self.obdf())
                    .field("nfben", &self.nfben())
                    .field("nfcsb", &self.nfcsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtior {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtior {{ gtioa: {=u8:?}, oadflt: {:?}, oahld: {:?}, oae: {:?}, oadf: {:?}, nfaen: {:?}, nfcsa: {:?}, gtiob: {=u8:?}, obdflt: {:?}, obhld: {:?}, obe: {:?}, obdf: {:?}, nfben: {:?}, nfcsb: {:?} }}" , self . gtioa () , self . oadflt () , self . oahld () , self . oae () , self . oadf () , self . nfaen () , self . nfcsa () , self . gtiob () , self . obdflt () , self . obhld () , self . obe () , self . obdf () , self . nfben () , self . nfcsb ())
            }
        }
        #[doc = "General PWM Timer Stop Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtpsr(pub u32);
        impl Gtpsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgar(&self) -> super::vals::Psgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Psgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgar(&mut self, val: super::vals::Psgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgaf(&self) -> super::vals::Psgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Psgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgaf(&mut self, val: super::vals::Psgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgbr(&self) -> super::vals::Psgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Psgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgbr(&mut self, val: super::vals::Psgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn psgtrgbf(&self) -> super::vals::Psgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Psgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_psgtrgbf(&mut self, val: super::vals::Psgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscarbl(&self) -> super::vals::Pscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscarbl(&mut self, val: super::vals::Pscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscarbh(&self) -> super::vals::Pscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscarbh(&mut self, val: super::vals::Pscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscafbl(&self) -> super::vals::Pscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscafbl(&mut self, val: super::vals::Pscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscafbh(&self) -> super::vals::Pscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscafbh(&mut self, val: super::vals::Pscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbral(&self) -> super::vals::Pscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbral(&mut self, val: super::vals::Pscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbrah(&self) -> super::vals::Pscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbrah(&mut self, val: super::vals::Pscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbfal(&self) -> super::vals::Pscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbfal(&mut self, val: super::vals::Pscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pscbfah(&self) -> super::vals::Pscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pscbfah(&mut self, val: super::vals::Pscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselca(&self) -> super::vals::Pselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselca(&mut self, val: super::vals::Pselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcb(&self) -> super::vals::Pselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcb(&mut self, val: super::vals::Pselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcc(&self) -> super::vals::Pselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcc(&mut self, val: super::vals::Pselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn pselcd(&self) -> super::vals::Pselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_pselcd(&mut self, val: super::vals::Pselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Software Source Counter Stop Enable"]
            #[inline(always)]
            pub const fn cstop(&self) -> super::vals::Cstop {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cstop::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Stop Enable"]
            #[inline(always)]
            pub fn set_cstop(&mut self, val: super::vals::Cstop) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtpsr {
            #[inline(always)]
            fn default() -> Gtpsr {
                Gtpsr(0)
            }
        }
        impl core::fmt::Debug for Gtpsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtpsr")
                    .field("psgtrgar", &self.psgtrgar())
                    .field("psgtrgaf", &self.psgtrgaf())
                    .field("psgtrgbr", &self.psgtrgbr())
                    .field("psgtrgbf", &self.psgtrgbf())
                    .field("pscarbl", &self.pscarbl())
                    .field("pscarbh", &self.pscarbh())
                    .field("pscafbl", &self.pscafbl())
                    .field("pscafbh", &self.pscafbh())
                    .field("pscbral", &self.pscbral())
                    .field("pscbrah", &self.pscbrah())
                    .field("pscbfal", &self.pscbfal())
                    .field("pscbfah", &self.pscbfah())
                    .field("pselca", &self.pselca())
                    .field("pselcb", &self.pselcb())
                    .field("pselcc", &self.pselcc())
                    .field("pselcd", &self.pselcd())
                    .field("cstop", &self.cstop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtpsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtpsr {{ psgtrgar: {:?}, psgtrgaf: {:?}, psgtrgbr: {:?}, psgtrgbf: {:?}, pscarbl: {:?}, pscarbh: {:?}, pscafbl: {:?}, pscafbh: {:?}, pscbral: {:?}, pscbrah: {:?}, pscbfal: {:?}, pscbfah: {:?}, pselca: {:?}, pselcb: {:?}, pselcc: {:?}, pselcd: {:?}, cstop: {:?} }}" , self . psgtrgar () , self . psgtrgaf () , self . psgtrgbr () , self . psgtrgbf () , self . pscarbl () , self . pscarbh () , self . pscafbl () , self . pscafbh () , self . pscbral () , self . pscbrah () , self . pscbfal () , self . pscbfah () , self . pselca () , self . pselcb () , self . pselcc () , self . pselcd () , self . cstop ())
            }
        }
        #[doc = "General PWM Timer Start Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtssr(pub u32);
        impl Gtssr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgar(&self) -> super::vals::Ssgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgar(&mut self, val: super::vals::Ssgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgaf(&self) -> super::vals::Ssgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ssgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgaf(&mut self, val: super::vals::Ssgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgbr(&self) -> super::vals::Ssgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ssgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgbr(&mut self, val: super::vals::Ssgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub const fn ssgtrgbf(&self) -> super::vals::Ssgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ssgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_ssgtrgbf(&mut self, val: super::vals::Ssgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscarbl(&self) -> super::vals::Sscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Sscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscarbl(&mut self, val: super::vals::Sscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscarbh(&self) -> super::vals::Sscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Sscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscarbh(&mut self, val: super::vals::Sscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscafbl(&self) -> super::vals::Sscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Sscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscafbl(&mut self, val: super::vals::Sscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscafbh(&self) -> super::vals::Sscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Sscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscafbh(&mut self, val: super::vals::Sscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbral(&self) -> super::vals::Sscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Sscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbral(&mut self, val: super::vals::Sscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbrah(&self) -> super::vals::Sscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Sscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbrah(&mut self, val: super::vals::Sscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbfal(&self) -> super::vals::Sscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Sscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbfal(&mut self, val: super::vals::Sscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sscbfah(&self) -> super::vals::Sscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sscbfah(&mut self, val: super::vals::Sscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselca(&self) -> super::vals::Sselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Sselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselca(&mut self, val: super::vals::Sselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcb(&self) -> super::vals::Sselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Sselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcb(&mut self, val: super::vals::Sselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcc(&self) -> super::vals::Sselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Sselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcc(&mut self, val: super::vals::Sselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Start Enable"]
            #[inline(always)]
            pub const fn sselcd(&self) -> super::vals::Sselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Sselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_sselcd(&mut self, val: super::vals::Sselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Software Source Counter Start Enable"]
            #[inline(always)]
            pub const fn cstrt(&self) -> super::vals::Cstrt {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Cstrt::from_bits(val as u8)
            }
            #[doc = "Software Source Counter Start Enable"]
            #[inline(always)]
            pub fn set_cstrt(&mut self, val: super::vals::Cstrt) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gtssr {
            #[inline(always)]
            fn default() -> Gtssr {
                Gtssr(0)
            }
        }
        impl core::fmt::Debug for Gtssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtssr")
                    .field("ssgtrgar", &self.ssgtrgar())
                    .field("ssgtrgaf", &self.ssgtrgaf())
                    .field("ssgtrgbr", &self.ssgtrgbr())
                    .field("ssgtrgbf", &self.ssgtrgbf())
                    .field("sscarbl", &self.sscarbl())
                    .field("sscarbh", &self.sscarbh())
                    .field("sscafbl", &self.sscafbl())
                    .field("sscafbh", &self.sscafbh())
                    .field("sscbral", &self.sscbral())
                    .field("sscbrah", &self.sscbrah())
                    .field("sscbfal", &self.sscbfal())
                    .field("sscbfah", &self.sscbfah())
                    .field("sselca", &self.sselca())
                    .field("sselcb", &self.sselcb())
                    .field("sselcc", &self.sselcc())
                    .field("sselcd", &self.sselcd())
                    .field("cstrt", &self.cstrt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtssr {{ ssgtrgar: {:?}, ssgtrgaf: {:?}, ssgtrgbr: {:?}, ssgtrgbf: {:?}, sscarbl: {:?}, sscarbh: {:?}, sscafbl: {:?}, sscafbh: {:?}, sscbral: {:?}, sscbrah: {:?}, sscbfal: {:?}, sscbfah: {:?}, sselca: {:?}, sselcb: {:?}, sselcc: {:?}, sselcd: {:?}, cstrt: {:?} }}" , self . ssgtrgar () , self . ssgtrgaf () , self . ssgtrgbr () , self . ssgtrgbf () , self . sscarbl () , self . sscarbh () , self . sscafbl () , self . sscafbh () , self . sscbral () , self . sscbrah () , self . sscbfal () , self . sscbfah () , self . sselca () , self . sselcb () , self . sselcc () , self . sselcd () , self . cstrt ())
            }
        }
        #[doc = "General PWM Timer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtst(pub u32);
        impl Gtst {
            #[doc = "Input Capture/Compare Match Flag A"]
            #[inline(always)]
            pub const fn tcfa(&self) -> super::vals::Tcfa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tcfa::from_bits(val as u8)
            }
            #[doc = "Input Capture/Compare Match Flag A"]
            #[inline(always)]
            pub fn set_tcfa(&mut self, val: super::vals::Tcfa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Input Capture/Compare Match Flag B"]
            #[inline(always)]
            pub const fn tcfb(&self) -> super::vals::Tcfb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Tcfb::from_bits(val as u8)
            }
            #[doc = "Input Capture/Compare Match Flag B"]
            #[inline(always)]
            pub fn set_tcfb(&mut self, val: super::vals::Tcfb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Input Compare Match Flag C"]
            #[inline(always)]
            pub const fn tcfc(&self) -> super::vals::Tcfc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Tcfc::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag C"]
            #[inline(always)]
            pub fn set_tcfc(&mut self, val: super::vals::Tcfc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Input Compare Match Flag D"]
            #[inline(always)]
            pub const fn tcfd(&self) -> super::vals::Tcfd {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tcfd::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag D"]
            #[inline(always)]
            pub fn set_tcfd(&mut self, val: super::vals::Tcfd) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Input Compare Match Flag E"]
            #[inline(always)]
            pub const fn tcfe(&self) -> super::vals::Tcfe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tcfe::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag E"]
            #[inline(always)]
            pub fn set_tcfe(&mut self, val: super::vals::Tcfe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Input Compare Match Flag F"]
            #[inline(always)]
            pub const fn tcff(&self) -> super::vals::Tcff {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tcff::from_bits(val as u8)
            }
            #[doc = "Input Compare Match Flag F"]
            #[inline(always)]
            pub fn set_tcff(&mut self, val: super::vals::Tcff) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub const fn tcfpo(&self) -> super::vals::Tcfpo {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Tcfpo::from_bits(val as u8)
            }
            #[doc = "Overflow Flag"]
            #[inline(always)]
            pub fn set_tcfpo(&mut self, val: super::vals::Tcfpo) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn tcfpu(&self) -> super::vals::Tcfpu {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Tcfpu::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_tcfpu(&mut self, val: super::vals::Tcfpu) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Count Direction Flag"]
            #[inline(always)]
            pub const fn tucf(&self) -> super::vals::Tucf {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Tucf::from_bits(val as u8)
            }
            #[doc = "Count Direction Flag"]
            #[inline(always)]
            pub fn set_tucf(&mut self, val: super::vals::Tucf) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Output Disable Flag"]
            #[inline(always)]
            pub const fn odf(&self) -> super::vals::Odf {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Odf::from_bits(val as u8)
            }
            #[doc = "Output Disable Flag"]
            #[inline(always)]
            pub fn set_odf(&mut self, val: super::vals::Odf) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Same Time Output Level High Flag"]
            #[inline(always)]
            pub const fn oabhf(&self) -> super::vals::Oabhf {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Oabhf::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level High Flag"]
            #[inline(always)]
            pub fn set_oabhf(&mut self, val: super::vals::Oabhf) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Same Time Output Level Low Flag"]
            #[inline(always)]
            pub const fn oablf(&self) -> super::vals::Oablf {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Oablf::from_bits(val as u8)
            }
            #[doc = "Same Time Output Level Low Flag"]
            #[inline(always)]
            pub fn set_oablf(&mut self, val: super::vals::Oablf) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Gtst {
            #[inline(always)]
            fn default() -> Gtst {
                Gtst(0)
            }
        }
        impl core::fmt::Debug for Gtst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtst")
                    .field("tcfa", &self.tcfa())
                    .field("tcfb", &self.tcfb())
                    .field("tcfc", &self.tcfc())
                    .field("tcfd", &self.tcfd())
                    .field("tcfe", &self.tcfe())
                    .field("tcff", &self.tcff())
                    .field("tcfpo", &self.tcfpo())
                    .field("tcfpu", &self.tcfpu())
                    .field("tucf", &self.tucf())
                    .field("odf", &self.odf())
                    .field("oabhf", &self.oabhf())
                    .field("oablf", &self.oablf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtst {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtst {{ tcfa: {:?}, tcfb: {:?}, tcfc: {:?}, tcfd: {:?}, tcfe: {:?}, tcff: {:?}, tcfpo: {:?}, tcfpu: {:?}, tucf: {:?}, odf: {:?}, oabhf: {:?}, oablf: {:?} }}" , self . tcfa () , self . tcfb () , self . tcfc () , self . tcfd () , self . tcfe () , self . tcff () , self . tcfpo () , self . tcfpu () , self . tucf () , self . odf () , self . oabhf () , self . oablf ())
            }
        }
        #[doc = "General PWM Timer Software Stop Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtstp(pub u32);
        impl Gtstp {
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop0(&self) -> super::vals::Cstop0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cstop0::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop0(&mut self, val: super::vals::Cstop0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop1(&self) -> super::vals::Cstop1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cstop1::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop1(&mut self, val: super::vals::Cstop1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop2(&self) -> super::vals::Cstop2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cstop2::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop2(&mut self, val: super::vals::Cstop2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop3(&self) -> super::vals::Cstop3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cstop3::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop3(&mut self, val: super::vals::Cstop3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop4(&self) -> super::vals::Cstop4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cstop4::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop4(&mut self, val: super::vals::Cstop4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop5(&self) -> super::vals::Cstop5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cstop5::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop5(&mut self, val: super::vals::Cstop5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop6(&self) -> super::vals::Cstop6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cstop6::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop6(&mut self, val: super::vals::Cstop6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop7(&self) -> super::vals::Cstop7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cstop7::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop7(&mut self, val: super::vals::Cstop7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop8(&self) -> super::vals::Cstop8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cstop8::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop8(&mut self, val: super::vals::Cstop8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstop9(&self) -> super::vals::Cstop9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cstop9::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Stop (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstop9(&mut self, val: super::vals::Cstop9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Gtstp {
            #[inline(always)]
            fn default() -> Gtstp {
                Gtstp(0)
            }
        }
        impl core::fmt::Debug for Gtstp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtstp")
                    .field("cstop0", &self.cstop0())
                    .field("cstop1", &self.cstop1())
                    .field("cstop2", &self.cstop2())
                    .field("cstop3", &self.cstop3())
                    .field("cstop4", &self.cstop4())
                    .field("cstop5", &self.cstop5())
                    .field("cstop6", &self.cstop6())
                    .field("cstop7", &self.cstop7())
                    .field("cstop8", &self.cstop8())
                    .field("cstop9", &self.cstop9())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtstp {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtstp {{ cstop0: {:?}, cstop1: {:?}, cstop2: {:?}, cstop3: {:?}, cstop4: {:?}, cstop5: {:?}, cstop6: {:?}, cstop7: {:?}, cstop8: {:?}, cstop9: {:?} }}" , self . cstop0 () , self . cstop1 () , self . cstop2 () , self . cstop3 () , self . cstop4 () , self . cstop5 () , self . cstop6 () , self . cstop7 () , self . cstop8 () , self . cstop9 ())
            }
        }
        #[doc = "General PWM Timer Software Start Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtstr(pub u32);
        impl Gtstr {
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt0(&self) -> super::vals::Cstrt0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cstrt0::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt0(&mut self, val: super::vals::Cstrt0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt1(&self) -> super::vals::Cstrt1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cstrt1::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt1(&mut self, val: super::vals::Cstrt1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt2(&self) -> super::vals::Cstrt2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cstrt2::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt2(&mut self, val: super::vals::Cstrt2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt3(&self) -> super::vals::Cstrt3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cstrt3::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt3(&mut self, val: super::vals::Cstrt3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt4(&self) -> super::vals::Cstrt4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Cstrt4::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt4(&mut self, val: super::vals::Cstrt4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt5(&self) -> super::vals::Cstrt5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Cstrt5::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt5(&mut self, val: super::vals::Cstrt5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt6(&self) -> super::vals::Cstrt6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Cstrt6::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt6(&mut self, val: super::vals::Cstrt6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt7(&self) -> super::vals::Cstrt7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cstrt7::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt7(&mut self, val: super::vals::Cstrt7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt8(&self) -> super::vals::Cstrt8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Cstrt8::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt8(&mut self, val: super::vals::Cstrt8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub const fn cstrt9(&self) -> super::vals::Cstrt9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Cstrt9::from_bits(val as u8)
            }
            #[doc = "Channel n GTCNT Count Start (n : the same as bit position value)"]
            #[inline(always)]
            pub fn set_cstrt9(&mut self, val: super::vals::Cstrt9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Gtstr {
            #[inline(always)]
            fn default() -> Gtstr {
                Gtstr(0)
            }
        }
        impl core::fmt::Debug for Gtstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtstr")
                    .field("cstrt0", &self.cstrt0())
                    .field("cstrt1", &self.cstrt1())
                    .field("cstrt2", &self.cstrt2())
                    .field("cstrt3", &self.cstrt3())
                    .field("cstrt4", &self.cstrt4())
                    .field("cstrt5", &self.cstrt5())
                    .field("cstrt6", &self.cstrt6())
                    .field("cstrt7", &self.cstrt7())
                    .field("cstrt8", &self.cstrt8())
                    .field("cstrt9", &self.cstrt9())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtstr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtstr {{ cstrt0: {:?}, cstrt1: {:?}, cstrt2: {:?}, cstrt3: {:?}, cstrt4: {:?}, cstrt5: {:?}, cstrt6: {:?}, cstrt7: {:?}, cstrt8: {:?}, cstrt9: {:?} }}" , self . cstrt0 () , self . cstrt1 () , self . cstrt2 () , self . cstrt3 () , self . cstrt4 () , self . cstrt5 () , self . cstrt6 () , self . cstrt7 () , self . cstrt8 () , self . cstrt9 ())
            }
        }
        #[doc = "General PWM Timer Count Direction and Duty Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtuddtyc(pub u32);
        impl Gtuddtyc {
            #[doc = "Count Direction Setting"]
            #[inline(always)]
            pub const fn ud(&self) -> super::vals::Ud {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ud::from_bits(val as u8)
            }
            #[doc = "Count Direction Setting"]
            #[inline(always)]
            pub fn set_ud(&mut self, val: super::vals::Ud) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Forcible Count Direction Setting"]
            #[inline(always)]
            pub const fn udf(&self) -> super::vals::Udf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Udf::from_bits(val as u8)
            }
            #[doc = "Forcible Count Direction Setting"]
            #[inline(always)]
            pub fn set_udf(&mut self, val: super::vals::Udf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTIOCnA Output Duty Setting"]
            #[inline(always)]
            pub const fn oadty(&self) -> super::vals::Oadty {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Oadty::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Output Duty Setting"]
            #[inline(always)]
            pub fn set_oadty(&mut self, val: super::vals::Oadty) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "Forcible GTIOCnA Output Duty Setting"]
            #[inline(always)]
            pub const fn oadtyf(&self) -> super::vals::Oadtyf {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oadtyf::from_bits(val as u8)
            }
            #[doc = "Forcible GTIOCnA Output Duty Setting"]
            #[inline(always)]
            pub fn set_oadtyf(&mut self, val: super::vals::Oadtyf) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting"]
            #[inline(always)]
            pub const fn oadtyr(&self) -> super::vals::Oadtyr {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oadtyr::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Output Value Selecting after Releasing 0%/100% Duty Setting"]
            #[inline(always)]
            pub fn set_oadtyr(&mut self, val: super::vals::Oadtyr) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "GTIOCnB Output Duty Setting"]
            #[inline(always)]
            pub const fn obdty(&self) -> super::vals::Obdty {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Obdty::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Output Duty Setting"]
            #[inline(always)]
            pub fn set_obdty(&mut self, val: super::vals::Obdty) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Forcible GTIOCnB Output Duty Setting"]
            #[inline(always)]
            pub const fn obdtyf(&self) -> super::vals::Obdtyf {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Obdtyf::from_bits(val as u8)
            }
            #[doc = "Forcible GTIOCnB Output Duty Setting"]
            #[inline(always)]
            pub fn set_obdtyf(&mut self, val: super::vals::Obdtyf) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting"]
            #[inline(always)]
            pub const fn obdtyr(&self) -> super::vals::Obdtyr {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Obdtyr::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Output Value Selecting after Releasing 0%/100% Duty Setting"]
            #[inline(always)]
            pub fn set_obdtyr(&mut self, val: super::vals::Obdtyr) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Gtuddtyc {
            #[inline(always)]
            fn default() -> Gtuddtyc {
                Gtuddtyc(0)
            }
        }
        impl core::fmt::Debug for Gtuddtyc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtuddtyc")
                    .field("ud", &self.ud())
                    .field("udf", &self.udf())
                    .field("oadty", &self.oadty())
                    .field("oadtyf", &self.oadtyf())
                    .field("oadtyr", &self.oadtyr())
                    .field("obdty", &self.obdty())
                    .field("obdtyf", &self.obdtyf())
                    .field("obdtyr", &self.obdtyr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtuddtyc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtuddtyc {{ ud: {:?}, udf: {:?}, oadty: {:?}, oadtyf: {:?}, oadtyr: {:?}, obdty: {:?}, obdtyf: {:?}, obdtyr: {:?} }}" , self . ud () , self . udf () , self . oadty () , self . oadtyf () , self . oadtyr () , self . obdty () , self . obdtyf () , self . obdtyr ())
            }
        }
        #[doc = "General PWM Timer Up Count Source Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtupsr(pub u32);
        impl Gtupsr {
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgar(&self) -> super::vals::Usgtrgar {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Usgtrgar::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgar(&mut self, val: super::vals::Usgtrgar) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgaf(&self) -> super::vals::Usgtrgaf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Usgtrgaf::from_bits(val as u8)
            }
            #[doc = "GTETRGA Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgaf(&mut self, val: super::vals::Usgtrgaf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgbr(&self) -> super::vals::Usgtrgbr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Usgtrgbr::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Rising Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgbr(&mut self, val: super::vals::Usgtrgbr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn usgtrgbf(&self) -> super::vals::Usgtrgbf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Usgtrgbf::from_bits(val as u8)
            }
            #[doc = "GTETRGB Pin Falling Input Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_usgtrgbf(&mut self, val: super::vals::Usgtrgbf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscarbl(&self) -> super::vals::Uscarbl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Uscarbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscarbl(&mut self, val: super::vals::Uscarbl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscarbh(&self) -> super::vals::Uscarbh {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Uscarbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Rising Input during GTIOCnB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscarbh(&mut self, val: super::vals::Uscarbh) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscafbl(&self) -> super::vals::Uscafbl {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Uscafbl::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscafbl(&mut self, val: super::vals::Uscafbl) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscafbh(&self) -> super::vals::Uscafbh {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Uscafbh::from_bits(val as u8)
            }
            #[doc = "GTIOCnA Pin Falling Input during GTIOCnB Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscafbh(&mut self, val: super::vals::Uscafbh) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbral(&self) -> super::vals::Uscbral {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Uscbral::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbral(&mut self, val: super::vals::Uscbral) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbrah(&self) -> super::vals::Uscbrah {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Uscbrah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Rising Input during GTIOCnA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbrah(&mut self, val: super::vals::Uscbrah) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbfal(&self) -> super::vals::Uscbfal {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Uscbfal::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value Low Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbfal(&mut self, val: super::vals::Uscbfal) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uscbfah(&self) -> super::vals::Uscbfah {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Uscbfah::from_bits(val as u8)
            }
            #[doc = "GTIOCnB Pin Falling Input during GTIOCnA Value High Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uscbfah(&mut self, val: super::vals::Uscbfah) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "ELC_GPTA Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselca(&self) -> super::vals::Uselca {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Uselca::from_bits(val as u8)
            }
            #[doc = "ELC_GPTA Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselca(&mut self, val: super::vals::Uselca) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "ELC_GPTB Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcb(&self) -> super::vals::Uselcb {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Uselcb::from_bits(val as u8)
            }
            #[doc = "ELC_GPTB Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcb(&mut self, val: super::vals::Uselcb) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "ELC_GPTC Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcc(&self) -> super::vals::Uselcc {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Uselcc::from_bits(val as u8)
            }
            #[doc = "ELC_GPTC Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcc(&mut self, val: super::vals::Uselcc) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "ELC_GPTD Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub const fn uselcd(&self) -> super::vals::Uselcd {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Uselcd::from_bits(val as u8)
            }
            #[doc = "ELC_GPTD Event Source Counter Count Up Enable"]
            #[inline(always)]
            pub fn set_uselcd(&mut self, val: super::vals::Uselcd) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gtupsr {
            #[inline(always)]
            fn default() -> Gtupsr {
                Gtupsr(0)
            }
        }
        impl core::fmt::Debug for Gtupsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtupsr")
                    .field("usgtrgar", &self.usgtrgar())
                    .field("usgtrgaf", &self.usgtrgaf())
                    .field("usgtrgbr", &self.usgtrgbr())
                    .field("usgtrgbf", &self.usgtrgbf())
                    .field("uscarbl", &self.uscarbl())
                    .field("uscarbh", &self.uscarbh())
                    .field("uscafbl", &self.uscafbl())
                    .field("uscafbh", &self.uscafbh())
                    .field("uscbral", &self.uscbral())
                    .field("uscbrah", &self.uscbrah())
                    .field("uscbfal", &self.uscbfal())
                    .field("uscbfah", &self.uscbfah())
                    .field("uselca", &self.uselca())
                    .field("uselcb", &self.uselcb())
                    .field("uselcc", &self.uselcc())
                    .field("uselcd", &self.uselcd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtupsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gtupsr {{ usgtrgar: {:?}, usgtrgaf: {:?}, usgtrgbr: {:?}, usgtrgbf: {:?}, uscarbl: {:?}, uscarbh: {:?}, uscafbl: {:?}, uscafbh: {:?}, uscbral: {:?}, uscbrah: {:?}, uscbfal: {:?}, uscbfah: {:?}, uselca: {:?}, uselcb: {:?}, uselcc: {:?}, uselcd: {:?} }}" , self . usgtrgar () , self . usgtrgaf () , self . usgtrgbr () , self . usgtrgbf () , self . uscarbl () , self . uscarbh () , self . uscafbl () , self . uscafbh () , self . uscbral () , self . uscbrah () , self . uscbfal () , self . uscbfah () , self . uselca () , self . uselcb () , self . uselcc () , self . uselcd ())
            }
        }
        #[doc = "General PWM Timer Write,Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gtwp(pub u32);
        impl Gtwp {
            #[doc = "Register Write Disable"]
            #[inline(always)]
            pub const fn wp(&self) -> super::vals::Wp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Wp::from_bits(val as u8)
            }
            #[doc = "Register Write Disable"]
            #[inline(always)]
            pub fn set_wp(&mut self, val: super::vals::Wp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "GTWP Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "GTWP Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Gtwp {
            #[inline(always)]
            fn default() -> Gtwp {
                Gtwp(0)
            }
        }
        impl core::fmt::Debug for Gtwp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gtwp")
                    .field("wp", &self.wp())
                    .field("prkey", &self.prkey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gtwp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gtwp {{ wp: {:?}, prkey: {=u8:?} }}",
                    self.wp(),
                    self.prkey()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascafbh {
            #[inline(always)]
            fn from(val: u8) -> Ascafbh {
                Ascafbh::from_bits(val)
            }
        }
        impl From<Ascafbh> for u8 {
            #[inline(always)]
            fn from(val: Ascafbh) -> u8 {
                Ascafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascafbl {
            #[inline(always)]
            fn from(val: u8) -> Ascafbl {
                Ascafbl::from_bits(val)
            }
        }
        impl From<Ascafbl> for u8 {
            #[inline(always)]
            fn from(val: Ascafbl) -> u8 {
                Ascafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascarbh {
            #[inline(always)]
            fn from(val: u8) -> Ascarbh {
                Ascarbh::from_bits(val)
            }
        }
        impl From<Ascarbh> for u8 {
            #[inline(always)]
            fn from(val: Ascarbh) -> u8 {
                Ascarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascarbl {
            #[inline(always)]
            fn from(val: u8) -> Ascarbl {
                Ascarbl::from_bits(val)
            }
        }
        impl From<Ascarbl> for u8 {
            #[inline(always)]
            fn from(val: Ascarbl) -> u8 {
                Ascarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbfah {
            #[inline(always)]
            fn from(val: u8) -> Ascbfah {
                Ascbfah::from_bits(val)
            }
        }
        impl From<Ascbfah> for u8 {
            #[inline(always)]
            fn from(val: Ascbfah) -> u8 {
                Ascbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbfal {
            #[inline(always)]
            fn from(val: u8) -> Ascbfal {
                Ascbfal::from_bits(val)
            }
        }
        impl From<Ascbfal> for u8 {
            #[inline(always)]
            fn from(val: Ascbfal) -> u8 {
                Ascbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbrah {
            #[inline(always)]
            fn from(val: u8) -> Ascbrah {
                Ascbrah::from_bits(val)
            }
        }
        impl From<Ascbrah> for u8 {
            #[inline(always)]
            fn from(val: Ascbrah) -> u8 {
                Ascbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ascbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ascbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ascbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ascbral {
            #[inline(always)]
            fn from(val: u8) -> Ascbral {
                Ascbral::from_bits(val)
            }
        }
        impl From<Ascbral> for u8 {
            #[inline(always)]
            fn from(val: Ascbral) -> u8 {
                Ascbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselca {
            #[inline(always)]
            fn from(val: u8) -> Aselca {
                Aselca::from_bits(val)
            }
        }
        impl From<Aselca> for u8 {
            #[inline(always)]
            fn from(val: Aselca) -> u8 {
                Aselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcb {
            #[inline(always)]
            fn from(val: u8) -> Aselcb {
                Aselcb::from_bits(val)
            }
        }
        impl From<Aselcb> for u8 {
            #[inline(always)]
            fn from(val: Aselcb) -> u8 {
                Aselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcc {
            #[inline(always)]
            fn from(val: u8) -> Aselcc {
                Aselcc::from_bits(val)
            }
        }
        impl From<Aselcc> for u8 {
            #[inline(always)]
            fn from(val: Aselcc) -> u8 {
                Aselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aselcd {
            #[inline(always)]
            fn from(val: u8) -> Aselcd {
                Aselcd::from_bits(val)
            }
        }
        impl From<Aselcd> for u8 {
            #[inline(always)]
            fn from(val: Aselcd) -> u8 {
                Aselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgaf {
                Asgtrgaf::from_bits(val)
            }
        }
        impl From<Asgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgaf) -> u8 {
                Asgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgar {
                Asgtrgar::from_bits(val)
            }
        }
        impl From<Asgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgar) -> u8 {
                Asgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgbf {
                Asgtrgbf::from_bits(val)
            }
        }
        impl From<Asgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgbf) -> u8 {
                Asgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Asgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Asgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Asgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Asgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Asgtrgbr {
                Asgtrgbr::from_bits(val)
            }
        }
        impl From<Asgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Asgtrgbr) -> u8 {
                Asgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bd0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bd0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bd0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bd0 {
            #[inline(always)]
            fn from(val: u8) -> Bd0 {
                Bd0::from_bits(val)
            }
        }
        impl From<Bd0> for u8 {
            #[inline(always)]
            fn from(val: Bd0) -> u8 {
                Bd0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bd1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bd1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bd1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bd1 {
            #[inline(always)]
            fn from(val: u8) -> Bd1 {
                Bd1::from_bits(val)
            }
        }
        impl From<Bd1> for u8 {
            #[inline(always)]
            fn from(val: Bd1) -> u8 {
                Bd1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscafbh {
            #[inline(always)]
            fn from(val: u8) -> Bscafbh {
                Bscafbh::from_bits(val)
            }
        }
        impl From<Bscafbh> for u8 {
            #[inline(always)]
            fn from(val: Bscafbh) -> u8 {
                Bscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscafbl {
            #[inline(always)]
            fn from(val: u8) -> Bscafbl {
                Bscafbl::from_bits(val)
            }
        }
        impl From<Bscafbl> for u8 {
            #[inline(always)]
            fn from(val: Bscafbl) -> u8 {
                Bscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscarbh {
            #[inline(always)]
            fn from(val: u8) -> Bscarbh {
                Bscarbh::from_bits(val)
            }
        }
        impl From<Bscarbh> for u8 {
            #[inline(always)]
            fn from(val: Bscarbh) -> u8 {
                Bscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscarbl {
            #[inline(always)]
            fn from(val: u8) -> Bscarbl {
                Bscarbl::from_bits(val)
            }
        }
        impl From<Bscarbl> for u8 {
            #[inline(always)]
            fn from(val: Bscarbl) -> u8 {
                Bscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbfah {
            #[inline(always)]
            fn from(val: u8) -> Bscbfah {
                Bscbfah::from_bits(val)
            }
        }
        impl From<Bscbfah> for u8 {
            #[inline(always)]
            fn from(val: Bscbfah) -> u8 {
                Bscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbfal {
            #[inline(always)]
            fn from(val: u8) -> Bscbfal {
                Bscbfal::from_bits(val)
            }
        }
        impl From<Bscbfal> for u8 {
            #[inline(always)]
            fn from(val: Bscbfal) -> u8 {
                Bscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbrah {
            #[inline(always)]
            fn from(val: u8) -> Bscbrah {
                Bscbrah::from_bits(val)
            }
        }
        impl From<Bscbrah> for u8 {
            #[inline(always)]
            fn from(val: Bscbrah) -> u8 {
                Bscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bscbral {
            #[inline(always)]
            fn from(val: u8) -> Bscbral {
                Bscbral::from_bits(val)
            }
        }
        impl From<Bscbral> for u8 {
            #[inline(always)]
            fn from(val: Bscbral) -> u8 {
                Bscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselca {
            #[inline(always)]
            fn from(val: u8) -> Bselca {
                Bselca::from_bits(val)
            }
        }
        impl From<Bselca> for u8 {
            #[inline(always)]
            fn from(val: Bselca) -> u8 {
                Bselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcb {
            #[inline(always)]
            fn from(val: u8) -> Bselcb {
                Bselcb::from_bits(val)
            }
        }
        impl From<Bselcb> for u8 {
            #[inline(always)]
            fn from(val: Bselcb) -> u8 {
                Bselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcc {
            #[inline(always)]
            fn from(val: u8) -> Bselcc {
                Bselcc::from_bits(val)
            }
        }
        impl From<Bselcc> for u8 {
            #[inline(always)]
            fn from(val: Bselcc) -> u8 {
                Bselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bselcd {
            #[inline(always)]
            fn from(val: u8) -> Bselcd {
                Bselcd::from_bits(val)
            }
        }
        impl From<Bselcd> for u8 {
            #[inline(always)]
            fn from(val: Bselcd) -> u8 {
                Bselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgaf {
                Bsgtrgaf::from_bits(val)
            }
        }
        impl From<Bsgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgaf) -> u8 {
                Bsgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgar {
                Bsgtrgar::from_bits(val)
            }
        }
        impl From<Bsgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgar) -> u8 {
                Bsgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgbf {
                Bsgtrgbf::from_bits(val)
            }
        }
        impl From<Bsgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgbf) -> u8 {
                Bsgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bsgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bsgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bsgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bsgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Bsgtrgbr {
                Bsgtrgbr::from_bits(val)
            }
        }
        impl From<Bsgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Bsgtrgbr) -> u8 {
                Bsgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr {
            #[inline(always)]
            fn from(val: u8) -> Cclr {
                Cclr::from_bits(val)
            }
        }
        impl From<Cclr> for u8 {
            #[inline(always)]
            fn from(val: Cclr) -> u8 {
                Cclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr0 {
            #[inline(always)]
            fn from(val: u8) -> Cclr0 {
                Cclr0::from_bits(val)
            }
        }
        impl From<Cclr0> for u8 {
            #[inline(always)]
            fn from(val: Cclr0) -> u8 {
                Cclr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr1 {
            #[inline(always)]
            fn from(val: u8) -> Cclr1 {
                Cclr1::from_bits(val)
            }
        }
        impl From<Cclr1> for u8 {
            #[inline(always)]
            fn from(val: Cclr1) -> u8 {
                Cclr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr2 {
            #[inline(always)]
            fn from(val: u8) -> Cclr2 {
                Cclr2::from_bits(val)
            }
        }
        impl From<Cclr2> for u8 {
            #[inline(always)]
            fn from(val: Cclr2) -> u8 {
                Cclr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr3 {
            #[inline(always)]
            fn from(val: u8) -> Cclr3 {
                Cclr3::from_bits(val)
            }
        }
        impl From<Cclr3> for u8 {
            #[inline(always)]
            fn from(val: Cclr3) -> u8 {
                Cclr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr4 {
            #[inline(always)]
            fn from(val: u8) -> Cclr4 {
                Cclr4::from_bits(val)
            }
        }
        impl From<Cclr4> for u8 {
            #[inline(always)]
            fn from(val: Cclr4) -> u8 {
                Cclr4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr5 {
            #[inline(always)]
            fn from(val: u8) -> Cclr5 {
                Cclr5::from_bits(val)
            }
        }
        impl From<Cclr5> for u8 {
            #[inline(always)]
            fn from(val: Cclr5) -> u8 {
                Cclr5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr6 {
            #[inline(always)]
            fn from(val: u8) -> Cclr6 {
                Cclr6::from_bits(val)
            }
        }
        impl From<Cclr6> for u8 {
            #[inline(always)]
            fn from(val: Cclr6) -> u8 {
                Cclr6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr7 {
            #[inline(always)]
            fn from(val: u8) -> Cclr7 {
                Cclr7::from_bits(val)
            }
        }
        impl From<Cclr7> for u8 {
            #[inline(always)]
            fn from(val: Cclr7) -> u8 {
                Cclr7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr8 {
            #[inline(always)]
            fn from(val: u8) -> Cclr8 {
                Cclr8::from_bits(val)
            }
        }
        impl From<Cclr8> for u8 {
            #[inline(always)]
            fn from(val: Cclr8) -> u8 {
                Cclr8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cclr9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cclr9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cclr9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cclr9 {
            #[inline(always)]
            fn from(val: u8) -> Cclr9 {
                Cclr9::from_bits(val)
            }
        }
        impl From<Cclr9> for u8 {
            #[inline(always)]
            fn from(val: Cclr9) -> u8 {
                Cclr9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccra {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ccra {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccra {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccra {
            #[inline(always)]
            fn from(val: u8) -> Ccra {
                Ccra::from_bits(val)
            }
        }
        impl From<Ccra> for u8 {
            #[inline(always)]
            fn from(val: Ccra) -> u8 {
                Ccra::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccrb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ccrb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccrb {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccrb {
            #[inline(always)]
            fn from(val: u8) -> Ccrb {
                Ccrb::from_bits(val)
            }
        }
        impl From<Ccrb> for u8 {
            #[inline(always)]
            fn from(val: Ccrb) -> u8 {
                Ccrb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscafbh {
            #[inline(always)]
            fn from(val: u8) -> Cscafbh {
                Cscafbh::from_bits(val)
            }
        }
        impl From<Cscafbh> for u8 {
            #[inline(always)]
            fn from(val: Cscafbh) -> u8 {
                Cscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscafbl {
            #[inline(always)]
            fn from(val: u8) -> Cscafbl {
                Cscafbl::from_bits(val)
            }
        }
        impl From<Cscafbl> for u8 {
            #[inline(always)]
            fn from(val: Cscafbl) -> u8 {
                Cscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscarbh {
            #[inline(always)]
            fn from(val: u8) -> Cscarbh {
                Cscarbh::from_bits(val)
            }
        }
        impl From<Cscarbh> for u8 {
            #[inline(always)]
            fn from(val: Cscarbh) -> u8 {
                Cscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscarbl {
            #[inline(always)]
            fn from(val: u8) -> Cscarbl {
                Cscarbl::from_bits(val)
            }
        }
        impl From<Cscarbl> for u8 {
            #[inline(always)]
            fn from(val: Cscarbl) -> u8 {
                Cscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbfah {
            #[inline(always)]
            fn from(val: u8) -> Cscbfah {
                Cscbfah::from_bits(val)
            }
        }
        impl From<Cscbfah> for u8 {
            #[inline(always)]
            fn from(val: Cscbfah) -> u8 {
                Cscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbfal {
            #[inline(always)]
            fn from(val: u8) -> Cscbfal {
                Cscbfal::from_bits(val)
            }
        }
        impl From<Cscbfal> for u8 {
            #[inline(always)]
            fn from(val: Cscbfal) -> u8 {
                Cscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbrah {
            #[inline(always)]
            fn from(val: u8) -> Cscbrah {
                Cscbrah::from_bits(val)
            }
        }
        impl From<Cscbrah> for u8 {
            #[inline(always)]
            fn from(val: Cscbrah) -> u8 {
                Cscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cscbral {
            #[inline(always)]
            fn from(val: u8) -> Cscbral {
                Cscbral::from_bits(val)
            }
        }
        impl From<Cscbral> for u8 {
            #[inline(always)]
            fn from(val: Cscbral) -> u8 {
                Cscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselca {
            #[inline(always)]
            fn from(val: u8) -> Cselca {
                Cselca::from_bits(val)
            }
        }
        impl From<Cselca> for u8 {
            #[inline(always)]
            fn from(val: Cselca) -> u8 {
                Cselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcb {
            #[inline(always)]
            fn from(val: u8) -> Cselcb {
                Cselcb::from_bits(val)
            }
        }
        impl From<Cselcb> for u8 {
            #[inline(always)]
            fn from(val: Cselcb) -> u8 {
                Cselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcc {
            #[inline(always)]
            fn from(val: u8) -> Cselcc {
                Cselcc::from_bits(val)
            }
        }
        impl From<Cselcc> for u8 {
            #[inline(always)]
            fn from(val: Cselcc) -> u8 {
                Cselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cselcd {
            #[inline(always)]
            fn from(val: u8) -> Cselcd {
                Cselcd::from_bits(val)
            }
        }
        impl From<Cselcd> for u8 {
            #[inline(always)]
            fn from(val: Cselcd) -> u8 {
                Cselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgaf {
                Csgtrgaf::from_bits(val)
            }
        }
        impl From<Csgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgaf) -> u8 {
                Csgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgar {
                Csgtrgar::from_bits(val)
            }
        }
        impl From<Csgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgar) -> u8 {
                Csgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgbf {
                Csgtrgbf::from_bits(val)
            }
        }
        impl From<Csgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgbf) -> u8 {
                Csgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Csgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Csgtrgbr {
                Csgtrgbr::from_bits(val)
            }
        }
        impl From<Csgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Csgtrgbr) -> u8 {
                Csgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cst {
            #[inline(always)]
            fn from(val: u8) -> Cst {
                Cst::from_bits(val)
            }
        }
        impl From<Cst> for u8 {
            #[inline(always)]
            fn from(val: Cst) -> u8 {
                Cst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop {
            #[inline(always)]
            fn from(val: u8) -> Cstop {
                Cstop::from_bits(val)
            }
        }
        impl From<Cstop> for u8 {
            #[inline(always)]
            fn from(val: Cstop) -> u8 {
                Cstop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop0 {
            #[inline(always)]
            fn from(val: u8) -> Cstop0 {
                Cstop0::from_bits(val)
            }
        }
        impl From<Cstop0> for u8 {
            #[inline(always)]
            fn from(val: Cstop0) -> u8 {
                Cstop0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop1 {
            #[inline(always)]
            fn from(val: u8) -> Cstop1 {
                Cstop1::from_bits(val)
            }
        }
        impl From<Cstop1> for u8 {
            #[inline(always)]
            fn from(val: Cstop1) -> u8 {
                Cstop1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop2 {
            #[inline(always)]
            fn from(val: u8) -> Cstop2 {
                Cstop2::from_bits(val)
            }
        }
        impl From<Cstop2> for u8 {
            #[inline(always)]
            fn from(val: Cstop2) -> u8 {
                Cstop2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop3 {
            #[inline(always)]
            fn from(val: u8) -> Cstop3 {
                Cstop3::from_bits(val)
            }
        }
        impl From<Cstop3> for u8 {
            #[inline(always)]
            fn from(val: Cstop3) -> u8 {
                Cstop3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop4 {
            #[inline(always)]
            fn from(val: u8) -> Cstop4 {
                Cstop4::from_bits(val)
            }
        }
        impl From<Cstop4> for u8 {
            #[inline(always)]
            fn from(val: Cstop4) -> u8 {
                Cstop4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop5 {
            #[inline(always)]
            fn from(val: u8) -> Cstop5 {
                Cstop5::from_bits(val)
            }
        }
        impl From<Cstop5> for u8 {
            #[inline(always)]
            fn from(val: Cstop5) -> u8 {
                Cstop5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop6 {
            #[inline(always)]
            fn from(val: u8) -> Cstop6 {
                Cstop6::from_bits(val)
            }
        }
        impl From<Cstop6> for u8 {
            #[inline(always)]
            fn from(val: Cstop6) -> u8 {
                Cstop6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop7 {
            #[inline(always)]
            fn from(val: u8) -> Cstop7 {
                Cstop7::from_bits(val)
            }
        }
        impl From<Cstop7> for u8 {
            #[inline(always)]
            fn from(val: Cstop7) -> u8 {
                Cstop7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop8 {
            #[inline(always)]
            fn from(val: u8) -> Cstop8 {
                Cstop8::from_bits(val)
            }
        }
        impl From<Cstop8> for u8 {
            #[inline(always)]
            fn from(val: Cstop8) -> u8 {
                Cstop8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstop9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstop9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstop9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstop9 {
            #[inline(always)]
            fn from(val: u8) -> Cstop9 {
                Cstop9::from_bits(val)
            }
        }
        impl From<Cstop9> for u8 {
            #[inline(always)]
            fn from(val: Cstop9) -> u8 {
                Cstop9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt {
            #[inline(always)]
            fn from(val: u8) -> Cstrt {
                Cstrt::from_bits(val)
            }
        }
        impl From<Cstrt> for u8 {
            #[inline(always)]
            fn from(val: Cstrt) -> u8 {
                Cstrt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt0 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt0 {
                Cstrt0::from_bits(val)
            }
        }
        impl From<Cstrt0> for u8 {
            #[inline(always)]
            fn from(val: Cstrt0) -> u8 {
                Cstrt0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt1 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt1 {
                Cstrt1::from_bits(val)
            }
        }
        impl From<Cstrt1> for u8 {
            #[inline(always)]
            fn from(val: Cstrt1) -> u8 {
                Cstrt1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt2 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt2 {
                Cstrt2::from_bits(val)
            }
        }
        impl From<Cstrt2> for u8 {
            #[inline(always)]
            fn from(val: Cstrt2) -> u8 {
                Cstrt2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt3 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt3 {
                Cstrt3::from_bits(val)
            }
        }
        impl From<Cstrt3> for u8 {
            #[inline(always)]
            fn from(val: Cstrt3) -> u8 {
                Cstrt3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt4 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt4 {
                Cstrt4::from_bits(val)
            }
        }
        impl From<Cstrt4> for u8 {
            #[inline(always)]
            fn from(val: Cstrt4) -> u8 {
                Cstrt4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt5 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt5 {
                Cstrt5::from_bits(val)
            }
        }
        impl From<Cstrt5> for u8 {
            #[inline(always)]
            fn from(val: Cstrt5) -> u8 {
                Cstrt5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt6 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt6 {
                Cstrt6::from_bits(val)
            }
        }
        impl From<Cstrt6> for u8 {
            #[inline(always)]
            fn from(val: Cstrt6) -> u8 {
                Cstrt6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt7 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt7 {
                Cstrt7::from_bits(val)
            }
        }
        impl From<Cstrt7> for u8 {
            #[inline(always)]
            fn from(val: Cstrt7) -> u8 {
                Cstrt7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt8 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt8 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt8 {
                Cstrt8::from_bits(val)
            }
        }
        impl From<Cstrt8> for u8 {
            #[inline(always)]
            fn from(val: Cstrt8) -> u8 {
                Cstrt8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cstrt9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cstrt9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cstrt9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cstrt9 {
            #[inline(always)]
            fn from(val: u8) -> Cstrt9 {
                Cstrt9::from_bits(val)
            }
        }
        impl From<Cstrt9> for u8 {
            #[inline(always)]
            fn from(val: Cstrt9) -> u8 {
                Cstrt9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscafbh {
            #[inline(always)]
            fn from(val: u8) -> Dscafbh {
                Dscafbh::from_bits(val)
            }
        }
        impl From<Dscafbh> for u8 {
            #[inline(always)]
            fn from(val: Dscafbh) -> u8 {
                Dscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscafbl {
            #[inline(always)]
            fn from(val: u8) -> Dscafbl {
                Dscafbl::from_bits(val)
            }
        }
        impl From<Dscafbl> for u8 {
            #[inline(always)]
            fn from(val: Dscafbl) -> u8 {
                Dscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscarbh {
            #[inline(always)]
            fn from(val: u8) -> Dscarbh {
                Dscarbh::from_bits(val)
            }
        }
        impl From<Dscarbh> for u8 {
            #[inline(always)]
            fn from(val: Dscarbh) -> u8 {
                Dscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscarbl {
            #[inline(always)]
            fn from(val: u8) -> Dscarbl {
                Dscarbl::from_bits(val)
            }
        }
        impl From<Dscarbl> for u8 {
            #[inline(always)]
            fn from(val: Dscarbl) -> u8 {
                Dscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbfah {
            #[inline(always)]
            fn from(val: u8) -> Dscbfah {
                Dscbfah::from_bits(val)
            }
        }
        impl From<Dscbfah> for u8 {
            #[inline(always)]
            fn from(val: Dscbfah) -> u8 {
                Dscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbfal {
            #[inline(always)]
            fn from(val: u8) -> Dscbfal {
                Dscbfal::from_bits(val)
            }
        }
        impl From<Dscbfal> for u8 {
            #[inline(always)]
            fn from(val: Dscbfal) -> u8 {
                Dscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbrah {
            #[inline(always)]
            fn from(val: u8) -> Dscbrah {
                Dscbrah::from_bits(val)
            }
        }
        impl From<Dscbrah> for u8 {
            #[inline(always)]
            fn from(val: Dscbrah) -> u8 {
                Dscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dscbral {
            #[inline(always)]
            fn from(val: u8) -> Dscbral {
                Dscbral::from_bits(val)
            }
        }
        impl From<Dscbral> for u8 {
            #[inline(always)]
            fn from(val: Dscbral) -> u8 {
                Dscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselca {
            #[inline(always)]
            fn from(val: u8) -> Dselca {
                Dselca::from_bits(val)
            }
        }
        impl From<Dselca> for u8 {
            #[inline(always)]
            fn from(val: Dselca) -> u8 {
                Dselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcb {
            #[inline(always)]
            fn from(val: u8) -> Dselcb {
                Dselcb::from_bits(val)
            }
        }
        impl From<Dselcb> for u8 {
            #[inline(always)]
            fn from(val: Dselcb) -> u8 {
                Dselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcc {
            #[inline(always)]
            fn from(val: u8) -> Dselcc {
                Dselcc::from_bits(val)
            }
        }
        impl From<Dselcc> for u8 {
            #[inline(always)]
            fn from(val: Dselcc) -> u8 {
                Dselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dselcd {
            #[inline(always)]
            fn from(val: u8) -> Dselcd {
                Dselcd::from_bits(val)
            }
        }
        impl From<Dselcd> for u8 {
            #[inline(always)]
            fn from(val: Dselcd) -> u8 {
                Dselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgaf {
                Dsgtrgaf::from_bits(val)
            }
        }
        impl From<Dsgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgaf) -> u8 {
                Dsgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgar {
                Dsgtrgar::from_bits(val)
            }
        }
        impl From<Dsgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgar) -> u8 {
                Dsgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgbf {
                Dsgtrgbf::from_bits(val)
            }
        }
        impl From<Dsgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgbf) -> u8 {
                Dsgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Dsgtrgbr {
                Dsgtrgbr::from_bits(val)
            }
        }
        impl From<Dsgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Dsgtrgbr) -> u8 {
                Dsgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Grp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grp {
            #[inline(always)]
            fn from(val: u8) -> Grp {
                Grp::from_bits(val)
            }
        }
        impl From<Grp> for u8 {
            #[inline(always)]
            fn from(val: Grp) -> u8 {
                Grp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grpabh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grpabh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grpabh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grpabh {
            #[inline(always)]
            fn from(val: u8) -> Grpabh {
                Grpabh::from_bits(val)
            }
        }
        impl From<Grpabh> for u8 {
            #[inline(always)]
            fn from(val: Grpabh) -> u8 {
                Grpabh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Grpabl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Grpabl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Grpabl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Grpabl {
            #[inline(always)]
            fn from(val: u8) -> Grpabl {
                Grpabl::from_bits(val)
            }
        }
        impl From<Grpabl> for u8 {
            #[inline(always)]
            fn from(val: Grpabl) -> u8 {
                Grpabl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Md {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Md {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Md {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Md {
            #[inline(always)]
            fn from(val: u8) -> Md {
                Md::from_bits(val)
            }
        }
        impl From<Md> for u8 {
            #[inline(always)]
            fn from(val: Md) -> u8 {
                Md::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfaen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfaen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfaen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfaen {
            #[inline(always)]
            fn from(val: u8) -> Nfaen {
                Nfaen::from_bits(val)
            }
        }
        impl From<Nfaen> for u8 {
            #[inline(always)]
            fn from(val: Nfaen) -> u8 {
                Nfaen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfben {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfben {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfben {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfben {
            #[inline(always)]
            fn from(val: u8) -> Nfben {
                Nfben::from_bits(val)
            }
        }
        impl From<Nfben> for u8 {
            #[inline(always)]
            fn from(val: Nfben) -> u8 {
                Nfben::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcsa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcsa {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcsa {
            #[inline(always)]
            fn from(val: u8) -> Nfcsa {
                Nfcsa::from_bits(val)
            }
        }
        impl From<Nfcsa> for u8 {
            #[inline(always)]
            fn from(val: Nfcsa) -> u8 {
                Nfcsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcsb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcsb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcsb {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcsb {
            #[inline(always)]
            fn from(val: u8) -> Nfcsb {
                Nfcsb::from_bits(val)
            }
        }
        impl From<Nfcsb> for u8 {
            #[inline(always)]
            fn from(val: Nfcsb) -> u8 {
                Nfcsb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oabhf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oabhf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oabhf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oabhf {
            #[inline(always)]
            fn from(val: u8) -> Oabhf {
                Oabhf::from_bits(val)
            }
        }
        impl From<Oabhf> for u8 {
            #[inline(always)]
            fn from(val: Oabhf) -> u8 {
                Oabhf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oablf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oablf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oablf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oablf {
            #[inline(always)]
            fn from(val: u8) -> Oablf {
                Oablf::from_bits(val)
            }
        }
        impl From<Oablf> for u8 {
            #[inline(always)]
            fn from(val: Oablf) -> u8 {
                Oablf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oadf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadf {
            #[inline(always)]
            fn from(val: u8) -> Oadf {
                Oadf::from_bits(val)
            }
        }
        impl From<Oadf> for u8 {
            #[inline(always)]
            fn from(val: Oadf) -> u8 {
                Oadf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadflt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadflt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadflt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadflt {
            #[inline(always)]
            fn from(val: u8) -> Oadflt {
                Oadflt::from_bits(val)
            }
        }
        impl From<Oadflt> for u8 {
            #[inline(always)]
            fn from(val: Oadflt) -> u8 {
                Oadflt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Oadty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadty {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadty {
            #[inline(always)]
            fn from(val: u8) -> Oadty {
                Oadty::from_bits(val)
            }
        }
        impl From<Oadty> for u8 {
            #[inline(always)]
            fn from(val: Oadty) -> u8 {
                Oadty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadtyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadtyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadtyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadtyf {
            #[inline(always)]
            fn from(val: u8) -> Oadtyf {
                Oadtyf::from_bits(val)
            }
        }
        impl From<Oadtyf> for u8 {
            #[inline(always)]
            fn from(val: Oadtyf) -> u8 {
                Oadtyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oadtyr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oadtyr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oadtyr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oadtyr {
            #[inline(always)]
            fn from(val: u8) -> Oadtyr {
                Oadtyr::from_bits(val)
            }
        }
        impl From<Oadtyr> for u8 {
            #[inline(always)]
            fn from(val: Oadtyr) -> u8 {
                Oadtyr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oae {
            #[inline(always)]
            fn from(val: u8) -> Oae {
                Oae::from_bits(val)
            }
        }
        impl From<Oae> for u8 {
            #[inline(always)]
            fn from(val: Oae) -> u8 {
                Oae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oahld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oahld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oahld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oahld {
            #[inline(always)]
            fn from(val: u8) -> Oahld {
                Oahld::from_bits(val)
            }
        }
        impl From<Oahld> for u8 {
            #[inline(always)]
            fn from(val: Oahld) -> u8 {
                Oahld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Obdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdf {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdf {
            #[inline(always)]
            fn from(val: u8) -> Obdf {
                Obdf::from_bits(val)
            }
        }
        impl From<Obdf> for u8 {
            #[inline(always)]
            fn from(val: Obdf) -> u8 {
                Obdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdflt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdflt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdflt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdflt {
            #[inline(always)]
            fn from(val: u8) -> Obdflt {
                Obdflt::from_bits(val)
            }
        }
        impl From<Obdflt> for u8 {
            #[inline(always)]
            fn from(val: Obdflt) -> u8 {
                Obdflt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdty {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Obdty {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdty {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdty {
            #[inline(always)]
            fn from(val: u8) -> Obdty {
                Obdty::from_bits(val)
            }
        }
        impl From<Obdty> for u8 {
            #[inline(always)]
            fn from(val: Obdty) -> u8 {
                Obdty::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdtyf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdtyf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdtyf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdtyf {
            #[inline(always)]
            fn from(val: u8) -> Obdtyf {
                Obdtyf::from_bits(val)
            }
        }
        impl From<Obdtyf> for u8 {
            #[inline(always)]
            fn from(val: Obdtyf) -> u8 {
                Obdtyf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obdtyr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obdtyr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obdtyr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obdtyr {
            #[inline(always)]
            fn from(val: u8) -> Obdtyr {
                Obdtyr::from_bits(val)
            }
        }
        impl From<Obdtyr> for u8 {
            #[inline(always)]
            fn from(val: Obdtyr) -> u8 {
                Obdtyr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obe {
            #[inline(always)]
            fn from(val: u8) -> Obe {
                Obe::from_bits(val)
            }
        }
        impl From<Obe> for u8 {
            #[inline(always)]
            fn from(val: Obe) -> u8 {
                Obe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Obhld {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Obhld {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Obhld {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Obhld {
            #[inline(always)]
            fn from(val: u8) -> Obhld {
                Obhld::from_bits(val)
            }
        }
        impl From<Obhld> for u8 {
            #[inline(always)]
            fn from(val: Obhld) -> u8 {
                Obhld::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Odf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Odf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Odf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Odf {
            #[inline(always)]
            fn from(val: u8) -> Odf {
                Odf::from_bits(val)
            }
        }
        impl From<Odf> for u8 {
            #[inline(always)]
            fn from(val: Odf) -> u8 {
                Odf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Pr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pr {
            #[inline(always)]
            fn from(val: u8) -> Pr {
                Pr::from_bits(val)
            }
        }
        impl From<Pr> for u8 {
            #[inline(always)]
            fn from(val: Pr) -> u8 {
                Pr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscafbh {
            #[inline(always)]
            fn from(val: u8) -> Pscafbh {
                Pscafbh::from_bits(val)
            }
        }
        impl From<Pscafbh> for u8 {
            #[inline(always)]
            fn from(val: Pscafbh) -> u8 {
                Pscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscafbl {
            #[inline(always)]
            fn from(val: u8) -> Pscafbl {
                Pscafbl::from_bits(val)
            }
        }
        impl From<Pscafbl> for u8 {
            #[inline(always)]
            fn from(val: Pscafbl) -> u8 {
                Pscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscarbh {
            #[inline(always)]
            fn from(val: u8) -> Pscarbh {
                Pscarbh::from_bits(val)
            }
        }
        impl From<Pscarbh> for u8 {
            #[inline(always)]
            fn from(val: Pscarbh) -> u8 {
                Pscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscarbl {
            #[inline(always)]
            fn from(val: u8) -> Pscarbl {
                Pscarbl::from_bits(val)
            }
        }
        impl From<Pscarbl> for u8 {
            #[inline(always)]
            fn from(val: Pscarbl) -> u8 {
                Pscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbfah {
            #[inline(always)]
            fn from(val: u8) -> Pscbfah {
                Pscbfah::from_bits(val)
            }
        }
        impl From<Pscbfah> for u8 {
            #[inline(always)]
            fn from(val: Pscbfah) -> u8 {
                Pscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbfal {
            #[inline(always)]
            fn from(val: u8) -> Pscbfal {
                Pscbfal::from_bits(val)
            }
        }
        impl From<Pscbfal> for u8 {
            #[inline(always)]
            fn from(val: Pscbfal) -> u8 {
                Pscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbrah {
            #[inline(always)]
            fn from(val: u8) -> Pscbrah {
                Pscbrah::from_bits(val)
            }
        }
        impl From<Pscbrah> for u8 {
            #[inline(always)]
            fn from(val: Pscbrah) -> u8 {
                Pscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pscbral {
            #[inline(always)]
            fn from(val: u8) -> Pscbral {
                Pscbral::from_bits(val)
            }
        }
        impl From<Pscbral> for u8 {
            #[inline(always)]
            fn from(val: Pscbral) -> u8 {
                Pscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselca {
            #[inline(always)]
            fn from(val: u8) -> Pselca {
                Pselca::from_bits(val)
            }
        }
        impl From<Pselca> for u8 {
            #[inline(always)]
            fn from(val: Pselca) -> u8 {
                Pselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcb {
            #[inline(always)]
            fn from(val: u8) -> Pselcb {
                Pselcb::from_bits(val)
            }
        }
        impl From<Pselcb> for u8 {
            #[inline(always)]
            fn from(val: Pselcb) -> u8 {
                Pselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcc {
            #[inline(always)]
            fn from(val: u8) -> Pselcc {
                Pselcc::from_bits(val)
            }
        }
        impl From<Pselcc> for u8 {
            #[inline(always)]
            fn from(val: Pselcc) -> u8 {
                Pselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pselcd {
            #[inline(always)]
            fn from(val: u8) -> Pselcd {
                Pselcd::from_bits(val)
            }
        }
        impl From<Pselcd> for u8 {
            #[inline(always)]
            fn from(val: Pselcd) -> u8 {
                Pselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgaf {
                Psgtrgaf::from_bits(val)
            }
        }
        impl From<Psgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgaf) -> u8 {
                Psgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgar {
                Psgtrgar::from_bits(val)
            }
        }
        impl From<Psgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgar) -> u8 {
                Psgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgbf {
                Psgtrgbf::from_bits(val)
            }
        }
        impl From<Psgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgbf) -> u8 {
                Psgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Psgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Psgtrgbr {
                Psgtrgbr::from_bits(val)
            }
        }
        impl From<Psgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Psgtrgbr) -> u8 {
                Psgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscafbh {
            #[inline(always)]
            fn from(val: u8) -> Sscafbh {
                Sscafbh::from_bits(val)
            }
        }
        impl From<Sscafbh> for u8 {
            #[inline(always)]
            fn from(val: Sscafbh) -> u8 {
                Sscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscafbl {
            #[inline(always)]
            fn from(val: u8) -> Sscafbl {
                Sscafbl::from_bits(val)
            }
        }
        impl From<Sscafbl> for u8 {
            #[inline(always)]
            fn from(val: Sscafbl) -> u8 {
                Sscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscarbh {
            #[inline(always)]
            fn from(val: u8) -> Sscarbh {
                Sscarbh::from_bits(val)
            }
        }
        impl From<Sscarbh> for u8 {
            #[inline(always)]
            fn from(val: Sscarbh) -> u8 {
                Sscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscarbl {
            #[inline(always)]
            fn from(val: u8) -> Sscarbl {
                Sscarbl::from_bits(val)
            }
        }
        impl From<Sscarbl> for u8 {
            #[inline(always)]
            fn from(val: Sscarbl) -> u8 {
                Sscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbfah {
            #[inline(always)]
            fn from(val: u8) -> Sscbfah {
                Sscbfah::from_bits(val)
            }
        }
        impl From<Sscbfah> for u8 {
            #[inline(always)]
            fn from(val: Sscbfah) -> u8 {
                Sscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbfal {
            #[inline(always)]
            fn from(val: u8) -> Sscbfal {
                Sscbfal::from_bits(val)
            }
        }
        impl From<Sscbfal> for u8 {
            #[inline(always)]
            fn from(val: Sscbfal) -> u8 {
                Sscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbrah {
            #[inline(always)]
            fn from(val: u8) -> Sscbrah {
                Sscbrah::from_bits(val)
            }
        }
        impl From<Sscbrah> for u8 {
            #[inline(always)]
            fn from(val: Sscbrah) -> u8 {
                Sscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sscbral {
            #[inline(always)]
            fn from(val: u8) -> Sscbral {
                Sscbral::from_bits(val)
            }
        }
        impl From<Sscbral> for u8 {
            #[inline(always)]
            fn from(val: Sscbral) -> u8 {
                Sscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselca {
            #[inline(always)]
            fn from(val: u8) -> Sselca {
                Sselca::from_bits(val)
            }
        }
        impl From<Sselca> for u8 {
            #[inline(always)]
            fn from(val: Sselca) -> u8 {
                Sselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcb {
            #[inline(always)]
            fn from(val: u8) -> Sselcb {
                Sselcb::from_bits(val)
            }
        }
        impl From<Sselcb> for u8 {
            #[inline(always)]
            fn from(val: Sselcb) -> u8 {
                Sselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcc {
            #[inline(always)]
            fn from(val: u8) -> Sselcc {
                Sselcc::from_bits(val)
            }
        }
        impl From<Sselcc> for u8 {
            #[inline(always)]
            fn from(val: Sselcc) -> u8 {
                Sselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sselcd {
            #[inline(always)]
            fn from(val: u8) -> Sselcd {
                Sselcd::from_bits(val)
            }
        }
        impl From<Sselcd> for u8 {
            #[inline(always)]
            fn from(val: Sselcd) -> u8 {
                Sselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgaf {
                Ssgtrgaf::from_bits(val)
            }
        }
        impl From<Ssgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgaf) -> u8 {
                Ssgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgar {
                Ssgtrgar::from_bits(val)
            }
        }
        impl From<Ssgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgar) -> u8 {
                Ssgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgbf {
                Ssgtrgbf::from_bits(val)
            }
        }
        impl From<Ssgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgbf) -> u8 {
                Ssgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Ssgtrgbr {
                Ssgtrgbr::from_bits(val)
            }
        }
        impl From<Ssgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Ssgtrgbr) -> u8 {
                Ssgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfa {
            #[inline(always)]
            fn from(val: u8) -> Tcfa {
                Tcfa::from_bits(val)
            }
        }
        impl From<Tcfa> for u8 {
            #[inline(always)]
            fn from(val: Tcfa) -> u8 {
                Tcfa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfb {
            #[inline(always)]
            fn from(val: u8) -> Tcfb {
                Tcfb::from_bits(val)
            }
        }
        impl From<Tcfb> for u8 {
            #[inline(always)]
            fn from(val: Tcfb) -> u8 {
                Tcfb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfc {
            #[inline(always)]
            fn from(val: u8) -> Tcfc {
                Tcfc::from_bits(val)
            }
        }
        impl From<Tcfc> for u8 {
            #[inline(always)]
            fn from(val: Tcfc) -> u8 {
                Tcfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfd {
            #[inline(always)]
            fn from(val: u8) -> Tcfd {
                Tcfd::from_bits(val)
            }
        }
        impl From<Tcfd> for u8 {
            #[inline(always)]
            fn from(val: Tcfd) -> u8 {
                Tcfd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfe {
            #[inline(always)]
            fn from(val: u8) -> Tcfe {
                Tcfe::from_bits(val)
            }
        }
        impl From<Tcfe> for u8 {
            #[inline(always)]
            fn from(val: Tcfe) -> u8 {
                Tcfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcff {
            #[inline(always)]
            fn from(val: u8) -> Tcff {
                Tcff::from_bits(val)
            }
        }
        impl From<Tcff> for u8 {
            #[inline(always)]
            fn from(val: Tcff) -> u8 {
                Tcff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfpo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfpo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfpo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfpo {
            #[inline(always)]
            fn from(val: u8) -> Tcfpo {
                Tcfpo::from_bits(val)
            }
        }
        impl From<Tcfpo> for u8 {
            #[inline(always)]
            fn from(val: Tcfpo) -> u8 {
                Tcfpo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tcfpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tcfpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tcfpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tcfpu {
            #[inline(always)]
            fn from(val: u8) -> Tcfpu {
                Tcfpu::from_bits(val)
            }
        }
        impl From<Tcfpu> for u8 {
            #[inline(always)]
            fn from(val: Tcfpu) -> u8 {
                Tcfpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tde {
            #[inline(always)]
            fn from(val: u8) -> Tde {
                Tde::from_bits(val)
            }
        }
        impl From<Tde> for u8 {
            #[inline(always)]
            fn from(val: Tde) -> u8 {
                Tde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tpcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tpcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tpcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tpcs {
            #[inline(always)]
            fn from(val: u8) -> Tpcs {
                Tpcs::from_bits(val)
            }
        }
        impl From<Tpcs> for u8 {
            #[inline(always)]
            fn from(val: Tpcs) -> u8 {
                Tpcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tucf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tucf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tucf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tucf {
            #[inline(always)]
            fn from(val: u8) -> Tucf {
                Tucf::from_bits(val)
            }
        }
        impl From<Tucf> for u8 {
            #[inline(always)]
            fn from(val: Tucf) -> u8 {
                Tucf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ud {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ud {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ud {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ud {
            #[inline(always)]
            fn from(val: u8) -> Ud {
                Ud::from_bits(val)
            }
        }
        impl From<Ud> for u8 {
            #[inline(always)]
            fn from(val: Ud) -> u8 {
                Ud::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Udf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Udf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Udf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Udf {
            #[inline(always)]
            fn from(val: u8) -> Udf {
                Udf::from_bits(val)
            }
        }
        impl From<Udf> for u8 {
            #[inline(always)]
            fn from(val: Udf) -> u8 {
                Udf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscafbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscafbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscafbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscafbh {
            #[inline(always)]
            fn from(val: u8) -> Uscafbh {
                Uscafbh::from_bits(val)
            }
        }
        impl From<Uscafbh> for u8 {
            #[inline(always)]
            fn from(val: Uscafbh) -> u8 {
                Uscafbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscafbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscafbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscafbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscafbl {
            #[inline(always)]
            fn from(val: u8) -> Uscafbl {
                Uscafbl::from_bits(val)
            }
        }
        impl From<Uscafbl> for u8 {
            #[inline(always)]
            fn from(val: Uscafbl) -> u8 {
                Uscafbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscarbh {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscarbh {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscarbh {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscarbh {
            #[inline(always)]
            fn from(val: u8) -> Uscarbh {
                Uscarbh::from_bits(val)
            }
        }
        impl From<Uscarbh> for u8 {
            #[inline(always)]
            fn from(val: Uscarbh) -> u8 {
                Uscarbh::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscarbl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscarbl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscarbl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscarbl {
            #[inline(always)]
            fn from(val: u8) -> Uscarbl {
                Uscarbl::from_bits(val)
            }
        }
        impl From<Uscarbl> for u8 {
            #[inline(always)]
            fn from(val: Uscarbl) -> u8 {
                Uscarbl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbfah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbfah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbfah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbfah {
            #[inline(always)]
            fn from(val: u8) -> Uscbfah {
                Uscbfah::from_bits(val)
            }
        }
        impl From<Uscbfah> for u8 {
            #[inline(always)]
            fn from(val: Uscbfah) -> u8 {
                Uscbfah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbfal {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbfal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbfal {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbfal {
            #[inline(always)]
            fn from(val: u8) -> Uscbfal {
                Uscbfal::from_bits(val)
            }
        }
        impl From<Uscbfal> for u8 {
            #[inline(always)]
            fn from(val: Uscbfal) -> u8 {
                Uscbfal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbrah {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbrah {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbrah {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbrah {
            #[inline(always)]
            fn from(val: u8) -> Uscbrah {
                Uscbrah::from_bits(val)
            }
        }
        impl From<Uscbrah> for u8 {
            #[inline(always)]
            fn from(val: Uscbrah) -> u8 {
                Uscbrah::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uscbral {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uscbral {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uscbral {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uscbral {
            #[inline(always)]
            fn from(val: u8) -> Uscbral {
                Uscbral::from_bits(val)
            }
        }
        impl From<Uscbral> for u8 {
            #[inline(always)]
            fn from(val: Uscbral) -> u8 {
                Uscbral::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselca {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselca {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselca {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselca {
            #[inline(always)]
            fn from(val: u8) -> Uselca {
                Uselca::from_bits(val)
            }
        }
        impl From<Uselca> for u8 {
            #[inline(always)]
            fn from(val: Uselca) -> u8 {
                Uselca::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcb {
            #[inline(always)]
            fn from(val: u8) -> Uselcb {
                Uselcb::from_bits(val)
            }
        }
        impl From<Uselcb> for u8 {
            #[inline(always)]
            fn from(val: Uselcb) -> u8 {
                Uselcb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcc {
            #[inline(always)]
            fn from(val: u8) -> Uselcc {
                Uselcc::from_bits(val)
            }
        }
        impl From<Uselcc> for u8 {
            #[inline(always)]
            fn from(val: Uselcc) -> u8 {
                Uselcc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Uselcd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Uselcd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Uselcd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Uselcd {
            #[inline(always)]
            fn from(val: u8) -> Uselcd {
                Uselcd::from_bits(val)
            }
        }
        impl From<Uselcd> for u8 {
            #[inline(always)]
            fn from(val: Uselcd) -> u8 {
                Uselcd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgaf {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgaf {
                Usgtrgaf::from_bits(val)
            }
        }
        impl From<Usgtrgaf> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgaf) -> u8 {
                Usgtrgaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgar {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgar {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgar {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgar {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgar {
                Usgtrgar::from_bits(val)
            }
        }
        impl From<Usgtrgar> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgar) -> u8 {
                Usgtrgar::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgbf {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgbf {
                Usgtrgbf::from_bits(val)
            }
        }
        impl From<Usgtrgbf> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgbf) -> u8 {
                Usgtrgbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usgtrgbr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Usgtrgbr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usgtrgbr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usgtrgbr {
            #[inline(always)]
            fn from(val: u8) -> Usgtrgbr {
                Usgtrgbr::from_bits(val)
            }
        }
        impl From<Usgtrgbr> for u8 {
            #[inline(always)]
            fn from(val: Usgtrgbr) -> u8 {
                Usgtrgbr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wp {
            #[inline(always)]
            fn from(val: u8) -> Wp {
                Wp::from_bits(val)
            }
        }
        impl From<Wp> for u8 {
            #[inline(always)]
            fn from(val: Wp) -> u8 {
                Wp::to_bits(val)
            }
        }
    }
}
pub mod gpt_ops {
    #[doc = "Output Phase Switching Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GptOps {
        ptr: *mut u8,
    }
    unsafe impl Send for GptOps {}
    unsafe impl Sync for GptOps {}
    impl GptOps {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output Phase Switching Control Register"]
        #[inline(always)]
        pub const fn opscr(self) -> crate::common::Reg<regs::Opscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Output Phase Switching Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opscr(pub u32);
        impl Opscr {
            #[inline(always)]
            pub const fn uf(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_uf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn vf(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_vf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn wf(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_wf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Output Phase Enable"]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::En {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::En::from_bits(val as u8)
            }
            #[doc = "Output Phase Enable"]
            #[inline(always)]
            pub fn set_en(&mut self, val: super::vals::En) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "External Feedback Signal Enable"]
            #[inline(always)]
            pub const fn fb(&self) -> super::vals::Fb {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Fb::from_bits(val as u8)
            }
            #[doc = "External Feedback Signal Enable"]
            #[inline(always)]
            pub fn set_fb(&mut self, val: super::vals::Fb) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Positive,Phase Output (P) Control"]
            #[inline(always)]
            pub const fn p(&self) -> super::vals::P {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::P::from_bits(val as u8)
            }
            #[doc = "Positive,Phase Output (P) Control"]
            #[inline(always)]
            pub fn set_p(&mut self, val: super::vals::P) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Negative,Phase Output (N) Control"]
            #[inline(always)]
            pub const fn n(&self) -> super::vals::N {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::N::from_bits(val as u8)
            }
            #[doc = "Negative,Phase Output (N) Control"]
            #[inline(always)]
            pub fn set_n(&mut self, val: super::vals::N) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Output Phase Invert Control"]
            #[inline(always)]
            pub const fn inv(&self) -> super::vals::Inv {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Inv::from_bits(val as u8)
            }
            #[doc = "Output Phase Invert Control"]
            #[inline(always)]
            pub fn set_inv(&mut self, val: super::vals::Inv) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Output Phase Rotation Direction Reversal Control"]
            #[inline(always)]
            pub const fn rv(&self) -> super::vals::Rv {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Rv::from_bits(val as u8)
            }
            #[doc = "Output Phase Rotation Direction Reversal Control"]
            #[inline(always)]
            pub fn set_rv(&mut self, val: super::vals::Rv) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Input Phase Alignment"]
            #[inline(always)]
            pub const fn align(&self) -> super::vals::Align {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Align::from_bits(val as u8)
            }
            #[doc = "Input Phase Alignment"]
            #[inline(always)]
            pub fn set_align(&mut self, val: super::vals::Align) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Output Disabled Source Selection"]
            #[inline(always)]
            pub const fn grp(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "Output Disabled Source Selection"]
            #[inline(always)]
            pub fn set_grp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
            #[doc = "Group Output Disable Function"]
            #[inline(always)]
            pub const fn godf(&self) -> super::vals::Godf {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Godf::from_bits(val as u8)
            }
            #[doc = "Group Output Disable Function"]
            #[inline(always)]
            pub fn set_godf(&mut self, val: super::vals::Godf) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "External Input Noise Filter Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "External Input Noise Filter Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "External Input Noise Filter Clock Selection"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "External Input Noise Filter Clock Selection"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Opscr {
            #[inline(always)]
            fn default() -> Opscr {
                Opscr(0)
            }
        }
        impl core::fmt::Debug for Opscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opscr")
                    .field("uf", &self.uf())
                    .field("vf", &self.vf())
                    .field("wf", &self.wf())
                    .field("en", &self.en())
                    .field("fb", &self.fb())
                    .field("p", &self.p())
                    .field("n", &self.n())
                    .field("inv", &self.inv())
                    .field("rv", &self.rv())
                    .field("align", &self.align())
                    .field("grp", &self.grp())
                    .field("godf", &self.godf())
                    .field("nfen", &self.nfen())
                    .field("nfcs", &self.nfcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opscr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Opscr {{ uf: {=bool:?}, vf: {=bool:?}, wf: {=bool:?}, en: {:?}, fb: {:?}, p: {:?}, n: {:?}, inv: {:?}, rv: {:?}, align: {:?}, grp: {=u8:?}, godf: {:?}, nfen: {:?}, nfcs: {:?} }}" , self . uf () , self . vf () , self . wf () , self . en () , self . fb () , self . p () , self . n () , self . inv () , self . rv () , self . align () , self . grp () , self . godf () , self . nfen () , self . nfcs ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Align {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Align {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Align {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Align {
            #[inline(always)]
            fn from(val: u8) -> Align {
                Align::from_bits(val)
            }
        }
        impl From<Align> for u8 {
            #[inline(always)]
            fn from(val: Align) -> u8 {
                Align::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum En {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl En {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> En {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for En {
            #[inline(always)]
            fn from(val: u8) -> En {
                En::from_bits(val)
            }
        }
        impl From<En> for u8 {
            #[inline(always)]
            fn from(val: En) -> u8 {
                En::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fb {
            #[inline(always)]
            fn from(val: u8) -> Fb {
                Fb::from_bits(val)
            }
        }
        impl From<Fb> for u8 {
            #[inline(always)]
            fn from(val: Fb) -> u8 {
                Fb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Godf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Godf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Godf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Godf {
            #[inline(always)]
            fn from(val: u8) -> Godf {
                Godf::from_bits(val)
            }
        }
        impl From<Godf> for u8 {
            #[inline(always)]
            fn from(val: Godf) -> u8 {
                Godf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inv {
            #[inline(always)]
            fn from(val: u8) -> Inv {
                Inv::from_bits(val)
            }
        }
        impl From<Inv> for u8 {
            #[inline(always)]
            fn from(val: Inv) -> u8 {
                Inv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum N {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl N {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> N {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for N {
            #[inline(always)]
            fn from(val: u8) -> N {
                N::from_bits(val)
            }
        }
        impl From<N> for u8 {
            #[inline(always)]
            fn from(val: N) -> u8 {
                N::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P {
            #[inline(always)]
            fn from(val: u8) -> P {
                P::from_bits(val)
            }
        }
        impl From<P> for u8 {
            #[inline(always)]
            fn from(val: P) -> u8 {
                P::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rv {
            #[inline(always)]
            fn from(val: u8) -> Rv {
                Rv::from_bits(val)
            }
        }
        impl From<Rv> for u8 {
            #[inline(always)]
            fn from(val: Rv) -> u8 {
                Rv::to_bits(val)
            }
        }
    }
}
pub mod i3c {
    #[doc = "I3C Bus Interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct I3c {
        ptr: *mut u8,
    }
    unsafe impl Send for I3c {}
    unsafe impl Sync for I3c {}
    impl I3c {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Protocol Selection Register"]
        #[inline(always)]
        pub const fn prts(self) -> crate::common::Reg<regs::Prts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Bus Control Register"]
        #[inline(always)]
        pub const fn bctl(self) -> crate::common::Reg<regs::Bctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Master Device Address Register"]
        #[inline(always)]
        pub const fn msdvad(self) -> crate::common::Reg<regs::Msdvad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Reset Control Register"]
        #[inline(always)]
        pub const fn rstctl(self) -> crate::common::Reg<regs::Rstctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Present State Register"]
        #[inline(always)]
        pub const fn prsst(self) -> crate::common::Reg<regs::Prsst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Internal Status Register"]
        #[inline(always)]
        pub const fn inst(self) -> crate::common::Reg<regs::Inst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Internal Status Enable Register"]
        #[inline(always)]
        pub const fn inste(self) -> crate::common::Reg<regs::Inste, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Internal Interrupt Enable Register"]
        #[inline(always)]
        pub const fn inie(self) -> crate::common::Reg<regs::Inie, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Internal Status Force Register"]
        #[inline(always)]
        pub const fn instfc(self) -> crate::common::Reg<regs::Instfc, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Device Characteristic Table Register"]
        #[inline(always)]
        pub const fn dvct(self) -> crate::common::Reg<regs::Dvct, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "IBI Notify Control Register"]
        #[inline(always)]
        pub const fn ibinctl(self) -> crate::common::Reg<regs::Ibinctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "Bus Function Control Register"]
        #[inline(always)]
        pub const fn bfctl(self) -> crate::common::Reg<regs::Bfctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Slave Control Register"]
        #[inline(always)]
        pub const fn svctl(self) -> crate::common::Reg<regs::Svctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "Reference Clock Control Register"]
        #[inline(always)]
        pub const fn refckctl(self) -> crate::common::Reg<regs::Refckctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "Standard Bit Rate Register"]
        #[inline(always)]
        pub const fn stdbr(self) -> crate::common::Reg<regs::Stdbr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "Extended Bit Rate Register"]
        #[inline(always)]
        pub const fn extbr(self) -> crate::common::Reg<regs::Extbr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "Bus Free Condition Detection Time Register"]
        #[inline(always)]
        pub const fn bfrecdt(self) -> crate::common::Reg<regs::Bfrecdt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "Bus Available Condition Detection Time Register"]
        #[inline(always)]
        pub const fn bavlcdt(self) -> crate::common::Reg<regs::Bavlcdt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Bus Idle Condition Detection Time Register"]
        #[inline(always)]
        pub const fn bidlcdt(self) -> crate::common::Reg<regs::Bidlcdt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Output Control Register"]
        #[inline(always)]
        pub const fn outctl(self) -> crate::common::Reg<regs::Outctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Input Control Register"]
        #[inline(always)]
        pub const fn inctl(self) -> crate::common::Reg<regs::Inctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Timeout Control Register"]
        #[inline(always)]
        pub const fn tmoctl(self) -> crate::common::Reg<regs::Tmoctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Acknowledge Control Register"]
        #[inline(always)]
        pub const fn ackctl(self) -> crate::common::Reg<regs::Ackctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "SCL Stretch Control Register"]
        #[inline(always)]
        pub const fn scstrctl(self) -> crate::common::Reg<regs::Scstrctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "SCL Stalling Control Register"]
        #[inline(always)]
        pub const fn scstlctl(self) -> crate::common::Reg<regs::Scstlctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "Slave Transfer Data Length Register 0"]
        #[inline(always)]
        pub const fn svtdlg0(self) -> crate::common::Reg<regs::Svtdlg0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "Condition Control Register"]
        #[inline(always)]
        pub const fn cndctl(self) -> crate::common::Reg<regs::Cndctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "Normal Command Queue Port Register"]
        #[inline(always)]
        pub const fn ncmdqp(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0150usize) as _) }
        }
        #[doc = "Normal Response Queue Port Register"]
        #[inline(always)]
        pub const fn nrspqp(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0154usize) as _) }
        }
        #[doc = "Normal Transfer Data Buffer Port Register 0"]
        #[inline(always)]
        pub const fn ntdtbp0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0158usize) as _) }
        }
        #[doc = "Normal Transfer Data Buffer Port Register 0"]
        #[inline(always)]
        pub const fn ntdtbp0_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0158usize) as _) }
        }
        #[doc = "Normal IBI Queue Port Register"]
        #[inline(always)]
        pub const fn nibiqp(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x017cusize) as _) }
        }
        #[doc = "Normal Receive Status Queue Port Register"]
        #[inline(always)]
        pub const fn nrsqp(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Normal Queue Threshold Control Register"]
        #[inline(always)]
        pub const fn nqthctl(self) -> crate::common::Reg<regs::Nqthctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Normal Transfer Data Buffer Threshold Control Register 0"]
        #[inline(always)]
        pub const fn ntbthctl0(self) -> crate::common::Reg<regs::Ntbthctl0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Normal Receive Status Queue Threshold Control Register"]
        #[inline(always)]
        pub const fn nrqthctl(self) -> crate::common::Reg<regs::Nrqthctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "Bus Status Register"]
        #[inline(always)]
        pub const fn bst(self) -> crate::common::Reg<regs::Bst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d0usize) as _) }
        }
        #[doc = "Bus Status Enable Register"]
        #[inline(always)]
        pub const fn bste(self) -> crate::common::Reg<regs::Bste, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d4usize) as _) }
        }
        #[doc = "Bus Interrupt Enable Register"]
        #[inline(always)]
        pub const fn bie(self) -> crate::common::Reg<regs::Bie, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d8usize) as _) }
        }
        #[doc = "Bus Status Force Register"]
        #[inline(always)]
        pub const fn bstfc(self) -> crate::common::Reg<regs::Bstfc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01dcusize) as _) }
        }
        #[doc = "Normal Transfer Status Register"]
        #[inline(always)]
        pub const fn ntst(self) -> crate::common::Reg<regs::Ntst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e0usize) as _) }
        }
        #[doc = "Normal Transfer Status Enable Register"]
        #[inline(always)]
        pub const fn ntste(self) -> crate::common::Reg<regs::Ntste, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e4usize) as _) }
        }
        #[doc = "Normal Transfer Interrupt Enable Register"]
        #[inline(always)]
        pub const fn ntie(self) -> crate::common::Reg<regs::Ntie, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01e8usize) as _) }
        }
        #[doc = "Normal Transfer Status Force Register"]
        #[inline(always)]
        pub const fn ntstfc(self) -> crate::common::Reg<regs::Ntstfc, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01ecusize) as _) }
        }
        #[doc = "Bus Condition Status Register"]
        #[inline(always)]
        pub const fn bcst(self) -> crate::common::Reg<regs::Bcst, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0210usize) as _) }
        }
        #[doc = "Slave Status Register"]
        #[inline(always)]
        pub const fn svst(self) -> crate::common::Reg<regs::Svst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0214usize) as _) }
        }
        #[doc = "Device Address Table Basic Register %s"]
        #[inline(always)]
        pub const fn datbas(self, n: usize) -> crate::common::Reg<regs::Datbas, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0224usize + n * 8usize) as _) }
        }
        #[doc = "Extended Device Address Table Basic Register"]
        #[inline(always)]
        pub const fn exdatbas(self) -> crate::common::Reg<regs::Exdatbas, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02a0usize) as _) }
        }
        #[doc = "Slave Device Address Table Basic Register 0"]
        #[inline(always)]
        pub const fn sdatbas0(self) -> crate::common::Reg<regs::Sdatbas0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02b0usize) as _) }
        }
        #[doc = "Master Device Characteristic Table Register %s"]
        #[inline(always)]
        pub const fn msdct(self, n: usize) -> crate::common::Reg<regs::Msdct, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02d0usize + n * 4usize) as _) }
        }
        #[doc = "Slave Device Characteristic Table Register"]
        #[inline(always)]
        pub const fn svdct(self) -> crate::common::Reg<regs::Svdct, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0320usize) as _) }
        }
        #[doc = "Slave Device Characteristic Table Provisional ID Low Register"]
        #[inline(always)]
        pub const fn sdctpidl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0324usize) as _) }
        }
        #[doc = "Slave Device Characteristic Table Provisional ID High Register"]
        #[inline(always)]
        pub const fn sdctpidh(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0328usize) as _) }
        }
        #[doc = "Slave Device Address Register 0"]
        #[inline(always)]
        pub const fn svdvad0(self) -> crate::common::Reg<regs::Svdvad0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "CCC Slave Events Command Register"]
        #[inline(always)]
        pub const fn csecmd(self) -> crate::common::Reg<regs::Csecmd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0350usize) as _) }
        }
        #[doc = "CCC Enter Activity State Register"]
        #[inline(always)]
        pub const fn ceactst(self) -> crate::common::Reg<regs::Ceactst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0354usize) as _) }
        }
        #[doc = "CCC Max Write Length Register"]
        #[inline(always)]
        pub const fn cmwlg(self) -> crate::common::Reg<regs::Cmwlg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0358usize) as _) }
        }
        #[doc = "CCC Max Read Length Register"]
        #[inline(always)]
        pub const fn cmrlg(self) -> crate::common::Reg<regs::Cmrlg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x035cusize) as _) }
        }
        #[doc = "CCC Enter Test Mode Register"]
        #[inline(always)]
        pub const fn cetstmd(self) -> crate::common::Reg<regs::Cetstmd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0360usize) as _) }
        }
        #[doc = "CCC Get Device Status Register"]
        #[inline(always)]
        pub const fn cgdvst(self) -> crate::common::Reg<regs::Cgdvst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0364usize) as _) }
        }
        #[doc = "CCC Max Data Speed W (Write) Register"]
        #[inline(always)]
        pub const fn cmdspw(self) -> crate::common::Reg<regs::Cmdspw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0368usize) as _) }
        }
        #[doc = "CCC Max Data Speed R (Read) Register"]
        #[inline(always)]
        pub const fn cmdspr(self) -> crate::common::Reg<regs::Cmdspr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x036cusize) as _) }
        }
        #[doc = "CCC Max Data Speed T (Turnaround) Register"]
        #[inline(always)]
        pub const fn cmdspt(self) -> crate::common::Reg<regs::Cmdspt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0370usize) as _) }
        }
        #[doc = "CCC Exchange Timing Support Information M (Mode) Register"]
        #[inline(always)]
        pub const fn cetsm(self) -> crate::common::Reg<regs::Cetsm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0374usize) as _) }
        }
        #[doc = "Bit Count Register"]
        #[inline(always)]
        pub const fn bitcnt(self) -> crate::common::Reg<regs::Bitcnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0380usize) as _) }
        }
        #[doc = "Normal Queue Status Level Register"]
        #[inline(always)]
        pub const fn nqstlv(self) -> crate::common::Reg<regs::Nqstlv, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0394usize) as _) }
        }
        #[doc = "Normal Data Buffer Status Level Register 0"]
        #[inline(always)]
        pub const fn ndbstlv0(self) -> crate::common::Reg<regs::Ndbstlv0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0398usize) as _) }
        }
        #[doc = "Normal Receive Status Queue Status Level Register"]
        #[inline(always)]
        pub const fn nrsqstlv(self) -> crate::common::Reg<regs::Nrsqstlv, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03c0usize) as _) }
        }
        #[doc = "Present State Debug Register"]
        #[inline(always)]
        pub const fn prstdbg(self) -> crate::common::Reg<regs::Prstdbg, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03ccusize) as _) }
        }
        #[doc = "Master Error Counters Register"]
        #[inline(always)]
        pub const fn mserrcnt(self) -> crate::common::Reg<regs::Mserrcnt, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03d0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Acknowledge Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ackctl(pub u32);
        impl Ackctl {
            #[doc = "Acknowledge Reception"]
            #[inline(always)]
            pub const fn ackr(&self) -> super::vals::Ackr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ackr::from_bits(val as u8)
            }
            #[doc = "Acknowledge Reception"]
            #[inline(always)]
            pub fn set_ackr(&mut self, val: super::vals::Ackr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Acknowledge Transmission"]
            #[inline(always)]
            pub const fn ackt(&self) -> super::vals::Ackt {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ackt::from_bits(val as u8)
            }
            #[doc = "Acknowledge Transmission"]
            #[inline(always)]
            pub fn set_ackt(&mut self, val: super::vals::Ackt) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "ACKT Write Protect"]
            #[inline(always)]
            pub const fn acktwp(&self) -> super::vals::Acktwp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Acktwp::from_bits(val as u8)
            }
            #[doc = "ACKT Write Protect"]
            #[inline(always)]
            pub fn set_acktwp(&mut self, val: super::vals::Acktwp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Ackctl {
            #[inline(always)]
            fn default() -> Ackctl {
                Ackctl(0)
            }
        }
        impl core::fmt::Debug for Ackctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ackctl")
                    .field("ackr", &self.ackr())
                    .field("ackt", &self.ackt())
                    .field("acktwp", &self.acktwp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ackctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ackctl {{ ackr: {:?}, ackt: {:?}, acktwp: {:?} }}",
                    self.ackr(),
                    self.ackt(),
                    self.acktwp()
                )
            }
        }
        #[doc = "Bus Available Condition Detection Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bavlcdt(pub u32);
        impl Bavlcdt {
            #[doc = "Bus Available Condition Detection Cycle"]
            #[inline(always)]
            pub const fn avlcyc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Bus Available Condition Detection Cycle"]
            #[inline(always)]
            pub fn set_avlcyc(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Bavlcdt {
            #[inline(always)]
            fn default() -> Bavlcdt {
                Bavlcdt(0)
            }
        }
        impl core::fmt::Debug for Bavlcdt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bavlcdt")
                    .field("avlcyc", &self.avlcyc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bavlcdt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bavlcdt {{ avlcyc: {=u16:?} }}", self.avlcyc())
            }
        }
        #[doc = "Bus Condition Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bcst(pub u32);
        impl Bcst {
            #[doc = "Bus Free Detection Flag"]
            #[inline(always)]
            pub const fn bfref(&self) -> super::vals::Bfref {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bfref::from_bits(val as u8)
            }
            #[doc = "Bus Free Detection Flag"]
            #[inline(always)]
            pub fn set_bfref(&mut self, val: super::vals::Bfref) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Bus Available Detection Flag"]
            #[inline(always)]
            pub const fn bavlf(&self) -> super::vals::Bavlf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Bavlf::from_bits(val as u8)
            }
            #[doc = "Bus Available Detection Flag"]
            #[inline(always)]
            pub fn set_bavlf(&mut self, val: super::vals::Bavlf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Bus Idle Detection Flag"]
            #[inline(always)]
            pub const fn bidlf(&self) -> super::vals::Bidlf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Bidlf::from_bits(val as u8)
            }
            #[doc = "Bus Idle Detection Flag"]
            #[inline(always)]
            pub fn set_bidlf(&mut self, val: super::vals::Bidlf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Bcst {
            #[inline(always)]
            fn default() -> Bcst {
                Bcst(0)
            }
        }
        impl core::fmt::Debug for Bcst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bcst")
                    .field("bfref", &self.bfref())
                    .field("bavlf", &self.bavlf())
                    .field("bidlf", &self.bidlf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bcst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bcst {{ bfref: {:?}, bavlf: {:?}, bidlf: {:?} }}",
                    self.bfref(),
                    self.bavlf(),
                    self.bidlf()
                )
            }
        }
        #[doc = "Bus Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bctl(pub u32);
        impl Bctl {
            #[doc = "Include I3C Broadcast Address"]
            #[inline(always)]
            pub const fn incba(&self) -> super::vals::Incba {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Incba::from_bits(val as u8)
            }
            #[doc = "Include I3C Broadcast Address"]
            #[inline(always)]
            pub fn set_incba(&mut self, val: super::vals::Incba) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Hot,Join Acknowledge Control"]
            #[inline(always)]
            pub const fn hjackctl(&self) -> super::vals::Hjackctl {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Hjackctl::from_bits(val as u8)
            }
            #[doc = "Hot,Join Acknowledge Control"]
            #[inline(always)]
            pub fn set_hjackctl(&mut self, val: super::vals::Hjackctl) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Abort"]
            #[inline(always)]
            pub const fn abt(&self) -> super::vals::Abt {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Abt::from_bits(val as u8)
            }
            #[doc = "Abort"]
            #[inline(always)]
            pub fn set_abt(&mut self, val: super::vals::Abt) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Resume"]
            #[inline(always)]
            pub const fn rsm(&self) -> super::vals::Rsm {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Rsm::from_bits(val as u8)
            }
            #[doc = "Resume"]
            #[inline(always)]
            pub fn set_rsm(&mut self, val: super::vals::Rsm) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Bus Enable"]
            #[inline(always)]
            pub const fn buse(&self) -> super::vals::Buse {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Buse::from_bits(val as u8)
            }
            #[doc = "Bus Enable"]
            #[inline(always)]
            pub fn set_buse(&mut self, val: super::vals::Buse) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Bctl {
            #[inline(always)]
            fn default() -> Bctl {
                Bctl(0)
            }
        }
        impl core::fmt::Debug for Bctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bctl")
                    .field("incba", &self.incba())
                    .field("hjackctl", &self.hjackctl())
                    .field("abt", &self.abt())
                    .field("rsm", &self.rsm())
                    .field("buse", &self.buse())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bctl {{ incba: {:?}, hjackctl: {:?}, abt: {:?}, rsm: {:?}, buse: {:?} }}",
                    self.incba(),
                    self.hjackctl(),
                    self.abt(),
                    self.rsm(),
                    self.buse()
                )
            }
        }
        #[doc = "Bus Function Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bfctl(pub u32);
        impl Bfctl {
            #[doc = "Master Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn male(&self) -> super::vals::Male {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Male::from_bits(val as u8)
            }
            #[doc = "Master Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_male(&mut self, val: super::vals::Male) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK Transmission Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn nale(&self) -> super::vals::Nale {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Nale::from_bits(val as u8)
            }
            #[doc = "NACK Transmission Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_nale(&mut self, val: super::vals::Nale) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Slave Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub const fn sale(&self) -> super::vals::Sale {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sale::from_bits(val as u8)
            }
            #[doc = "Slave Arbitration,Lost Detection Enable"]
            #[inline(always)]
            pub fn set_sale(&mut self, val: super::vals::Sale) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "SCL Synchronous Circuit Enable"]
            #[inline(always)]
            pub const fn scsyne(&self) -> super::vals::Scsyne {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Scsyne::from_bits(val as u8)
            }
            #[doc = "SCL Synchronous Circuit Enable"]
            #[inline(always)]
            pub fn set_scsyne(&mut self, val: super::vals::Scsyne) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "SMBus/I2C Bus Selection"]
            #[inline(always)]
            pub const fn smbs(&self) -> super::vals::Smbs {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Smbs::from_bits(val as u8)
            }
            #[doc = "SMBus/I2C Bus Selection"]
            #[inline(always)]
            pub fn set_smbs(&mut self, val: super::vals::Smbs) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Fast,mode Plus Enable"]
            #[inline(always)]
            pub const fn fmpe(&self) -> super::vals::Fmpe {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Fmpe::from_bits(val as u8)
            }
            #[doc = "Fast,mode Plus Enable"]
            #[inline(always)]
            pub fn set_fmpe(&mut self, val: super::vals::Fmpe) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "High Speed Mode Enable"]
            #[inline(always)]
            pub const fn hsme(&self) -> super::vals::Hsme {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Hsme::from_bits(val as u8)
            }
            #[doc = "High Speed Mode Enable"]
            #[inline(always)]
            pub fn set_hsme(&mut self, val: super::vals::Hsme) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Bfctl {
            #[inline(always)]
            fn default() -> Bfctl {
                Bfctl(0)
            }
        }
        impl core::fmt::Debug for Bfctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bfctl")
                    .field("male", &self.male())
                    .field("nale", &self.nale())
                    .field("sale", &self.sale())
                    .field("scsyne", &self.scsyne())
                    .field("smbs", &self.smbs())
                    .field("fmpe", &self.fmpe())
                    .field("hsme", &self.hsme())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bfctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bfctl {{ male: {:?}, nale: {:?}, sale: {:?}, scsyne: {:?}, smbs: {:?}, fmpe: {:?}, hsme: {:?} }}" , self . male () , self . nale () , self . sale () , self . scsyne () , self . smbs () , self . fmpe () , self . hsme ())
            }
        }
        #[doc = "Bus Free Condition Detection Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bfrecdt(pub u32);
        impl Bfrecdt {
            #[doc = "Bus Free Condition Detection Cycle"]
            #[inline(always)]
            pub const fn frecyc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Bus Free Condition Detection Cycle"]
            #[inline(always)]
            pub fn set_frecyc(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Bfrecdt {
            #[inline(always)]
            fn default() -> Bfrecdt {
                Bfrecdt(0)
            }
        }
        impl core::fmt::Debug for Bfrecdt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bfrecdt")
                    .field("frecyc", &self.frecyc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bfrecdt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bfrecdt {{ frecyc: {=u16:?} }}", self.frecyc())
            }
        }
        #[doc = "Bus Idle Condition Detection Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bidlcdt(pub u32);
        impl Bidlcdt {
            #[doc = "Bus Idle Condition Detection Cycle"]
            #[inline(always)]
            pub const fn idlcyc(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0003_ffff;
                val as u32
            }
            #[doc = "Bus Idle Condition Detection Cycle"]
            #[inline(always)]
            pub fn set_idlcyc(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0003_ffff << 0usize)) | (((val as u32) & 0x0003_ffff) << 0usize);
            }
        }
        impl Default for Bidlcdt {
            #[inline(always)]
            fn default() -> Bidlcdt {
                Bidlcdt(0)
            }
        }
        impl core::fmt::Debug for Bidlcdt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bidlcdt")
                    .field("idlcyc", &self.idlcyc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bidlcdt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bidlcdt {{ idlcyc: {=u32:?} }}", self.idlcyc())
            }
        }
        #[doc = "Bus Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bie(pub u32);
        impl Bie {
            #[doc = "START Condition Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn stcnddie(&self) -> super::vals::Stcnddie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Stcnddie::from_bits(val as u8)
            }
            #[doc = "START Condition Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_stcnddie(&mut self, val: super::vals::Stcnddie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "STOP Condition Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn spcnddie(&self) -> super::vals::Spcnddie {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spcnddie::from_bits(val as u8)
            }
            #[doc = "STOP Condition Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_spcnddie(&mut self, val: super::vals::Spcnddie) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "HDR Exit Pattern Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn hdrexdie(&self) -> super::vals::Hdrexdie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Hdrexdie::from_bits(val as u8)
            }
            #[doc = "HDR Exit Pattern Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_hdrexdie(&mut self, val: super::vals::Hdrexdie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "NACK Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn nackdie(&self) -> super::vals::Nackdie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nackdie::from_bits(val as u8)
            }
            #[doc = "NACK Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_nackdie(&mut self, val: super::vals::Nackdie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn tendie(&self) -> super::vals::Tendie {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Tendie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_tendie(&mut self, val: super::vals::Tendie) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Arbitration Lost Interrupt Enable"]
            #[inline(always)]
            pub const fn alie(&self) -> super::vals::Alie {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Alie::from_bits(val as u8)
            }
            #[doc = "Arbitration Lost Interrupt Enable"]
            #[inline(always)]
            pub fn set_alie(&mut self, val: super::vals::Alie) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Timeout Detection Interrupt Enable"]
            #[inline(always)]
            pub const fn todie(&self) -> super::vals::Todie {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Todie::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Interrupt Enable"]
            #[inline(always)]
            pub fn set_todie(&mut self, val: super::vals::Todie) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Bie {
            #[inline(always)]
            fn default() -> Bie {
                Bie(0)
            }
        }
        impl core::fmt::Debug for Bie {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bie")
                    .field("stcnddie", &self.stcnddie())
                    .field("spcnddie", &self.spcnddie())
                    .field("hdrexdie", &self.hdrexdie())
                    .field("nackdie", &self.nackdie())
                    .field("tendie", &self.tendie())
                    .field("alie", &self.alie())
                    .field("todie", &self.todie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bie {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bie {{ stcnddie: {:?}, spcnddie: {:?}, hdrexdie: {:?}, nackdie: {:?}, tendie: {:?}, alie: {:?}, todie: {:?} }}" , self . stcnddie () , self . spcnddie () , self . hdrexdie () , self . nackdie () , self . tendie () , self . alie () , self . todie ())
            }
        }
        #[doc = "Bit Count Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bitcnt(pub u32);
        impl Bitcnt {
            #[doc = "Bit Counter"]
            #[inline(always)]
            pub const fn bcnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Bit Counter"]
            #[inline(always)]
            pub fn set_bcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Bitcnt {
            #[inline(always)]
            fn default() -> Bitcnt {
                Bitcnt(0)
            }
        }
        impl core::fmt::Debug for Bitcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bitcnt")
                    .field("bcnt", &self.bcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bitcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bitcnt {{ bcnt: {=u8:?} }}", self.bcnt())
            }
        }
        #[doc = "Bus Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bst(pub u32);
        impl Bst {
            #[doc = "START Condition Detection Flag"]
            #[inline(always)]
            pub const fn stcnddf(&self) -> super::vals::Stcnddf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Stcnddf::from_bits(val as u8)
            }
            #[doc = "START Condition Detection Flag"]
            #[inline(always)]
            pub fn set_stcnddf(&mut self, val: super::vals::Stcnddf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "STOP Condition Detection Flag"]
            #[inline(always)]
            pub const fn spcnddf(&self) -> super::vals::Spcnddf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spcnddf::from_bits(val as u8)
            }
            #[doc = "STOP Condition Detection Flag"]
            #[inline(always)]
            pub fn set_spcnddf(&mut self, val: super::vals::Spcnddf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "HDR Exit Pattern Detection Flag"]
            #[inline(always)]
            pub const fn hdrexdf(&self) -> super::vals::Hdrexdf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Hdrexdf::from_bits(val as u8)
            }
            #[doc = "HDR Exit Pattern Detection Flag"]
            #[inline(always)]
            pub fn set_hdrexdf(&mut self, val: super::vals::Hdrexdf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "NACK Detection Flag"]
            #[inline(always)]
            pub const fn nackdf(&self) -> super::vals::Nackdf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nackdf::from_bits(val as u8)
            }
            #[doc = "NACK Detection Flag"]
            #[inline(always)]
            pub fn set_nackdf(&mut self, val: super::vals::Nackdf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tendf(&self) -> super::vals::Tendf {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Tendf::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tendf(&mut self, val: super::vals::Tendf) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Arbitration Lost Flag"]
            #[inline(always)]
            pub const fn alf(&self) -> super::vals::Alf {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Alf::from_bits(val as u8)
            }
            #[doc = "Arbitration Lost Flag"]
            #[inline(always)]
            pub fn set_alf(&mut self, val: super::vals::Alf) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Timeout Detection Flag"]
            #[inline(always)]
            pub const fn todf(&self) -> super::vals::Todf {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Todf::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Flag"]
            #[inline(always)]
            pub fn set_todf(&mut self, val: super::vals::Todf) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Bst {
            #[inline(always)]
            fn default() -> Bst {
                Bst(0)
            }
        }
        impl core::fmt::Debug for Bst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bst")
                    .field("stcnddf", &self.stcnddf())
                    .field("spcnddf", &self.spcnddf())
                    .field("hdrexdf", &self.hdrexdf())
                    .field("nackdf", &self.nackdf())
                    .field("tendf", &self.tendf())
                    .field("alf", &self.alf())
                    .field("todf", &self.todf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bst {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bst {{ stcnddf: {:?}, spcnddf: {:?}, hdrexdf: {:?}, nackdf: {:?}, tendf: {:?}, alf: {:?}, todf: {:?} }}" , self . stcnddf () , self . spcnddf () , self . hdrexdf () , self . nackdf () , self . tendf () , self . alf () , self . todf ())
            }
        }
        #[doc = "Bus Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bste(pub u32);
        impl Bste {
            #[doc = "START Condition Detection Enable"]
            #[inline(always)]
            pub const fn stcndde(&self) -> super::vals::Stcndde {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Stcndde::from_bits(val as u8)
            }
            #[doc = "START Condition Detection Enable"]
            #[inline(always)]
            pub fn set_stcndde(&mut self, val: super::vals::Stcndde) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "STOP Condition Detection Enable"]
            #[inline(always)]
            pub const fn spcndde(&self) -> super::vals::Spcndde {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spcndde::from_bits(val as u8)
            }
            #[doc = "STOP Condition Detection Enable"]
            #[inline(always)]
            pub fn set_spcndde(&mut self, val: super::vals::Spcndde) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "HDR Exit Pattern Detection Enable"]
            #[inline(always)]
            pub const fn hdrexde(&self) -> super::vals::Hdrexde {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Hdrexde::from_bits(val as u8)
            }
            #[doc = "HDR Exit Pattern Detection Enable"]
            #[inline(always)]
            pub fn set_hdrexde(&mut self, val: super::vals::Hdrexde) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "NACK Detection Enable"]
            #[inline(always)]
            pub const fn nackde(&self) -> super::vals::Nackde {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nackde::from_bits(val as u8)
            }
            #[doc = "NACK Detection Enable"]
            #[inline(always)]
            pub fn set_nackde(&mut self, val: super::vals::Nackde) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Transmit End Enable"]
            #[inline(always)]
            pub const fn tende(&self) -> super::vals::Tende {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Tende::from_bits(val as u8)
            }
            #[doc = "Transmit End Enable"]
            #[inline(always)]
            pub fn set_tende(&mut self, val: super::vals::Tende) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Arbitration Lost Enable"]
            #[inline(always)]
            pub const fn ale(&self) -> super::vals::Ale {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Ale::from_bits(val as u8)
            }
            #[doc = "Arbitration Lost Enable"]
            #[inline(always)]
            pub fn set_ale(&mut self, val: super::vals::Ale) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Timeout Detection Enable"]
            #[inline(always)]
            pub const fn tode(&self) -> super::vals::Tode {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Tode::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Enable"]
            #[inline(always)]
            pub fn set_tode(&mut self, val: super::vals::Tode) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Bste {
            #[inline(always)]
            fn default() -> Bste {
                Bste(0)
            }
        }
        impl core::fmt::Debug for Bste {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bste")
                    .field("stcndde", &self.stcndde())
                    .field("spcndde", &self.spcndde())
                    .field("hdrexde", &self.hdrexde())
                    .field("nackde", &self.nackde())
                    .field("tende", &self.tende())
                    .field("ale", &self.ale())
                    .field("tode", &self.tode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bste {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bste {{ stcndde: {:?}, spcndde: {:?}, hdrexde: {:?}, nackde: {:?}, tende: {:?}, ale: {:?}, tode: {:?} }}" , self . stcndde () , self . spcndde () , self . hdrexde () , self . nackde () , self . tende () , self . ale () , self . tode ())
            }
        }
        #[doc = "Bus Status Force Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bstfc(pub u32);
        impl Bstfc {
            #[doc = "START condition Detection Force"]
            #[inline(always)]
            pub const fn stcnddfc(&self) -> super::vals::Stcnddfc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Stcnddfc::from_bits(val as u8)
            }
            #[doc = "START condition Detection Force"]
            #[inline(always)]
            pub fn set_stcnddfc(&mut self, val: super::vals::Stcnddfc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "STOP condition Detection Force"]
            #[inline(always)]
            pub const fn spcnddfc(&self) -> super::vals::Spcnddfc {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spcnddfc::from_bits(val as u8)
            }
            #[doc = "STOP condition Detection Force"]
            #[inline(always)]
            pub fn set_spcnddfc(&mut self, val: super::vals::Spcnddfc) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "HDR Exit Pattern Detection Force"]
            #[inline(always)]
            pub const fn hdrexdfc(&self) -> super::vals::Hdrexdfc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Hdrexdfc::from_bits(val as u8)
            }
            #[doc = "HDR Exit Pattern Detection Force"]
            #[inline(always)]
            pub fn set_hdrexdfc(&mut self, val: super::vals::Hdrexdfc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "NACK Detection Force"]
            #[inline(always)]
            pub const fn nackdfc(&self) -> super::vals::Nackdfc {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Nackdfc::from_bits(val as u8)
            }
            #[doc = "NACK Detection Force"]
            #[inline(always)]
            pub fn set_nackdfc(&mut self, val: super::vals::Nackdfc) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Transmit End Force"]
            #[inline(always)]
            pub const fn tendfc(&self) -> super::vals::Tendfc {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Tendfc::from_bits(val as u8)
            }
            #[doc = "Transmit End Force"]
            #[inline(always)]
            pub fn set_tendfc(&mut self, val: super::vals::Tendfc) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Arbitration Lost Force"]
            #[inline(always)]
            pub const fn alfc(&self) -> super::vals::Alfc {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Alfc::from_bits(val as u8)
            }
            #[doc = "Arbitration Lost Force"]
            #[inline(always)]
            pub fn set_alfc(&mut self, val: super::vals::Alfc) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Timeout Detection Force"]
            #[inline(always)]
            pub const fn todfc(&self) -> super::vals::Todfc {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Todfc::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Force"]
            #[inline(always)]
            pub fn set_todfc(&mut self, val: super::vals::Todfc) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Bstfc {
            #[inline(always)]
            fn default() -> Bstfc {
                Bstfc(0)
            }
        }
        impl core::fmt::Debug for Bstfc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bstfc")
                    .field("stcnddfc", &self.stcnddfc())
                    .field("spcnddfc", &self.spcnddfc())
                    .field("hdrexdfc", &self.hdrexdfc())
                    .field("nackdfc", &self.nackdfc())
                    .field("tendfc", &self.tendfc())
                    .field("alfc", &self.alfc())
                    .field("todfc", &self.todfc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bstfc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bstfc {{ stcnddfc: {:?}, spcnddfc: {:?}, hdrexdfc: {:?}, nackdfc: {:?}, tendfc: {:?}, alfc: {:?}, todfc: {:?} }}" , self . stcnddfc () , self . spcnddfc () , self . hdrexdfc () , self . nackdfc () , self . tendfc () , self . alfc () , self . todfc ())
            }
        }
        #[doc = "CCC Enter Activity State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ceactst(pub u32);
        impl Ceactst {
            #[doc = "Activity State"]
            #[inline(always)]
            pub const fn actst(&self) -> super::vals::Actst {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Actst::from_bits(val as u8)
            }
            #[doc = "Activity State"]
            #[inline(always)]
            pub fn set_actst(&mut self, val: super::vals::Actst) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Ceactst {
            #[inline(always)]
            fn default() -> Ceactst {
                Ceactst(0)
            }
        }
        impl core::fmt::Debug for Ceactst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ceactst")
                    .field("actst", &self.actst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ceactst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ceactst {{ actst: {:?} }}", self.actst())
            }
        }
        #[doc = "CCC Exchange Timing Support Information M (Mode) Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cetsm(pub u32);
        impl Cetsm {
            #[doc = "Frequency Byte"]
            #[inline(always)]
            pub const fn freq(&self) -> super::vals::Freq {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::Freq::from_bits(val as u8)
            }
            #[doc = "Frequency Byte"]
            #[inline(always)]
            pub fn set_freq(&mut self, val: super::vals::Freq) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u32) & 0xff) << 8usize);
            }
            #[doc = "Inaccuracy Byte"]
            #[inline(always)]
            pub const fn inac(&self) -> super::vals::Inac {
                let val = (self.0 >> 16usize) & 0xff;
                super::vals::Inac::from_bits(val as u8)
            }
            #[doc = "Inaccuracy Byte"]
            #[inline(always)]
            pub fn set_inac(&mut self, val: super::vals::Inac) {
                self.0 =
                    (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Cetsm {
            #[inline(always)]
            fn default() -> Cetsm {
                Cetsm(0)
            }
        }
        impl core::fmt::Debug for Cetsm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cetsm")
                    .field("freq", &self.freq())
                    .field("inac", &self.inac())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cetsm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cetsm {{ freq: {:?}, inac: {:?} }}",
                    self.freq(),
                    self.inac()
                )
            }
        }
        #[doc = "CCC Enter Test Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cetstmd(pub u32);
        impl Cetstmd {
            #[doc = "Test Mode"]
            #[inline(always)]
            pub const fn tstmd(&self) -> super::vals::Tstmd {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Tstmd::from_bits(val as u8)
            }
            #[doc = "Test Mode"]
            #[inline(always)]
            pub fn set_tstmd(&mut self, val: super::vals::Tstmd) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Cetstmd {
            #[inline(always)]
            fn default() -> Cetstmd {
                Cetstmd(0)
            }
        }
        impl core::fmt::Debug for Cetstmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cetstmd")
                    .field("tstmd", &self.tstmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cetstmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cetstmd {{ tstmd: {:?} }}", self.tstmd())
            }
        }
        #[doc = "CCC Get Device Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cgdvst(pub u32);
        impl Cgdvst {
            #[doc = "Pending Interrupt"]
            #[inline(always)]
            pub const fn pndint(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Pending Interrupt"]
            #[inline(always)]
            pub fn set_pndint(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Protocol Error"]
            #[inline(always)]
            pub const fn prte(&self) -> super::vals::Prte {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Prte::from_bits(val as u8)
            }
            #[doc = "Protocol Error"]
            #[inline(always)]
            pub fn set_prte(&mut self, val: super::vals::Prte) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Slave Devices current Activity Mode"]
            #[inline(always)]
            pub const fn actmd(&self) -> super::vals::Actmd {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Actmd::from_bits(val as u8)
            }
            #[doc = "Slave Devices current Activity Mode"]
            #[inline(always)]
            pub fn set_actmd(&mut self, val: super::vals::Actmd) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
            #[doc = "Vendor Reserved"]
            #[inline(always)]
            pub const fn vdrsv(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Vendor Reserved"]
            #[inline(always)]
            pub fn set_vdrsv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Cgdvst {
            #[inline(always)]
            fn default() -> Cgdvst {
                Cgdvst(0)
            }
        }
        impl core::fmt::Debug for Cgdvst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cgdvst")
                    .field("pndint", &self.pndint())
                    .field("prte", &self.prte())
                    .field("actmd", &self.actmd())
                    .field("vdrsv", &self.vdrsv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cgdvst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cgdvst {{ pndint: {=u8:?}, prte: {:?}, actmd: {:?}, vdrsv: {=u8:?} }}",
                    self.pndint(),
                    self.prte(),
                    self.actmd(),
                    self.vdrsv()
                )
            }
        }
        #[doc = "CCC Max Data Speed R (Read) Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmdspr(pub u32);
        impl Cmdspr {
            #[doc = "Maximum Sustained Read Data Rate"]
            #[inline(always)]
            pub const fn msrdr(&self) -> super::vals::Msrdr {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Msrdr::from_bits(val as u8)
            }
            #[doc = "Maximum Sustained Read Data Rate"]
            #[inline(always)]
            pub fn set_msrdr(&mut self, val: super::vals::Msrdr) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Clock to Data Turnaround Time (TSCO)"]
            #[inline(always)]
            pub const fn cdttim(&self) -> super::vals::Cdttim {
                let val = (self.0 >> 3usize) & 0x07;
                super::vals::Cdttim::from_bits(val as u8)
            }
            #[doc = "Clock to Data Turnaround Time (TSCO)"]
            #[inline(always)]
            pub fn set_cdttim(&mut self, val: super::vals::Cdttim) {
                self.0 = (self.0 & !(0x07 << 3usize)) | (((val.to_bits() as u32) & 0x07) << 3usize);
            }
        }
        impl Default for Cmdspr {
            #[inline(always)]
            fn default() -> Cmdspr {
                Cmdspr(0)
            }
        }
        impl core::fmt::Debug for Cmdspr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmdspr")
                    .field("msrdr", &self.msrdr())
                    .field("cdttim", &self.cdttim())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmdspr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cmdspr {{ msrdr: {:?}, cdttim: {:?} }}",
                    self.msrdr(),
                    self.cdttim()
                )
            }
        }
        #[doc = "CCC Max Data Speed T (Turnaround) Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmdspt(pub u32);
        impl Cmdspt {
            #[doc = "Maximum Read Turnaround Time"]
            #[inline(always)]
            pub const fn mrttim(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Maximum Read Turnaround Time"]
            #[inline(always)]
            pub fn set_mrttim(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "Maximum Read Turnaround Time Enable"]
            #[inline(always)]
            pub const fn mrte(&self) -> super::vals::Mrte {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mrte::from_bits(val as u8)
            }
            #[doc = "Maximum Read Turnaround Time Enable"]
            #[inline(always)]
            pub fn set_mrte(&mut self, val: super::vals::Mrte) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Cmdspt {
            #[inline(always)]
            fn default() -> Cmdspt {
                Cmdspt(0)
            }
        }
        impl core::fmt::Debug for Cmdspt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmdspt")
                    .field("mrttim", &self.mrttim())
                    .field("mrte", &self.mrte())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmdspt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cmdspt {{ mrttim: {=u32:?}, mrte: {:?} }}",
                    self.mrttim(),
                    self.mrte()
                )
            }
        }
        #[doc = "CCC Max Data Speed W (Write) Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmdspw(pub u32);
        impl Cmdspw {
            #[doc = "Maximum Sustained Write Data Rate"]
            #[inline(always)]
            pub const fn mswdr(&self) -> super::vals::Mswdr {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Mswdr::from_bits(val as u8)
            }
            #[doc = "Maximum Sustained Write Data Rate"]
            #[inline(always)]
            pub fn set_mswdr(&mut self, val: super::vals::Mswdr) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Cmdspw {
            #[inline(always)]
            fn default() -> Cmdspw {
                Cmdspw(0)
            }
        }
        impl core::fmt::Debug for Cmdspw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmdspw")
                    .field("mswdr", &self.mswdr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmdspw {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cmdspw {{ mswdr: {:?} }}", self.mswdr())
            }
        }
        #[doc = "CCC Max Read Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmrlg(pub u32);
        impl Cmrlg {
            #[doc = "Max Read Length"]
            #[inline(always)]
            pub const fn mrlg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Max Read Length"]
            #[inline(always)]
            pub fn set_mrlg(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "IBI Payload Size"]
            #[inline(always)]
            pub const fn ibipsz(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "IBI Payload Size"]
            #[inline(always)]
            pub fn set_ibipsz(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Cmrlg {
            #[inline(always)]
            fn default() -> Cmrlg {
                Cmrlg(0)
            }
        }
        impl core::fmt::Debug for Cmrlg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmrlg")
                    .field("mrlg", &self.mrlg())
                    .field("ibipsz", &self.ibipsz())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmrlg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cmrlg {{ mrlg: {=u16:?}, ibipsz: {=u8:?} }}",
                    self.mrlg(),
                    self.ibipsz()
                )
            }
        }
        #[doc = "CCC Max Write Length Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cmwlg(pub u32);
        impl Cmwlg {
            #[doc = "Max Write Length"]
            #[inline(always)]
            pub const fn mwlg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Max Write Length"]
            #[inline(always)]
            pub fn set_mwlg(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Cmwlg {
            #[inline(always)]
            fn default() -> Cmwlg {
                Cmwlg(0)
            }
        }
        impl core::fmt::Debug for Cmwlg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cmwlg").field("mwlg", &self.mwlg()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmwlg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cmwlg {{ mwlg: {=u16:?} }}", self.mwlg())
            }
        }
        #[doc = "Condition Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cndctl(pub u32);
        impl Cndctl {
            #[doc = "START (S) Condition Issuance"]
            #[inline(always)]
            pub const fn stcnd(&self) -> super::vals::Stcnd {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Stcnd::from_bits(val as u8)
            }
            #[doc = "START (S) Condition Issuance"]
            #[inline(always)]
            pub fn set_stcnd(&mut self, val: super::vals::Stcnd) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Repeated START (Sr) Condition Issuance"]
            #[inline(always)]
            pub const fn srcnd(&self) -> super::vals::Srcnd {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Srcnd::from_bits(val as u8)
            }
            #[doc = "Repeated START (Sr) Condition Issuance"]
            #[inline(always)]
            pub fn set_srcnd(&mut self, val: super::vals::Srcnd) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "STOP (P) Condition Issuance"]
            #[inline(always)]
            pub const fn spcnd(&self) -> super::vals::Spcnd {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spcnd::from_bits(val as u8)
            }
            #[doc = "STOP (P) Condition Issuance"]
            #[inline(always)]
            pub fn set_spcnd(&mut self, val: super::vals::Spcnd) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Cndctl {
            #[inline(always)]
            fn default() -> Cndctl {
                Cndctl(0)
            }
        }
        impl core::fmt::Debug for Cndctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cndctl")
                    .field("stcnd", &self.stcnd())
                    .field("srcnd", &self.srcnd())
                    .field("spcnd", &self.spcnd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cndctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cndctl {{ stcnd: {:?}, srcnd: {:?}, spcnd: {:?} }}",
                    self.stcnd(),
                    self.srcnd(),
                    self.spcnd()
                )
            }
        }
        #[doc = "CCC Slave Events Command Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Csecmd(pub u32);
        impl Csecmd {
            #[doc = "Slave Interrupt Requests Enable"]
            #[inline(always)]
            pub const fn svirqe(&self) -> super::vals::Svirqe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Svirqe::from_bits(val as u8)
            }
            #[doc = "Slave Interrupt Requests Enable"]
            #[inline(always)]
            pub fn set_svirqe(&mut self, val: super::vals::Svirqe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Mastership Requests Enable"]
            #[inline(always)]
            pub const fn msrqe(&self) -> super::vals::Msrqe {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Msrqe::from_bits(val as u8)
            }
            #[doc = "Mastership Requests Enable"]
            #[inline(always)]
            pub fn set_msrqe(&mut self, val: super::vals::Msrqe) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Hot,Join Event Enable"]
            #[inline(always)]
            pub const fn hjeve(&self) -> super::vals::Hjeve {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Hjeve::from_bits(val as u8)
            }
            #[doc = "Hot,Join Event Enable"]
            #[inline(always)]
            pub fn set_hjeve(&mut self, val: super::vals::Hjeve) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Csecmd {
            #[inline(always)]
            fn default() -> Csecmd {
                Csecmd(0)
            }
        }
        impl core::fmt::Debug for Csecmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Csecmd")
                    .field("svirqe", &self.svirqe())
                    .field("msrqe", &self.msrqe())
                    .field("hjeve", &self.hjeve())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Csecmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Csecmd {{ svirqe: {:?}, msrqe: {:?}, hjeve: {:?} }}",
                    self.svirqe(),
                    self.msrqe(),
                    self.hjeve()
                )
            }
        }
        #[doc = "Device Address Table Basic Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Datbas(pub u32);
        impl Datbas {
            #[doc = "Device Static Address"]
            #[inline(always)]
            pub const fn dvstad(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Device Static Address"]
            #[inline(always)]
            pub fn set_dvstad(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Device IBI Payload"]
            #[inline(always)]
            pub const fn dvibipl(&self) -> super::vals::Dvibipl {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Dvibipl::from_bits(val as u8)
            }
            #[doc = "Device IBI Payload"]
            #[inline(always)]
            pub fn set_dvibipl(&mut self, val: super::vals::Dvibipl) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Device In,Band Slave Interrupt Request Reject"]
            #[inline(always)]
            pub const fn dvsirrj(&self) -> super::vals::Dvsirrj {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Dvsirrj::from_bits(val as u8)
            }
            #[doc = "Device In,Band Slave Interrupt Request Reject"]
            #[inline(always)]
            pub fn set_dvsirrj(&mut self, val: super::vals::Dvsirrj) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Device In,Band Master Request Reject"]
            #[inline(always)]
            pub const fn dvmrrj(&self) -> super::vals::Dvmrrj {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Dvmrrj::from_bits(val as u8)
            }
            #[doc = "Device In,Band Master Request Reject"]
            #[inline(always)]
            pub fn set_dvmrrj(&mut self, val: super::vals::Dvmrrj) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Device I3C Dynamic Address"]
            #[inline(always)]
            pub const fn dvdyad(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Device I3C Dynamic Address"]
            #[inline(always)]
            pub fn set_dvdyad(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Device NACK Retry Count"]
            #[inline(always)]
            pub const fn dvnack(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x03;
                val as u8
            }
            #[doc = "Device NACK Retry Count"]
            #[inline(always)]
            pub fn set_dvnack(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 29usize)) | (((val as u32) & 0x03) << 29usize);
            }
            #[doc = "Device Type"]
            #[inline(always)]
            pub const fn dvtyp(&self) -> super::vals::Dvtyp {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Dvtyp::from_bits(val as u8)
            }
            #[doc = "Device Type"]
            #[inline(always)]
            pub fn set_dvtyp(&mut self, val: super::vals::Dvtyp) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Datbas {
            #[inline(always)]
            fn default() -> Datbas {
                Datbas(0)
            }
        }
        impl core::fmt::Debug for Datbas {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Datbas")
                    .field("dvstad", &self.dvstad())
                    .field("dvibipl", &self.dvibipl())
                    .field("dvsirrj", &self.dvsirrj())
                    .field("dvmrrj", &self.dvmrrj())
                    .field("dvdyad", &self.dvdyad())
                    .field("dvnack", &self.dvnack())
                    .field("dvtyp", &self.dvtyp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Datbas {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Datbas {{ dvstad: {=u8:?}, dvibipl: {:?}, dvsirrj: {:?}, dvmrrj: {:?}, dvdyad: {=u8:?}, dvnack: {=u8:?}, dvtyp: {:?} }}" , self . dvstad () , self . dvibipl () , self . dvsirrj () , self . dvmrrj () , self . dvdyad () , self . dvnack () , self . dvtyp ())
            }
        }
        #[doc = "Device Characteristic Table Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dvct(pub u32);
        impl Dvct {
            #[doc = "DCT Table Index"]
            #[inline(always)]
            pub const fn idx(&self) -> u8 {
                let val = (self.0 >> 19usize) & 0x1f;
                val as u8
            }
            #[doc = "DCT Table Index"]
            #[inline(always)]
            pub fn set_idx(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 19usize)) | (((val as u32) & 0x1f) << 19usize);
            }
        }
        impl Default for Dvct {
            #[inline(always)]
            fn default() -> Dvct {
                Dvct(0)
            }
        }
        impl core::fmt::Debug for Dvct {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dvct").field("idx", &self.idx()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dvct {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dvct {{ idx: {=u8:?} }}", self.idx())
            }
        }
        #[doc = "Extended Device Address Table Basic Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Exdatbas(pub u32);
        impl Exdatbas {
            #[doc = "Extended Device Static Address"]
            #[inline(always)]
            pub const fn edstad(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Extended Device Static Address"]
            #[inline(always)]
            pub fn set_edstad(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Extended Device I3C Dynamic Address"]
            #[inline(always)]
            pub const fn eddyad(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Extended Device I3C Dynamic Address"]
            #[inline(always)]
            pub fn set_eddyad(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Extended Device NACK Retry Count"]
            #[inline(always)]
            pub const fn ednack(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x03;
                val as u8
            }
            #[doc = "Extended Device NACK Retry Count"]
            #[inline(always)]
            pub fn set_ednack(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 29usize)) | (((val as u32) & 0x03) << 29usize);
            }
            #[doc = "Extended Device Type"]
            #[inline(always)]
            pub const fn edtyp(&self) -> super::vals::Edtyp {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Edtyp::from_bits(val as u8)
            }
            #[doc = "Extended Device Type"]
            #[inline(always)]
            pub fn set_edtyp(&mut self, val: super::vals::Edtyp) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Exdatbas {
            #[inline(always)]
            fn default() -> Exdatbas {
                Exdatbas(0)
            }
        }
        impl core::fmt::Debug for Exdatbas {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Exdatbas")
                    .field("edstad", &self.edstad())
                    .field("eddyad", &self.eddyad())
                    .field("ednack", &self.ednack())
                    .field("edtyp", &self.edtyp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Exdatbas {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Exdatbas {{ edstad: {=u8:?}, eddyad: {=u8:?}, ednack: {=u8:?}, edtyp: {:?} }}",
                    self.edstad(),
                    self.eddyad(),
                    self.ednack(),
                    self.edtyp()
                )
            }
        }
        #[doc = "Extended Bit Rate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extbr(pub u32);
        impl Extbr {
            #[doc = "Extended Bit Rate Low,Level Period Open,Drain"]
            #[inline(always)]
            pub const fn ebrlo(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Extended Bit Rate Low,Level Period Open,Drain"]
            #[inline(always)]
            pub fn set_ebrlo(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Extended Bit Rate High,Level Period Open,Drain"]
            #[inline(always)]
            pub const fn ebrho(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Extended Bit Rate High,Level Period Open,Drain"]
            #[inline(always)]
            pub fn set_ebrho(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Extended Bit Rate Low,Level Period Push,Pull"]
            #[inline(always)]
            pub const fn ebrlp(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x3f;
                val as u8
            }
            #[doc = "Extended Bit Rate Low,Level Period Push,Pull"]
            #[inline(always)]
            pub fn set_ebrlp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 16usize)) | (((val as u32) & 0x3f) << 16usize);
            }
            #[doc = "Extended Bit Rate Low,Level Period Push,Pull"]
            #[inline(always)]
            pub const fn ebrhp(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x3f;
                val as u8
            }
            #[doc = "Extended Bit Rate Low,Level Period Push,Pull"]
            #[inline(always)]
            pub fn set_ebrhp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 24usize)) | (((val as u32) & 0x3f) << 24usize);
            }
        }
        impl Default for Extbr {
            #[inline(always)]
            fn default() -> Extbr {
                Extbr(0)
            }
        }
        impl core::fmt::Debug for Extbr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extbr")
                    .field("ebrlo", &self.ebrlo())
                    .field("ebrho", &self.ebrho())
                    .field("ebrlp", &self.ebrlp())
                    .field("ebrhp", &self.ebrhp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extbr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Extbr {{ ebrlo: {=u8:?}, ebrho: {=u8:?}, ebrlp: {=u8:?}, ebrhp: {=u8:?} }}",
                    self.ebrlo(),
                    self.ebrho(),
                    self.ebrlp(),
                    self.ebrhp()
                )
            }
        }
        #[doc = "IBI Notify Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ibinctl(pub u32);
        impl Ibinctl {
            #[doc = "Notify Rejected Hot,Join Control"]
            #[inline(always)]
            pub const fn nrhjctl(&self) -> super::vals::Nrhjctl {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Nrhjctl::from_bits(val as u8)
            }
            #[doc = "Notify Rejected Hot,Join Control"]
            #[inline(always)]
            pub fn set_nrhjctl(&mut self, val: super::vals::Nrhjctl) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Notify Rejected Master Request Control"]
            #[inline(always)]
            pub const fn nrmrctl(&self) -> super::vals::Nrmrctl {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Nrmrctl::from_bits(val as u8)
            }
            #[doc = "Notify Rejected Master Request Control"]
            #[inline(always)]
            pub fn set_nrmrctl(&mut self, val: super::vals::Nrmrctl) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Notify Rejected Slave Interrupt Request Control"]
            #[inline(always)]
            pub const fn nrsirctl(&self) -> super::vals::Nrsirctl {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Nrsirctl::from_bits(val as u8)
            }
            #[doc = "Notify Rejected Slave Interrupt Request Control"]
            #[inline(always)]
            pub fn set_nrsirctl(&mut self, val: super::vals::Nrsirctl) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Ibinctl {
            #[inline(always)]
            fn default() -> Ibinctl {
                Ibinctl(0)
            }
        }
        impl core::fmt::Debug for Ibinctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ibinctl")
                    .field("nrhjctl", &self.nrhjctl())
                    .field("nrmrctl", &self.nrmrctl())
                    .field("nrsirctl", &self.nrsirctl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ibinctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ibinctl {{ nrhjctl: {:?}, nrmrctl: {:?}, nrsirctl: {:?} }}",
                    self.nrhjctl(),
                    self.nrmrctl(),
                    self.nrsirctl()
                )
            }
        }
        #[doc = "Input Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inctl(pub u32);
        impl Inctl {
            #[doc = "Digital Noise Filter Stage Selection"]
            #[inline(always)]
            pub const fn dnfs(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Digital Noise Filter Stage Selection"]
            #[inline(always)]
            pub fn set_dnfs(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Digital Noise Filter Circuit Enable"]
            #[inline(always)]
            pub const fn dnfe(&self) -> super::vals::Dnfe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dnfe::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Circuit Enable"]
            #[inline(always)]
            pub fn set_dnfe(&mut self, val: super::vals::Dnfe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Inctl {
            #[inline(always)]
            fn default() -> Inctl {
                Inctl(0)
            }
        }
        impl core::fmt::Debug for Inctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inctl")
                    .field("dnfs", &self.dnfs())
                    .field("dnfe", &self.dnfe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Inctl {{ dnfs: {=u8:?}, dnfe: {:?} }}",
                    self.dnfs(),
                    self.dnfe()
                )
            }
        }
        #[doc = "Internal Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inie(pub u32);
        impl Inie {
            #[doc = "Internal Error Interrupt Enable"]
            #[inline(always)]
            pub const fn ineie(&self) -> super::vals::Ineie {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Ineie::from_bits(val as u8)
            }
            #[doc = "Internal Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_ineie(&mut self, val: super::vals::Ineie) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Inie {
            #[inline(always)]
            fn default() -> Inie {
                Inie(0)
            }
        }
        impl core::fmt::Debug for Inie {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inie")
                    .field("ineie", &self.ineie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inie {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Inie {{ ineie: {:?} }}", self.ineie())
            }
        }
        #[doc = "Internal Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inst(pub u32);
        impl Inst {
            #[doc = "Internal Error Flag"]
            #[inline(always)]
            pub const fn inef(&self) -> super::vals::Inef {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Inef::from_bits(val as u8)
            }
            #[doc = "Internal Error Flag"]
            #[inline(always)]
            pub fn set_inef(&mut self, val: super::vals::Inef) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Inst {
            #[inline(always)]
            fn default() -> Inst {
                Inst(0)
            }
        }
        impl core::fmt::Debug for Inst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inst").field("inef", &self.inef()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Inst {{ inef: {:?} }}", self.inef())
            }
        }
        #[doc = "Internal Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inste(pub u32);
        impl Inste {
            #[doc = "Internal Error Enable"]
            #[inline(always)]
            pub const fn inee(&self) -> super::vals::Inee {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Inee::from_bits(val as u8)
            }
            #[doc = "Internal Error Enable"]
            #[inline(always)]
            pub fn set_inee(&mut self, val: super::vals::Inee) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Inste {
            #[inline(always)]
            fn default() -> Inste {
                Inste(0)
            }
        }
        impl core::fmt::Debug for Inste {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inste").field("inee", &self.inee()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inste {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Inste {{ inee: {:?} }}", self.inee())
            }
        }
        #[doc = "Internal Status Force Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Instfc(pub u32);
        impl Instfc {
            #[doc = "Internal Error Force"]
            #[inline(always)]
            pub const fn inefc(&self) -> super::vals::Inefc {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Inefc::from_bits(val as u8)
            }
            #[doc = "Internal Error Force"]
            #[inline(always)]
            pub fn set_inefc(&mut self, val: super::vals::Inefc) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Instfc {
            #[inline(always)]
            fn default() -> Instfc {
                Instfc(0)
            }
        }
        impl core::fmt::Debug for Instfc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Instfc")
                    .field("inefc", &self.inefc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Instfc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Instfc {{ inefc: {:?} }}", self.inefc())
            }
        }
        #[doc = "Master Device Characteristic Table Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msdct(pub u32);
        impl Msdct {
            #[doc = "Max Data Speed Limitation"]
            #[inline(always)]
            pub const fn rbcr0(&self) -> super::vals::Rbcr0 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rbcr0::from_bits(val as u8)
            }
            #[doc = "Max Data Speed Limitation"]
            #[inline(always)]
            pub fn set_rbcr0(&mut self, val: super::vals::Rbcr0) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "IBI Request Capable"]
            #[inline(always)]
            pub const fn rbcr1(&self) -> super::vals::Rbcr1 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Rbcr1::from_bits(val as u8)
            }
            #[doc = "IBI Request Capable"]
            #[inline(always)]
            pub fn set_rbcr1(&mut self, val: super::vals::Rbcr1) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "IBI Payload"]
            #[inline(always)]
            pub const fn rbcr2(&self) -> super::vals::Rbcr2 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Rbcr2::from_bits(val as u8)
            }
            #[doc = "IBI Payload"]
            #[inline(always)]
            pub fn set_rbcr2(&mut self, val: super::vals::Rbcr2) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Offline Capable"]
            #[inline(always)]
            pub const fn rbcr3(&self) -> super::vals::Rbcr3 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Rbcr3::from_bits(val as u8)
            }
            #[doc = "Offline Capable"]
            #[inline(always)]
            pub fn set_rbcr3(&mut self, val: super::vals::Rbcr3) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Device Role"]
            #[inline(always)]
            pub const fn rbcr76(&self) -> super::vals::Rbcr76 {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Rbcr76::from_bits(val as u8)
            }
            #[doc = "Device Role"]
            #[inline(always)]
            pub fn set_rbcr76(&mut self, val: super::vals::Rbcr76) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u32) & 0x03) << 14usize);
            }
        }
        impl Default for Msdct {
            #[inline(always)]
            fn default() -> Msdct {
                Msdct(0)
            }
        }
        impl core::fmt::Debug for Msdct {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msdct")
                    .field("rbcr0", &self.rbcr0())
                    .field("rbcr1", &self.rbcr1())
                    .field("rbcr2", &self.rbcr2())
                    .field("rbcr3", &self.rbcr3())
                    .field("rbcr76", &self.rbcr76())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msdct {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msdct {{ rbcr0: {:?}, rbcr1: {:?}, rbcr2: {:?}, rbcr3: {:?}, rbcr76: {:?} }}",
                    self.rbcr0(),
                    self.rbcr1(),
                    self.rbcr2(),
                    self.rbcr3(),
                    self.rbcr76()
                )
            }
        }
        #[doc = "Master Device Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Msdvad(pub u32);
        impl Msdvad {
            #[doc = "Master Dynamic Address"]
            #[inline(always)]
            pub const fn mdyad(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x7f;
                val as u8
            }
            #[doc = "Master Dynamic Address"]
            #[inline(always)]
            pub fn set_mdyad(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
            }
            #[doc = "Master Dynamic Address Valid"]
            #[inline(always)]
            pub const fn mdyadv(&self) -> super::vals::Mdyadv {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mdyadv::from_bits(val as u8)
            }
            #[doc = "Master Dynamic Address Valid"]
            #[inline(always)]
            pub fn set_mdyadv(&mut self, val: super::vals::Mdyadv) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Msdvad {
            #[inline(always)]
            fn default() -> Msdvad {
                Msdvad(0)
            }
        }
        impl core::fmt::Debug for Msdvad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Msdvad")
                    .field("mdyad", &self.mdyad())
                    .field("mdyadv", &self.mdyadv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Msdvad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Msdvad {{ mdyad: {=u8:?}, mdyadv: {:?} }}",
                    self.mdyad(),
                    self.mdyadv()
                )
            }
        }
        #[doc = "Master Error Counters Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mserrcnt(pub u32);
        impl Mserrcnt {
            #[doc = "M2 Error Counter"]
            #[inline(always)]
            pub const fn m2ecnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "M2 Error Counter"]
            #[inline(always)]
            pub fn set_m2ecnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Mserrcnt {
            #[inline(always)]
            fn default() -> Mserrcnt {
                Mserrcnt(0)
            }
        }
        impl core::fmt::Debug for Mserrcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mserrcnt")
                    .field("m2ecnt", &self.m2ecnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mserrcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mserrcnt {{ m2ecnt: {=u8:?} }}", self.m2ecnt())
            }
        }
        #[doc = "Normal Data Buffer Status Level Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ndbstlv0(pub u32);
        impl Ndbstlv0 {
            #[doc = "Normal Transmit Data Buffer Free Level"]
            #[inline(always)]
            pub const fn tdbflv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Normal Transmit Data Buffer Free Level"]
            #[inline(always)]
            pub fn set_tdbflv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Normal Receive Data Buffer Level"]
            #[inline(always)]
            pub const fn rdblv(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Normal Receive Data Buffer Level"]
            #[inline(always)]
            pub fn set_rdblv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
        }
        impl Default for Ndbstlv0 {
            #[inline(always)]
            fn default() -> Ndbstlv0 {
                Ndbstlv0(0)
            }
        }
        impl core::fmt::Debug for Ndbstlv0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ndbstlv0")
                    .field("tdbflv", &self.tdbflv())
                    .field("rdblv", &self.rdblv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ndbstlv0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ndbstlv0 {{ tdbflv: {=u8:?}, rdblv: {=u8:?} }}",
                    self.tdbflv(),
                    self.rdblv()
                )
            }
        }
        #[doc = "Normal Queue Status Level Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nqstlv(pub u32);
        impl Nqstlv {
            #[doc = "Normal Command Queue Free Level"]
            #[inline(always)]
            pub const fn cmdqflv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Normal Command Queue Free Level"]
            #[inline(always)]
            pub fn set_cmdqflv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Normal Response Queue Level"]
            #[inline(always)]
            pub const fn rspqlv(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Normal Response Queue Level"]
            #[inline(always)]
            pub fn set_rspqlv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Normal IBI Queue Level"]
            #[inline(always)]
            pub const fn ibiqlv(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Normal IBI Queue Level"]
            #[inline(always)]
            pub fn set_ibiqlv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Normal IBI Status Count"]
            #[inline(always)]
            pub const fn ibiscnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Normal IBI Status Count"]
            #[inline(always)]
            pub fn set_ibiscnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for Nqstlv {
            #[inline(always)]
            fn default() -> Nqstlv {
                Nqstlv(0)
            }
        }
        impl core::fmt::Debug for Nqstlv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nqstlv")
                    .field("cmdqflv", &self.cmdqflv())
                    .field("rspqlv", &self.rspqlv())
                    .field("ibiqlv", &self.ibiqlv())
                    .field("ibiscnt", &self.ibiscnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nqstlv {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nqstlv {{ cmdqflv: {=u8:?}, rspqlv: {=u8:?}, ibiqlv: {=u8:?}, ibiscnt: {=u8:?} }}" , self . cmdqflv () , self . rspqlv () , self . ibiqlv () , self . ibiscnt ())
            }
        }
        #[doc = "Normal Queue Threshold Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nqthctl(pub u32);
        impl Nqthctl {
            #[doc = "Normal Command Ready Queue Threshold"]
            #[inline(always)]
            pub const fn cmdqth(&self) -> super::vals::Cmdqth {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Cmdqth::from_bits(val as u8)
            }
            #[doc = "Normal Command Ready Queue Threshold"]
            #[inline(always)]
            pub fn set_cmdqth(&mut self, val: super::vals::Cmdqth) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
            #[doc = "Normal Response Queue Threshold"]
            #[inline(always)]
            pub const fn rspqth(&self) -> super::vals::Rspqth {
                let val = (self.0 >> 8usize) & 0xff;
                super::vals::Rspqth::from_bits(val as u8)
            }
            #[doc = "Normal Response Queue Threshold"]
            #[inline(always)]
            pub fn set_rspqth(&mut self, val: super::vals::Rspqth) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val.to_bits() as u32) & 0xff) << 8usize);
            }
            #[doc = "Normal IBI Data Segment Size"]
            #[inline(always)]
            pub const fn ibidssz(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Normal IBI Data Segment Size"]
            #[inline(always)]
            pub fn set_ibidssz(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Normal IBI Queue Threshold"]
            #[inline(always)]
            pub const fn ibiqth(&self) -> super::vals::Ibiqth {
                let val = (self.0 >> 24usize) & 0xff;
                super::vals::Ibiqth::from_bits(val as u8)
            }
            #[doc = "Normal IBI Queue Threshold"]
            #[inline(always)]
            pub fn set_ibiqth(&mut self, val: super::vals::Ibiqth) {
                self.0 =
                    (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Nqthctl {
            #[inline(always)]
            fn default() -> Nqthctl {
                Nqthctl(0)
            }
        }
        impl core::fmt::Debug for Nqthctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nqthctl")
                    .field("cmdqth", &self.cmdqth())
                    .field("rspqth", &self.rspqth())
                    .field("ibidssz", &self.ibidssz())
                    .field("ibiqth", &self.ibiqth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nqthctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nqthctl {{ cmdqth: {:?}, rspqth: {:?}, ibidssz: {=u8:?}, ibiqth: {:?} }}",
                    self.cmdqth(),
                    self.rspqth(),
                    self.ibidssz(),
                    self.ibiqth()
                )
            }
        }
        #[doc = "Normal Receive Status Queue Threshold Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nrqthctl(pub u32);
        impl Nrqthctl {
            #[doc = "Normal Receive Status Queue Threshold"]
            #[inline(always)]
            pub const fn rsqth(&self) -> super::vals::Rsqth {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Rsqth::from_bits(val as u8)
            }
            #[doc = "Normal Receive Status Queue Threshold"]
            #[inline(always)]
            pub fn set_rsqth(&mut self, val: super::vals::Rsqth) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Nrqthctl {
            #[inline(always)]
            fn default() -> Nrqthctl {
                Nrqthctl(0)
            }
        }
        impl core::fmt::Debug for Nrqthctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nrqthctl")
                    .field("rsqth", &self.rsqth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nrqthctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Nrqthctl {{ rsqth: {:?} }}", self.rsqth())
            }
        }
        #[doc = "Normal Receive Status Queue Status Level Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nrsqstlv(pub u32);
        impl Nrsqstlv {
            #[doc = "Normal Receive Status Queue Level"]
            #[inline(always)]
            pub const fn rsqlv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Normal Receive Status Queue Level"]
            #[inline(always)]
            pub fn set_rsqlv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Nrsqstlv {
            #[inline(always)]
            fn default() -> Nrsqstlv {
                Nrsqstlv(0)
            }
        }
        impl core::fmt::Debug for Nrsqstlv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nrsqstlv")
                    .field("rsqlv", &self.rsqlv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nrsqstlv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Nrsqstlv {{ rsqlv: {=u8:?} }}", self.rsqlv())
            }
        }
        #[doc = "Normal Transfer Data Buffer Threshold Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ntbthctl0(pub u32);
        impl Ntbthctl0 {
            #[doc = "Normal Transmit Data Buffer Threshold"]
            #[inline(always)]
            pub const fn txdbth(&self) -> super::vals::Txdbth {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Txdbth::from_bits(val as u8)
            }
            #[doc = "Normal Transmit Data Buffer Threshold"]
            #[inline(always)]
            pub fn set_txdbth(&mut self, val: super::vals::Txdbth) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Normal Receive Data Buffer Threshold"]
            #[inline(always)]
            pub const fn rxdbth(&self) -> super::vals::Rxdbth {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Rxdbth::from_bits(val as u8)
            }
            #[doc = "Normal Receive Data Buffer Threshold"]
            #[inline(always)]
            pub fn set_rxdbth(&mut self, val: super::vals::Rxdbth) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Normal Tx Start Threshold"]
            #[inline(always)]
            pub const fn txstth(&self) -> super::vals::Txstth {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Txstth::from_bits(val as u8)
            }
            #[doc = "Normal Tx Start Threshold"]
            #[inline(always)]
            pub fn set_txstth(&mut self, val: super::vals::Txstth) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "Normal Rx Start Threshold"]
            #[inline(always)]
            pub const fn rxstth(&self) -> super::vals::Rxstth {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Rxstth::from_bits(val as u8)
            }
            #[doc = "Normal Rx Start Threshold"]
            #[inline(always)]
            pub fn set_rxstth(&mut self, val: super::vals::Rxstth) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Ntbthctl0 {
            #[inline(always)]
            fn default() -> Ntbthctl0 {
                Ntbthctl0(0)
            }
        }
        impl core::fmt::Debug for Ntbthctl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ntbthctl0")
                    .field("txdbth", &self.txdbth())
                    .field("rxdbth", &self.rxdbth())
                    .field("txstth", &self.txstth())
                    .field("rxstth", &self.rxstth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ntbthctl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ntbthctl0 {{ txdbth: {:?}, rxdbth: {:?}, txstth: {:?}, rxstth: {:?} }}",
                    self.txdbth(),
                    self.rxdbth(),
                    self.txstth(),
                    self.rxstth()
                )
            }
        }
        #[doc = "Normal Transfer Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ntie(pub u32);
        impl Ntie {
            #[doc = "Normal Transmit Data Buffer Empty Interrupt Enable 0"]
            #[inline(always)]
            pub const fn tdbeie0(&self) -> super::vals::Tdbeie0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tdbeie0::from_bits(val as u8)
            }
            #[doc = "Normal Transmit Data Buffer Empty Interrupt Enable 0"]
            #[inline(always)]
            pub fn set_tdbeie0(&mut self, val: super::vals::Tdbeie0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Normal Receive Data Buffer Full Interrupt Enable 0"]
            #[inline(always)]
            pub const fn rdbfie0(&self) -> super::vals::Rdbfie0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rdbfie0::from_bits(val as u8)
            }
            #[doc = "Normal Receive Data Buffer Full Interrupt Enable 0"]
            #[inline(always)]
            pub fn set_rdbfie0(&mut self, val: super::vals::Rdbfie0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Normal IBI Queue Empty/Full Interrupt Enable"]
            #[inline(always)]
            pub const fn ibiqefie(&self) -> super::vals::Ibiqefie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ibiqefie::from_bits(val as u8)
            }
            #[doc = "Normal IBI Queue Empty/Full Interrupt Enable"]
            #[inline(always)]
            pub fn set_ibiqefie(&mut self, val: super::vals::Ibiqefie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Normal Command Queue Empty Interrupt Enable"]
            #[inline(always)]
            pub const fn cmdqeie(&self) -> super::vals::Cmdqeie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmdqeie::from_bits(val as u8)
            }
            #[doc = "Normal Command Queue Empty Interrupt Enable"]
            #[inline(always)]
            pub fn set_cmdqeie(&mut self, val: super::vals::Cmdqeie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Normal Response Queue Full Interrupt Enable"]
            #[inline(always)]
            pub const fn rspqfie(&self) -> super::vals::Rspqfie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rspqfie::from_bits(val as u8)
            }
            #[doc = "Normal Response Queue Full Interrupt Enable"]
            #[inline(always)]
            pub fn set_rspqfie(&mut self, val: super::vals::Rspqfie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Normal Transfer Abort Interrupt Enable"]
            #[inline(always)]
            pub const fn tabtie(&self) -> super::vals::Tabtie {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tabtie::from_bits(val as u8)
            }
            #[doc = "Normal Transfer Abort Interrupt Enable"]
            #[inline(always)]
            pub fn set_tabtie(&mut self, val: super::vals::Tabtie) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Normal Transfer Error Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Normal Transfer Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Normal Receive Status Queue Full Interrupt Enable"]
            #[inline(always)]
            pub const fn rsqfie(&self) -> super::vals::Rsqfie {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Rsqfie::from_bits(val as u8)
            }
            #[doc = "Normal Receive Status Queue Full Interrupt Enable"]
            #[inline(always)]
            pub fn set_rsqfie(&mut self, val: super::vals::Rsqfie) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Ntie {
            #[inline(always)]
            fn default() -> Ntie {
                Ntie(0)
            }
        }
        impl core::fmt::Debug for Ntie {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ntie")
                    .field("tdbeie0", &self.tdbeie0())
                    .field("rdbfie0", &self.rdbfie0())
                    .field("ibiqefie", &self.ibiqefie())
                    .field("cmdqeie", &self.cmdqeie())
                    .field("rspqfie", &self.rspqfie())
                    .field("tabtie", &self.tabtie())
                    .field("teie", &self.teie())
                    .field("rsqfie", &self.rsqfie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ntie {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ntie {{ tdbeie0: {:?}, rdbfie0: {:?}, ibiqefie: {:?}, cmdqeie: {:?}, rspqfie: {:?}, tabtie: {:?}, teie: {:?}, rsqfie: {:?} }}" , self . tdbeie0 () , self . rdbfie0 () , self . ibiqefie () , self . cmdqeie () , self . rspqfie () , self . tabtie () , self . teie () , self . rsqfie ())
            }
        }
        #[doc = "Normal Transfer Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ntst(pub u32);
        impl Ntst {
            #[doc = "Normal Transmit Data Buffer Empty Flag 0"]
            #[inline(always)]
            pub const fn tdbef0(&self) -> super::vals::Tdbef0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tdbef0::from_bits(val as u8)
            }
            #[doc = "Normal Transmit Data Buffer Empty Flag 0"]
            #[inline(always)]
            pub fn set_tdbef0(&mut self, val: super::vals::Tdbef0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Normal Receive Data Buffer Full Flag 0"]
            #[inline(always)]
            pub const fn rdbff0(&self) -> super::vals::Rdbff0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rdbff0::from_bits(val as u8)
            }
            #[doc = "Normal Receive Data Buffer Full Flag 0"]
            #[inline(always)]
            pub fn set_rdbff0(&mut self, val: super::vals::Rdbff0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Normal IBI Queue Empty/Full Flag"]
            #[inline(always)]
            pub const fn ibiqeff(&self) -> super::vals::Ibiqeff {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ibiqeff::from_bits(val as u8)
            }
            #[doc = "Normal IBI Queue Empty/Full Flag"]
            #[inline(always)]
            pub fn set_ibiqeff(&mut self, val: super::vals::Ibiqeff) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Normal Command Queue Empty Flag"]
            #[inline(always)]
            pub const fn cmdqef(&self) -> super::vals::Cmdqef {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmdqef::from_bits(val as u8)
            }
            #[doc = "Normal Command Queue Empty Flag"]
            #[inline(always)]
            pub fn set_cmdqef(&mut self, val: super::vals::Cmdqef) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Normal Response Queue Full Flag"]
            #[inline(always)]
            pub const fn rspqff(&self) -> super::vals::Rspqff {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rspqff::from_bits(val as u8)
            }
            #[doc = "Normal Response Queue Full Flag"]
            #[inline(always)]
            pub fn set_rspqff(&mut self, val: super::vals::Rspqff) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Normal Transfer Abort Flag"]
            #[inline(always)]
            pub const fn tabtf(&self) -> super::vals::Tabtf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tabtf::from_bits(val as u8)
            }
            #[doc = "Normal Transfer Abort Flag"]
            #[inline(always)]
            pub fn set_tabtf(&mut self, val: super::vals::Tabtf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Normal Transfer Error Flag"]
            #[inline(always)]
            pub const fn tef(&self) -> super::vals::Tef {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tef::from_bits(val as u8)
            }
            #[doc = "Normal Transfer Error Flag"]
            #[inline(always)]
            pub fn set_tef(&mut self, val: super::vals::Tef) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Normal Receive Status Queue Full Flag"]
            #[inline(always)]
            pub const fn rsqff(&self) -> super::vals::Rsqff {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Rsqff::from_bits(val as u8)
            }
            #[doc = "Normal Receive Status Queue Full Flag"]
            #[inline(always)]
            pub fn set_rsqff(&mut self, val: super::vals::Rsqff) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Ntst {
            #[inline(always)]
            fn default() -> Ntst {
                Ntst(0)
            }
        }
        impl core::fmt::Debug for Ntst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ntst")
                    .field("tdbef0", &self.tdbef0())
                    .field("rdbff0", &self.rdbff0())
                    .field("ibiqeff", &self.ibiqeff())
                    .field("cmdqef", &self.cmdqef())
                    .field("rspqff", &self.rspqff())
                    .field("tabtf", &self.tabtf())
                    .field("tef", &self.tef())
                    .field("rsqff", &self.rsqff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ntst {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ntst {{ tdbef0: {:?}, rdbff0: {:?}, ibiqeff: {:?}, cmdqef: {:?}, rspqff: {:?}, tabtf: {:?}, tef: {:?}, rsqff: {:?} }}" , self . tdbef0 () , self . rdbff0 () , self . ibiqeff () , self . cmdqef () , self . rspqff () , self . tabtf () , self . tef () , self . rsqff ())
            }
        }
        #[doc = "Normal Transfer Status Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ntste(pub u32);
        impl Ntste {
            #[doc = "Normal Transmit Data Buffer Empty Enable 0"]
            #[inline(always)]
            pub const fn tdbee0(&self) -> super::vals::Tdbee0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tdbee0::from_bits(val as u8)
            }
            #[doc = "Normal Transmit Data Buffer Empty Enable 0"]
            #[inline(always)]
            pub fn set_tdbee0(&mut self, val: super::vals::Tdbee0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Normal Receive Data Buffer Full Enable 0"]
            #[inline(always)]
            pub const fn rdbfe0(&self) -> super::vals::Rdbfe0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rdbfe0::from_bits(val as u8)
            }
            #[doc = "Normal Receive Data Buffer Full Enable 0"]
            #[inline(always)]
            pub fn set_rdbfe0(&mut self, val: super::vals::Rdbfe0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Normal IBI Queue Empty/Full Enable"]
            #[inline(always)]
            pub const fn ibiqefe(&self) -> super::vals::Ibiqefe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ibiqefe::from_bits(val as u8)
            }
            #[doc = "Normal IBI Queue Empty/Full Enable"]
            #[inline(always)]
            pub fn set_ibiqefe(&mut self, val: super::vals::Ibiqefe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Normal Command Queue Empty Enable"]
            #[inline(always)]
            pub const fn cmdqee(&self) -> super::vals::Cmdqee {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmdqee::from_bits(val as u8)
            }
            #[doc = "Normal Command Queue Empty Enable"]
            #[inline(always)]
            pub fn set_cmdqee(&mut self, val: super::vals::Cmdqee) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Normal Response Queue Full Enable"]
            #[inline(always)]
            pub const fn rspqfe(&self) -> super::vals::Rspqfe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rspqfe::from_bits(val as u8)
            }
            #[doc = "Normal Response Queue Full Enable"]
            #[inline(always)]
            pub fn set_rspqfe(&mut self, val: super::vals::Rspqfe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Normal Transfer Abort Enable"]
            #[inline(always)]
            pub const fn tabte(&self) -> super::vals::Tabte {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tabte::from_bits(val as u8)
            }
            #[doc = "Normal Transfer Abort Enable"]
            #[inline(always)]
            pub fn set_tabte(&mut self, val: super::vals::Tabte) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Normal Transfer Error Enable"]
            #[inline(always)]
            pub const fn tee(&self) -> super::vals::Tee {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tee::from_bits(val as u8)
            }
            #[doc = "Normal Transfer Error Enable"]
            #[inline(always)]
            pub fn set_tee(&mut self, val: super::vals::Tee) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Normal Receive Status Queue Full Enable"]
            #[inline(always)]
            pub const fn rsqfe(&self) -> super::vals::Rsqfe {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Rsqfe::from_bits(val as u8)
            }
            #[doc = "Normal Receive Status Queue Full Enable"]
            #[inline(always)]
            pub fn set_rsqfe(&mut self, val: super::vals::Rsqfe) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Ntste {
            #[inline(always)]
            fn default() -> Ntste {
                Ntste(0)
            }
        }
        impl core::fmt::Debug for Ntste {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ntste")
                    .field("tdbee0", &self.tdbee0())
                    .field("rdbfe0", &self.rdbfe0())
                    .field("ibiqefe", &self.ibiqefe())
                    .field("cmdqee", &self.cmdqee())
                    .field("rspqfe", &self.rspqfe())
                    .field("tabte", &self.tabte())
                    .field("tee", &self.tee())
                    .field("rsqfe", &self.rsqfe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ntste {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ntste {{ tdbee0: {:?}, rdbfe0: {:?}, ibiqefe: {:?}, cmdqee: {:?}, rspqfe: {:?}, tabte: {:?}, tee: {:?}, rsqfe: {:?} }}" , self . tdbee0 () , self . rdbfe0 () , self . ibiqefe () , self . cmdqee () , self . rspqfe () , self . tabte () , self . tee () , self . rsqfe ())
            }
        }
        #[doc = "Normal Transfer Status Force Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ntstfc(pub u32);
        impl Ntstfc {
            #[doc = "Normal Transmit Data Buffer Empty Force 0"]
            #[inline(always)]
            pub const fn tdbefc0(&self) -> super::vals::Tdbefc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tdbefc0::from_bits(val as u8)
            }
            #[doc = "Normal Transmit Data Buffer Empty Force 0"]
            #[inline(always)]
            pub fn set_tdbefc0(&mut self, val: super::vals::Tdbefc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Normal Receive Data Buffer Full Force 0"]
            #[inline(always)]
            pub const fn rdbffc0(&self) -> super::vals::Rdbffc0 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rdbffc0::from_bits(val as u8)
            }
            #[doc = "Normal Receive Data Buffer Full Force 0"]
            #[inline(always)]
            pub fn set_rdbffc0(&mut self, val: super::vals::Rdbffc0) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Normal IBI Queue Empty/Full Force"]
            #[inline(always)]
            pub const fn ibiqeffc(&self) -> super::vals::Ibiqeffc {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ibiqeffc::from_bits(val as u8)
            }
            #[doc = "Normal IBI Queue Empty/Full Force"]
            #[inline(always)]
            pub fn set_ibiqeffc(&mut self, val: super::vals::Ibiqeffc) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Normal Command Queue Empty Force"]
            #[inline(always)]
            pub const fn cmdqefc(&self) -> super::vals::Cmdqefc {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Cmdqefc::from_bits(val as u8)
            }
            #[doc = "Normal Command Queue Empty Force"]
            #[inline(always)]
            pub fn set_cmdqefc(&mut self, val: super::vals::Cmdqefc) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Normal Response Queue Full Force"]
            #[inline(always)]
            pub const fn rspqffc(&self) -> super::vals::Rspqffc {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rspqffc::from_bits(val as u8)
            }
            #[doc = "Normal Response Queue Full Force"]
            #[inline(always)]
            pub fn set_rspqffc(&mut self, val: super::vals::Rspqffc) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Normal Transfer Abort Force"]
            #[inline(always)]
            pub const fn tabtfc(&self) -> super::vals::Tabtfc {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tabtfc::from_bits(val as u8)
            }
            #[doc = "Normal Transfer Abort Force"]
            #[inline(always)]
            pub fn set_tabtfc(&mut self, val: super::vals::Tabtfc) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Normal Transfer Error Force"]
            #[inline(always)]
            pub const fn tefc(&self) -> super::vals::Tefc {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tefc::from_bits(val as u8)
            }
            #[doc = "Normal Transfer Error Force"]
            #[inline(always)]
            pub fn set_tefc(&mut self, val: super::vals::Tefc) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Normal Receive Status Queue Full Force"]
            #[inline(always)]
            pub const fn rsqffc(&self) -> super::vals::Rsqffc {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Rsqffc::from_bits(val as u8)
            }
            #[doc = "Normal Receive Status Queue Full Force"]
            #[inline(always)]
            pub fn set_rsqffc(&mut self, val: super::vals::Rsqffc) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Ntstfc {
            #[inline(always)]
            fn default() -> Ntstfc {
                Ntstfc(0)
            }
        }
        impl core::fmt::Debug for Ntstfc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ntstfc")
                    .field("tdbefc0", &self.tdbefc0())
                    .field("rdbffc0", &self.rdbffc0())
                    .field("ibiqeffc", &self.ibiqeffc())
                    .field("cmdqefc", &self.cmdqefc())
                    .field("rspqffc", &self.rspqffc())
                    .field("tabtfc", &self.tabtfc())
                    .field("tefc", &self.tefc())
                    .field("rsqffc", &self.rsqffc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ntstfc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ntstfc {{ tdbefc0: {:?}, rdbffc0: {:?}, ibiqeffc: {:?}, cmdqefc: {:?}, rspqffc: {:?}, tabtfc: {:?}, tefc: {:?}, rsqffc: {:?} }}" , self . tdbefc0 () , self . rdbffc0 () , self . ibiqeffc () , self . cmdqefc () , self . rspqffc () , self . tabtfc () , self . tefc () , self . rsqffc ())
            }
        }
        #[doc = "Output Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outctl(pub u32);
        impl Outctl {
            #[doc = "SDA Output Control"]
            #[inline(always)]
            pub const fn sdoc(&self) -> super::vals::Sdoc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sdoc::from_bits(val as u8)
            }
            #[doc = "SDA Output Control"]
            #[inline(always)]
            pub fn set_sdoc(&mut self, val: super::vals::Sdoc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "SCL Output Control"]
            #[inline(always)]
            pub const fn scoc(&self) -> super::vals::Scoc {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Scoc::from_bits(val as u8)
            }
            #[doc = "SCL Output Control"]
            #[inline(always)]
            pub fn set_scoc(&mut self, val: super::vals::Scoc) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "SCL/SDA Output Control Write Protect"]
            #[inline(always)]
            pub const fn socwp(&self) -> super::vals::Socwp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Socwp::from_bits(val as u8)
            }
            #[doc = "SCL/SDA Output Control Write Protect"]
            #[inline(always)]
            pub fn set_socwp(&mut self, val: super::vals::Socwp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Extra SCL Clock Cycle Output"]
            #[inline(always)]
            pub const fn excyc(&self) -> super::vals::Excyc {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Excyc::from_bits(val as u8)
            }
            #[doc = "Extra SCL Clock Cycle Output"]
            #[inline(always)]
            pub fn set_excyc(&mut self, val: super::vals::Excyc) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "SDA Output Delay"]
            #[inline(always)]
            pub const fn sdod(&self) -> super::vals::Sdod {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Sdod::from_bits(val as u8)
            }
            #[doc = "SDA Output Delay"]
            #[inline(always)]
            pub fn set_sdod(&mut self, val: super::vals::Sdod) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "SDA Output Delay Clock Source Selection"]
            #[inline(always)]
            pub const fn sdodcs(&self) -> super::vals::Sdodcs {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sdodcs::from_bits(val as u8)
            }
            #[doc = "SDA Output Delay Clock Source Selection"]
            #[inline(always)]
            pub fn set_sdodcs(&mut self, val: super::vals::Sdodcs) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Outctl {
            #[inline(always)]
            fn default() -> Outctl {
                Outctl(0)
            }
        }
        impl core::fmt::Debug for Outctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outctl")
                    .field("sdoc", &self.sdoc())
                    .field("scoc", &self.scoc())
                    .field("socwp", &self.socwp())
                    .field("excyc", &self.excyc())
                    .field("sdod", &self.sdod())
                    .field("sdodcs", &self.sdodcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Outctl {{ sdoc: {:?}, scoc: {:?}, socwp: {:?}, excyc: {:?}, sdod: {:?}, sdodcs: {:?} }}" , self . sdoc () , self . scoc () , self . socwp () , self . excyc () , self . sdod () , self . sdodcs ())
            }
        }
        #[doc = "Present State Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prsst(pub u32);
        impl Prsst {
            #[doc = "Current Master"]
            #[inline(always)]
            pub const fn crms(&self) -> super::vals::Crms {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Crms::from_bits(val as u8)
            }
            #[doc = "Current Master"]
            #[inline(always)]
            pub fn set_crms(&mut self, val: super::vals::Crms) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Transmit/Receive Mode"]
            #[inline(always)]
            pub const fn trmd(&self) -> super::vals::Trmd {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Trmd::from_bits(val as u8)
            }
            #[doc = "Transmit/Receive Mode"]
            #[inline(always)]
            pub fn set_trmd(&mut self, val: super::vals::Trmd) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Present State Write Protect"]
            #[inline(always)]
            pub const fn prsstwp(&self) -> super::vals::Prsstwp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Prsstwp::from_bits(val as u8)
            }
            #[doc = "Present State Write Protect"]
            #[inline(always)]
            pub fn set_prsstwp(&mut self, val: super::vals::Prsstwp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Prsst {
            #[inline(always)]
            fn default() -> Prsst {
                Prsst(0)
            }
        }
        impl core::fmt::Debug for Prsst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prsst")
                    .field("crms", &self.crms())
                    .field("trmd", &self.trmd())
                    .field("prsstwp", &self.prsstwp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prsst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prsst {{ crms: {:?}, trmd: {:?}, prsstwp: {:?} }}",
                    self.crms(),
                    self.trmd(),
                    self.prsstwp()
                )
            }
        }
        #[doc = "Present State Debug Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prstdbg(pub u32);
        impl Prstdbg {
            #[doc = "SCL Line Signal Level"]
            #[inline(always)]
            pub const fn scilv(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "SCL Line Signal Level"]
            #[inline(always)]
            pub fn set_scilv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SDA Line Signal Level"]
            #[inline(always)]
            pub const fn sdilv(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "SDA Line Signal Level"]
            #[inline(always)]
            pub fn set_sdilv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "SCL Output Level"]
            #[inline(always)]
            pub const fn scolv(&self) -> super::vals::Scolv {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Scolv::from_bits(val as u8)
            }
            #[doc = "SCL Output Level"]
            #[inline(always)]
            pub fn set_scolv(&mut self, val: super::vals::Scolv) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "SDA Output Level"]
            #[inline(always)]
            pub const fn sdolv(&self) -> super::vals::Sdolv {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sdolv::from_bits(val as u8)
            }
            #[doc = "SDA Output Level"]
            #[inline(always)]
            pub fn set_sdolv(&mut self, val: super::vals::Sdolv) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Prstdbg {
            #[inline(always)]
            fn default() -> Prstdbg {
                Prstdbg(0)
            }
        }
        impl core::fmt::Debug for Prstdbg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prstdbg")
                    .field("scilv", &self.scilv())
                    .field("sdilv", &self.sdilv())
                    .field("scolv", &self.scolv())
                    .field("sdolv", &self.sdolv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prstdbg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prstdbg {{ scilv: {=bool:?}, sdilv: {=bool:?}, scolv: {:?}, sdolv: {:?} }}",
                    self.scilv(),
                    self.sdilv(),
                    self.scolv(),
                    self.sdolv()
                )
            }
        }
        #[doc = "Protocol Selection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prts(pub u32);
        impl Prts {
            #[doc = "Protocol Mode"]
            #[inline(always)]
            pub const fn prtmd(&self) -> super::vals::Prtmd {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Prtmd::from_bits(val as u8)
            }
            #[doc = "Protocol Mode"]
            #[inline(always)]
            pub fn set_prtmd(&mut self, val: super::vals::Prtmd) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Prts {
            #[inline(always)]
            fn default() -> Prts {
                Prts(0)
            }
        }
        impl core::fmt::Debug for Prts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prts")
                    .field("prtmd", &self.prtmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prts {{ prtmd: {:?} }}", self.prtmd())
            }
        }
        #[doc = "Reference Clock Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refckctl(pub u32);
        impl Refckctl {
            #[doc = "Internal Reference Clock Selection"]
            #[inline(always)]
            pub const fn irefcks(&self) -> super::vals::Irefcks {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Irefcks::from_bits(val as u8)
            }
            #[doc = "Internal Reference Clock Selection"]
            #[inline(always)]
            pub fn set_irefcks(&mut self, val: super::vals::Irefcks) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Refckctl {
            #[inline(always)]
            fn default() -> Refckctl {
                Refckctl(0)
            }
        }
        impl core::fmt::Debug for Refckctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refckctl")
                    .field("irefcks", &self.irefcks())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refckctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Refckctl {{ irefcks: {:?} }}", self.irefcks())
            }
        }
        #[doc = "Reset Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstctl(pub u32);
        impl Rstctl {
            #[doc = "I3C Software Reset"]
            #[inline(always)]
            pub const fn ri3crst(&self) -> super::vals::Ri3crst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ri3crst::from_bits(val as u8)
            }
            #[doc = "I3C Software Reset"]
            #[inline(always)]
            pub fn set_ri3crst(&mut self, val: super::vals::Ri3crst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Command Queue Software Reset"]
            #[inline(always)]
            pub const fn cmdqrst(&self) -> super::vals::Cmdqrst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cmdqrst::from_bits(val as u8)
            }
            #[doc = "Command Queue Software Reset"]
            #[inline(always)]
            pub fn set_cmdqrst(&mut self, val: super::vals::Cmdqrst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Response Queue Software Reset"]
            #[inline(always)]
            pub const fn rspqrst(&self) -> super::vals::Rspqrst {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Rspqrst::from_bits(val as u8)
            }
            #[doc = "Response Queue Software Reset"]
            #[inline(always)]
            pub fn set_rspqrst(&mut self, val: super::vals::Rspqrst) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Transmit Data Buffer Software Reset"]
            #[inline(always)]
            pub const fn tdbrst(&self) -> super::vals::Tdbrst {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Tdbrst::from_bits(val as u8)
            }
            #[doc = "Transmit Data Buffer Software Reset"]
            #[inline(always)]
            pub fn set_tdbrst(&mut self, val: super::vals::Tdbrst) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Receive Data Buffer Software Reset"]
            #[inline(always)]
            pub const fn rdbrst(&self) -> super::vals::Rdbrst {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rdbrst::from_bits(val as u8)
            }
            #[doc = "Receive Data Buffer Software Reset"]
            #[inline(always)]
            pub fn set_rdbrst(&mut self, val: super::vals::Rdbrst) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "IBI Queue Software Reset"]
            #[inline(always)]
            pub const fn ibiqrst(&self) -> super::vals::Ibiqrst {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ibiqrst::from_bits(val as u8)
            }
            #[doc = "IBI Queue Software Reset"]
            #[inline(always)]
            pub fn set_ibiqrst(&mut self, val: super::vals::Ibiqrst) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Receive Status Queue Software Reset"]
            #[inline(always)]
            pub const fn rsqrst(&self) -> super::vals::Rsqrst {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Rsqrst::from_bits(val as u8)
            }
            #[doc = "Receive Status Queue Software Reset"]
            #[inline(always)]
            pub fn set_rsqrst(&mut self, val: super::vals::Rsqrst) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Internal Software Reset"]
            #[inline(always)]
            pub const fn intlrst(&self) -> super::vals::Intlrst {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Intlrst::from_bits(val as u8)
            }
            #[doc = "Internal Software Reset"]
            #[inline(always)]
            pub fn set_intlrst(&mut self, val: super::vals::Intlrst) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Rstctl {
            #[inline(always)]
            fn default() -> Rstctl {
                Rstctl(0)
            }
        }
        impl core::fmt::Debug for Rstctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstctl")
                    .field("ri3crst", &self.ri3crst())
                    .field("cmdqrst", &self.cmdqrst())
                    .field("rspqrst", &self.rspqrst())
                    .field("tdbrst", &self.tdbrst())
                    .field("rdbrst", &self.rdbrst())
                    .field("ibiqrst", &self.ibiqrst())
                    .field("rsqrst", &self.rsqrst())
                    .field("intlrst", &self.intlrst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rstctl {{ ri3crst: {:?}, cmdqrst: {:?}, rspqrst: {:?}, tdbrst: {:?}, rdbrst: {:?}, ibiqrst: {:?}, rsqrst: {:?}, intlrst: {:?} }}" , self . ri3crst () , self . cmdqrst () , self . rspqrst () , self . tdbrst () , self . rdbrst () , self . ibiqrst () , self . rsqrst () , self . intlrst ())
            }
        }
        #[doc = "SCL Stalling Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scstlctl(pub u32);
        impl Scstlctl {
            #[doc = "Stalling Cycle"]
            #[inline(always)]
            pub const fn stlcyc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Stalling Cycle"]
            #[inline(always)]
            pub fn set_stlcyc(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Assigned Address Phase Enable"]
            #[inline(always)]
            pub const fn aape(&self) -> super::vals::Aape {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Aape::from_bits(val as u8)
            }
            #[doc = "Assigned Address Phase Enable"]
            #[inline(always)]
            pub fn set_aape(&mut self, val: super::vals::Aape) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Transition Phase Enable"]
            #[inline(always)]
            pub const fn trape(&self) -> super::vals::Trape {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Trape::from_bits(val as u8)
            }
            #[doc = "Transition Phase Enable"]
            #[inline(always)]
            pub fn set_trape(&mut self, val: super::vals::Trape) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Parity Phase Enable"]
            #[inline(always)]
            pub const fn parpe(&self) -> super::vals::Parpe {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Parpe::from_bits(val as u8)
            }
            #[doc = "Parity Phase Enable"]
            #[inline(always)]
            pub fn set_parpe(&mut self, val: super::vals::Parpe) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "ACK phase Enable"]
            #[inline(always)]
            pub const fn ackpe(&self) -> super::vals::Ackpe {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Ackpe::from_bits(val as u8)
            }
            #[doc = "ACK phase Enable"]
            #[inline(always)]
            pub fn set_ackpe(&mut self, val: super::vals::Ackpe) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Scstlctl {
            #[inline(always)]
            fn default() -> Scstlctl {
                Scstlctl(0)
            }
        }
        impl core::fmt::Debug for Scstlctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scstlctl")
                    .field("stlcyc", &self.stlcyc())
                    .field("aape", &self.aape())
                    .field("trape", &self.trape())
                    .field("parpe", &self.parpe())
                    .field("ackpe", &self.ackpe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scstlctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scstlctl {{ stlcyc: {=u16:?}, aape: {:?}, trape: {:?}, parpe: {:?}, ackpe: {:?} }}" , self . stlcyc () , self . aape () , self . trape () , self . parpe () , self . ackpe ())
            }
        }
        #[doc = "SCL Stretch Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scstrctl(pub u32);
        impl Scstrctl {
            #[doc = "Acknowledge Transmission Wait Enable"]
            #[inline(always)]
            pub const fn acktwe(&self) -> super::vals::Acktwe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Acktwe::from_bits(val as u8)
            }
            #[doc = "Acknowledge Transmission Wait Enable"]
            #[inline(always)]
            pub fn set_acktwe(&mut self, val: super::vals::Acktwe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Receive Wait Enable"]
            #[inline(always)]
            pub const fn rwe(&self) -> super::vals::Rwe {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rwe::from_bits(val as u8)
            }
            #[doc = "Receive Wait Enable"]
            #[inline(always)]
            pub fn set_rwe(&mut self, val: super::vals::Rwe) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Scstrctl {
            #[inline(always)]
            fn default() -> Scstrctl {
                Scstrctl(0)
            }
        }
        impl core::fmt::Debug for Scstrctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scstrctl")
                    .field("acktwe", &self.acktwe())
                    .field("rwe", &self.rwe())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scstrctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scstrctl {{ acktwe: {:?}, rwe: {:?} }}",
                    self.acktwe(),
                    self.rwe()
                )
            }
        }
        #[doc = "Slave Device Address Table Basic Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sdatbas0(pub u32);
        impl Sdatbas0 {
            #[doc = "Slave Device Static Address"]
            #[inline(always)]
            pub const fn sdstad(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Slave Device Static Address"]
            #[inline(always)]
            pub fn set_sdstad(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "Slave Device Address Length Selection"]
            #[inline(always)]
            pub const fn sdadls(&self) -> super::vals::Sdadls {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Sdadls::from_bits(val as u8)
            }
            #[doc = "Slave Device Address Length Selection"]
            #[inline(always)]
            pub fn set_sdadls(&mut self, val: super::vals::Sdadls) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Slave Device IBI Payload"]
            #[inline(always)]
            pub const fn sdibipl(&self) -> super::vals::Sdibipl {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Sdibipl::from_bits(val as u8)
            }
            #[doc = "Slave Device IBI Payload"]
            #[inline(always)]
            pub fn set_sdibipl(&mut self, val: super::vals::Sdibipl) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Slave Device I3C Dynamic Address"]
            #[inline(always)]
            pub const fn sddyad(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x7f;
                val as u8
            }
            #[doc = "Slave Device I3C Dynamic Address"]
            #[inline(always)]
            pub fn set_sddyad(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
            }
        }
        impl Default for Sdatbas0 {
            #[inline(always)]
            fn default() -> Sdatbas0 {
                Sdatbas0(0)
            }
        }
        impl core::fmt::Debug for Sdatbas0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sdatbas0")
                    .field("sdstad", &self.sdstad())
                    .field("sdadls", &self.sdadls())
                    .field("sdibipl", &self.sdibipl())
                    .field("sddyad", &self.sddyad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sdatbas0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sdatbas0 {{ sdstad: {=u16:?}, sdadls: {:?}, sdibipl: {:?}, sddyad: {=u8:?} }}",
                    self.sdstad(),
                    self.sdadls(),
                    self.sdibipl(),
                    self.sddyad()
                )
            }
        }
        #[doc = "Standard Bit Rate Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Stdbr(pub u32);
        impl Stdbr {
            #[doc = "Count value of the Low,level period of SCL clock"]
            #[inline(always)]
            pub const fn sbrlo(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Count value of the Low,level period of SCL clock"]
            #[inline(always)]
            pub fn set_sbrlo(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Count value of the High,level period of SCL clock"]
            #[inline(always)]
            pub const fn sbrho(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Count value of the High,level period of SCL clock"]
            #[inline(always)]
            pub fn set_sbrho(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Standard Bit Rate Low,level Period Push,Pull"]
            #[inline(always)]
            pub const fn sbrlp(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x3f;
                val as u8
            }
            #[doc = "Standard Bit Rate Low,level Period Push,Pull"]
            #[inline(always)]
            pub fn set_sbrlp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 16usize)) | (((val as u32) & 0x3f) << 16usize);
            }
            #[doc = "Standard Bit Rate High,Level Period Push,Pull"]
            #[inline(always)]
            pub const fn sbrhp(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x3f;
                val as u8
            }
            #[doc = "Standard Bit Rate High,Level Period Push,Pull"]
            #[inline(always)]
            pub fn set_sbrhp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 24usize)) | (((val as u32) & 0x3f) << 24usize);
            }
            #[doc = "Double the Standard Bit Rate Period for Open,Drain"]
            #[inline(always)]
            pub const fn dsbrpo(&self) -> super::vals::Dsbrpo {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Dsbrpo::from_bits(val as u8)
            }
            #[doc = "Double the Standard Bit Rate Period for Open,Drain"]
            #[inline(always)]
            pub fn set_dsbrpo(&mut self, val: super::vals::Dsbrpo) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Stdbr {
            #[inline(always)]
            fn default() -> Stdbr {
                Stdbr(0)
            }
        }
        impl core::fmt::Debug for Stdbr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Stdbr")
                    .field("sbrlo", &self.sbrlo())
                    .field("sbrho", &self.sbrho())
                    .field("sbrlp", &self.sbrlp())
                    .field("sbrhp", &self.sbrhp())
                    .field("dsbrpo", &self.dsbrpo())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Stdbr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Stdbr {{ sbrlo: {=u8:?}, sbrho: {=u8:?}, sbrlp: {=u8:?}, sbrhp: {=u8:?}, dsbrpo: {:?} }}" , self . sbrlo () , self . sbrho () , self . sbrlp () , self . sbrhp () , self . dsbrpo ())
            }
        }
        #[doc = "Slave Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Svctl(pub u32);
        impl Svctl {
            #[doc = "General Call Address Enable"]
            #[inline(always)]
            pub const fn gcae(&self) -> super::vals::Gcae {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Gcae::from_bits(val as u8)
            }
            #[doc = "General Call Address Enable"]
            #[inline(always)]
            pub fn set_gcae(&mut self, val: super::vals::Gcae) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Hs,mode Master Code Enable"]
            #[inline(always)]
            pub const fn hsmce(&self) -> super::vals::Hsmce {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Hsmce::from_bits(val as u8)
            }
            #[doc = "Hs,mode Master Code Enable"]
            #[inline(always)]
            pub fn set_hsmce(&mut self, val: super::vals::Hsmce) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Device,ID Address Enable"]
            #[inline(always)]
            pub const fn dvide(&self) -> super::vals::Dvide {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Dvide::from_bits(val as u8)
            }
            #[doc = "Device,ID Address Enable"]
            #[inline(always)]
            pub fn set_dvide(&mut self, val: super::vals::Dvide) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Host Address Enable"]
            #[inline(always)]
            pub const fn hoae(&self) -> super::vals::Hoae {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Hoae::from_bits(val as u8)
            }
            #[doc = "Host Address Enable"]
            #[inline(always)]
            pub fn set_hoae(&mut self, val: super::vals::Hoae) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Slave Address Enable 0"]
            #[inline(always)]
            pub const fn svae0(&self) -> super::vals::Svae0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Svae0::from_bits(val as u8)
            }
            #[doc = "Slave Address Enable 0"]
            #[inline(always)]
            pub fn set_svae0(&mut self, val: super::vals::Svae0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Svctl {
            #[inline(always)]
            fn default() -> Svctl {
                Svctl(0)
            }
        }
        impl core::fmt::Debug for Svctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Svctl")
                    .field("gcae", &self.gcae())
                    .field("hsmce", &self.hsmce())
                    .field("dvide", &self.dvide())
                    .field("hoae", &self.hoae())
                    .field("svae0", &self.svae0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Svctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Svctl {{ gcae: {:?}, hsmce: {:?}, dvide: {:?}, hoae: {:?}, svae0: {:?} }}",
                    self.gcae(),
                    self.hsmce(),
                    self.dvide(),
                    self.hoae(),
                    self.svae0()
                )
            }
        }
        #[doc = "Slave Device Characteristic Table Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Svdct(pub u32);
        impl Svdct {
            #[doc = "Transfar Device Characteristic Register"]
            #[inline(always)]
            pub const fn tdcr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Transfar Device Characteristic Register"]
            #[inline(always)]
            pub fn set_tdcr(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Max Data Speed Limitation"]
            #[inline(always)]
            pub const fn tbcr0(&self) -> super::vals::Tbcr0 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Tbcr0::from_bits(val as u8)
            }
            #[doc = "Max Data Speed Limitation"]
            #[inline(always)]
            pub fn set_tbcr0(&mut self, val: super::vals::Tbcr0) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "IBI Request Capable"]
            #[inline(always)]
            pub const fn tbcr1(&self) -> super::vals::Tbcr1 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tbcr1::from_bits(val as u8)
            }
            #[doc = "IBI Request Capable"]
            #[inline(always)]
            pub fn set_tbcr1(&mut self, val: super::vals::Tbcr1) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "IBI Payload"]
            #[inline(always)]
            pub const fn tbcr2(&self) -> super::vals::Tbcr2 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Tbcr2::from_bits(val as u8)
            }
            #[doc = "IBI Payload"]
            #[inline(always)]
            pub fn set_tbcr2(&mut self, val: super::vals::Tbcr2) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Offline Capable"]
            #[inline(always)]
            pub const fn tbcr3(&self) -> super::vals::Tbcr3 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tbcr3::from_bits(val as u8)
            }
            #[doc = "Offline Capable"]
            #[inline(always)]
            pub fn set_tbcr3(&mut self, val: super::vals::Tbcr3) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Device Role"]
            #[inline(always)]
            pub const fn tbcr76(&self) -> super::vals::Tbcr76 {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Tbcr76::from_bits(val as u8)
            }
            #[doc = "Device Role"]
            #[inline(always)]
            pub fn set_tbcr76(&mut self, val: super::vals::Tbcr76) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u32) & 0x03) << 14usize);
            }
        }
        impl Default for Svdct {
            #[inline(always)]
            fn default() -> Svdct {
                Svdct(0)
            }
        }
        impl core::fmt::Debug for Svdct {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Svdct")
                    .field("tdcr", &self.tdcr())
                    .field("tbcr0", &self.tbcr0())
                    .field("tbcr1", &self.tbcr1())
                    .field("tbcr2", &self.tbcr2())
                    .field("tbcr3", &self.tbcr3())
                    .field("tbcr76", &self.tbcr76())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Svdct {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Svdct {{ tdcr: {=u8:?}, tbcr0: {:?}, tbcr1: {:?}, tbcr2: {:?}, tbcr3: {:?}, tbcr76: {:?} }}" , self . tdcr () , self . tbcr0 () , self . tbcr1 () , self . tbcr2 () , self . tbcr3 () , self . tbcr76 ())
            }
        }
        #[doc = "Slave Device Address Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Svdvad0(pub u32);
        impl Svdvad0 {
            #[doc = "Slave Address"]
            #[inline(always)]
            pub const fn svad(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Slave Address"]
            #[inline(always)]
            pub fn set_svad(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
            #[doc = "Slave Address Length"]
            #[inline(always)]
            pub const fn sadlg(&self) -> super::vals::Sadlg {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Sadlg::from_bits(val as u8)
            }
            #[doc = "Slave Address Length"]
            #[inline(always)]
            pub fn set_sadlg(&mut self, val: super::vals::Sadlg) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Slave Static Address Valid"]
            #[inline(always)]
            pub const fn sstadv(&self) -> super::vals::Sstadv {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Sstadv::from_bits(val as u8)
            }
            #[doc = "Slave Static Address Valid"]
            #[inline(always)]
            pub fn set_sstadv(&mut self, val: super::vals::Sstadv) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Slave Dynamic Address Valid"]
            #[inline(always)]
            pub const fn sdyadv(&self) -> super::vals::Sdyadv {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Sdyadv::from_bits(val as u8)
            }
            #[doc = "Slave Dynamic Address Valid"]
            #[inline(always)]
            pub fn set_sdyadv(&mut self, val: super::vals::Sdyadv) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Svdvad0 {
            #[inline(always)]
            fn default() -> Svdvad0 {
                Svdvad0(0)
            }
        }
        impl core::fmt::Debug for Svdvad0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Svdvad0")
                    .field("svad", &self.svad())
                    .field("sadlg", &self.sadlg())
                    .field("sstadv", &self.sstadv())
                    .field("sdyadv", &self.sdyadv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Svdvad0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Svdvad0 {{ svad: {=u16:?}, sadlg: {:?}, sstadv: {:?}, sdyadv: {:?} }}",
                    self.svad(),
                    self.sadlg(),
                    self.sstadv(),
                    self.sdyadv()
                )
            }
        }
        #[doc = "Slave Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Svst(pub u32);
        impl Svst {
            #[doc = "General Call Address Detection Flag"]
            #[inline(always)]
            pub const fn gcaf(&self) -> super::vals::Gcaf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Gcaf::from_bits(val as u8)
            }
            #[doc = "General Call Address Detection Flag"]
            #[inline(always)]
            pub fn set_gcaf(&mut self, val: super::vals::Gcaf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Hs,mode Master Code Detection Flag"]
            #[inline(always)]
            pub const fn hsmcf(&self) -> super::vals::Hsmcf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Hsmcf::from_bits(val as u8)
            }
            #[doc = "Hs,mode Master Code Detection Flag"]
            #[inline(always)]
            pub fn set_hsmcf(&mut self, val: super::vals::Hsmcf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Device,ID Address Detection Flag"]
            #[inline(always)]
            pub const fn dvidf(&self) -> super::vals::Dvidf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Dvidf::from_bits(val as u8)
            }
            #[doc = "Device,ID Address Detection Flag"]
            #[inline(always)]
            pub fn set_dvidf(&mut self, val: super::vals::Dvidf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Host Address Detection Flag"]
            #[inline(always)]
            pub const fn hoaf(&self) -> super::vals::Hoaf {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Hoaf::from_bits(val as u8)
            }
            #[doc = "Host Address Detection Flag"]
            #[inline(always)]
            pub fn set_hoaf(&mut self, val: super::vals::Hoaf) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Slave Address Detection Flag 0"]
            #[inline(always)]
            pub const fn svaf0(&self) -> super::vals::Svaf0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Svaf0::from_bits(val as u8)
            }
            #[doc = "Slave Address Detection Flag 0"]
            #[inline(always)]
            pub fn set_svaf0(&mut self, val: super::vals::Svaf0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Svst {
            #[inline(always)]
            fn default() -> Svst {
                Svst(0)
            }
        }
        impl core::fmt::Debug for Svst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Svst")
                    .field("gcaf", &self.gcaf())
                    .field("hsmcf", &self.hsmcf())
                    .field("dvidf", &self.dvidf())
                    .field("hoaf", &self.hoaf())
                    .field("svaf0", &self.svaf0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Svst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Svst {{ gcaf: {:?}, hsmcf: {:?}, dvidf: {:?}, hoaf: {:?}, svaf0: {:?} }}",
                    self.gcaf(),
                    self.hsmcf(),
                    self.dvidf(),
                    self.hoaf(),
                    self.svaf0()
                )
            }
        }
        #[doc = "Slave Transfer Data Length Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Svtdlg0(pub u32);
        impl Svtdlg0 {
            #[doc = "Slave Transfer Data Length"]
            #[inline(always)]
            pub const fn stdlg(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Slave Transfer Data Length"]
            #[inline(always)]
            pub fn set_stdlg(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Svtdlg0 {
            #[inline(always)]
            fn default() -> Svtdlg0 {
                Svtdlg0(0)
            }
        }
        impl core::fmt::Debug for Svtdlg0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Svtdlg0")
                    .field("stdlg", &self.stdlg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Svtdlg0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Svtdlg0 {{ stdlg: {=u16:?} }}", self.stdlg())
            }
        }
        #[doc = "Timeout Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tmoctl(pub u32);
        impl Tmoctl {
            #[doc = "Timeout Detection Time Selection"]
            #[inline(always)]
            pub const fn todts(&self) -> super::vals::Todts {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Todts::from_bits(val as u8)
            }
            #[doc = "Timeout Detection Time Selection"]
            #[inline(always)]
            pub fn set_todts(&mut self, val: super::vals::Todts) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Timeout L Count Control"]
            #[inline(always)]
            pub const fn tolctl(&self) -> super::vals::Tolctl {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Tolctl::from_bits(val as u8)
            }
            #[doc = "Timeout L Count Control"]
            #[inline(always)]
            pub fn set_tolctl(&mut self, val: super::vals::Tolctl) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Timeout H Count Control"]
            #[inline(always)]
            pub const fn tohctl(&self) -> super::vals::Tohctl {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Tohctl::from_bits(val as u8)
            }
            #[doc = "Timeout H Count Control"]
            #[inline(always)]
            pub fn set_tohctl(&mut self, val: super::vals::Tohctl) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Timeout Operation Mode Selection"]
            #[inline(always)]
            pub const fn tomds(&self) -> super::vals::Tomds {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Tomds::from_bits(val as u8)
            }
            #[doc = "Timeout Operation Mode Selection"]
            #[inline(always)]
            pub fn set_tomds(&mut self, val: super::vals::Tomds) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Tmoctl {
            #[inline(always)]
            fn default() -> Tmoctl {
                Tmoctl(0)
            }
        }
        impl core::fmt::Debug for Tmoctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tmoctl")
                    .field("todts", &self.todts())
                    .field("tolctl", &self.tolctl())
                    .field("tohctl", &self.tohctl())
                    .field("tomds", &self.tomds())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tmoctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tmoctl {{ todts: {:?}, tolctl: {:?}, tohctl: {:?}, tomds: {:?} }}",
                    self.todts(),
                    self.tolctl(),
                    self.tohctl(),
                    self.tomds()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Aape {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Aape {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Aape {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Aape {
            #[inline(always)]
            fn from(val: u8) -> Aape {
                Aape::from_bits(val)
            }
        }
        impl From<Aape> for u8 {
            #[inline(always)]
            fn from(val: Aape) -> u8 {
                Aape::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abt {
            #[inline(always)]
            fn from(val: u8) -> Abt {
                Abt::from_bits(val)
            }
        }
        impl From<Abt> for u8 {
            #[inline(always)]
            fn from(val: Abt) -> u8 {
                Abt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackpe {
            #[inline(always)]
            fn from(val: u8) -> Ackpe {
                Ackpe::from_bits(val)
            }
        }
        impl From<Ackpe> for u8 {
            #[inline(always)]
            fn from(val: Ackpe) -> u8 {
                Ackpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackr {
            #[inline(always)]
            fn from(val: u8) -> Ackr {
                Ackr::from_bits(val)
            }
        }
        impl From<Ackr> for u8 {
            #[inline(always)]
            fn from(val: Ackr) -> u8 {
                Ackr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ackt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackt {
            #[inline(always)]
            fn from(val: u8) -> Ackt {
                Ackt::from_bits(val)
            }
        }
        impl From<Ackt> for u8 {
            #[inline(always)]
            fn from(val: Ackt) -> u8 {
                Ackt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Acktwe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Acktwe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Acktwe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Acktwe {
            #[inline(always)]
            fn from(val: u8) -> Acktwe {
                Acktwe::from_bits(val)
            }
        }
        impl From<Acktwe> for u8 {
            #[inline(always)]
            fn from(val: Acktwe) -> u8 {
                Acktwe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Acktwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Acktwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Acktwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Acktwp {
            #[inline(always)]
            fn from(val: u8) -> Acktwp {
                Acktwp::from_bits(val)
            }
        }
        impl From<Acktwp> for u8 {
            #[inline(always)]
            fn from(val: Acktwp) -> u8 {
                Acktwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Actmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Actmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Actmd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Actmd {
            #[inline(always)]
            fn from(val: u8) -> Actmd {
                Actmd::from_bits(val)
            }
        }
        impl From<Actmd> for u8 {
            #[inline(always)]
            fn from(val: Actmd) -> u8 {
                Actmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Actst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Actst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Actst {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Actst {
            #[inline(always)]
            fn from(val: u8) -> Actst {
                Actst::from_bits(val)
            }
        }
        impl From<Actst> for u8 {
            #[inline(always)]
            fn from(val: Actst) -> u8 {
                Actst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ale {
            #[inline(always)]
            fn from(val: u8) -> Ale {
                Ale::from_bits(val)
            }
        }
        impl From<Ale> for u8 {
            #[inline(always)]
            fn from(val: Ale) -> u8 {
                Ale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Alf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Alf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Alf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Alf {
            #[inline(always)]
            fn from(val: u8) -> Alf {
                Alf::from_bits(val)
            }
        }
        impl From<Alf> for u8 {
            #[inline(always)]
            fn from(val: Alf) -> u8 {
                Alf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Alfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Alfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Alfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Alfc {
            #[inline(always)]
            fn from(val: u8) -> Alfc {
                Alfc::from_bits(val)
            }
        }
        impl From<Alfc> for u8 {
            #[inline(always)]
            fn from(val: Alfc) -> u8 {
                Alfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Alie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Alie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Alie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Alie {
            #[inline(always)]
            fn from(val: u8) -> Alie {
                Alie::from_bits(val)
            }
        }
        impl From<Alie> for u8 {
            #[inline(always)]
            fn from(val: Alie) -> u8 {
                Alie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bavlf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bavlf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bavlf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bavlf {
            #[inline(always)]
            fn from(val: u8) -> Bavlf {
                Bavlf::from_bits(val)
            }
        }
        impl From<Bavlf> for u8 {
            #[inline(always)]
            fn from(val: Bavlf) -> u8 {
                Bavlf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bfref {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bfref {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bfref {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bfref {
            #[inline(always)]
            fn from(val: u8) -> Bfref {
                Bfref::from_bits(val)
            }
        }
        impl From<Bfref> for u8 {
            #[inline(always)]
            fn from(val: Bfref) -> u8 {
                Bfref::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bidlf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bidlf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bidlf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bidlf {
            #[inline(always)]
            fn from(val: u8) -> Bidlf {
                Bidlf::from_bits(val)
            }
        }
        impl From<Bidlf> for u8 {
            #[inline(always)]
            fn from(val: Bidlf) -> u8 {
                Bidlf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Buse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Buse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Buse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Buse {
            #[inline(always)]
            fn from(val: u8) -> Buse {
                Buse::from_bits(val)
            }
        }
        impl From<Buse> for u8 {
            #[inline(always)]
            fn from(val: Buse) -> u8 {
                Buse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cdttim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cdttim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cdttim {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cdttim {
            #[inline(always)]
            fn from(val: u8) -> Cdttim {
                Cdttim::from_bits(val)
            }
        }
        impl From<Cdttim> for u8 {
            #[inline(always)]
            fn from(val: Cdttim) -> u8 {
                Cdttim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmdqee {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmdqee {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmdqee {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmdqee {
            #[inline(always)]
            fn from(val: u8) -> Cmdqee {
                Cmdqee::from_bits(val)
            }
        }
        impl From<Cmdqee> for u8 {
            #[inline(always)]
            fn from(val: Cmdqee) -> u8 {
                Cmdqee::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmdqef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmdqef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmdqef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmdqef {
            #[inline(always)]
            fn from(val: u8) -> Cmdqef {
                Cmdqef::from_bits(val)
            }
        }
        impl From<Cmdqef> for u8 {
            #[inline(always)]
            fn from(val: Cmdqef) -> u8 {
                Cmdqef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmdqefc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmdqefc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmdqefc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmdqefc {
            #[inline(always)]
            fn from(val: u8) -> Cmdqefc {
                Cmdqefc::from_bits(val)
            }
        }
        impl From<Cmdqefc> for u8 {
            #[inline(always)]
            fn from(val: Cmdqefc) -> u8 {
                Cmdqefc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmdqeie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmdqeie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmdqeie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmdqeie {
            #[inline(always)]
            fn from(val: u8) -> Cmdqeie {
                Cmdqeie::from_bits(val)
            }
        }
        impl From<Cmdqeie> for u8 {
            #[inline(always)]
            fn from(val: Cmdqeie) -> u8 {
                Cmdqeie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmdqrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cmdqrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmdqrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmdqrst {
            #[inline(always)]
            fn from(val: u8) -> Cmdqrst {
                Cmdqrst::from_bits(val)
            }
        }
        impl From<Cmdqrst> for u8 {
            #[inline(always)]
            fn from(val: Cmdqrst) -> u8 {
                Cmdqrst::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Cmdqth(u8);
        impl Cmdqth {}
        impl Cmdqth {
            pub const fn from_bits(val: u8) -> Cmdqth {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Cmdqth {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmdqth {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Cmdqth {
            #[inline(always)]
            fn from(val: u8) -> Cmdqth {
                Cmdqth::from_bits(val)
            }
        }
        impl From<Cmdqth> for u8 {
            #[inline(always)]
            fn from(val: Cmdqth) -> u8 {
                Cmdqth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Crms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crms {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crms {
            #[inline(always)]
            fn from(val: u8) -> Crms {
                Crms::from_bits(val)
            }
        }
        impl From<Crms> for u8 {
            #[inline(always)]
            fn from(val: Crms) -> u8 {
                Crms::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dnfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dnfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dnfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dnfe {
            #[inline(always)]
            fn from(val: u8) -> Dnfe {
                Dnfe::from_bits(val)
            }
        }
        impl From<Dnfe> for u8 {
            #[inline(always)]
            fn from(val: Dnfe) -> u8 {
                Dnfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dsbrpo {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dsbrpo {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dsbrpo {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dsbrpo {
            #[inline(always)]
            fn from(val: u8) -> Dsbrpo {
                Dsbrpo::from_bits(val)
            }
        }
        impl From<Dsbrpo> for u8 {
            #[inline(always)]
            fn from(val: Dsbrpo) -> u8 {
                Dsbrpo::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvibipl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dvibipl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvibipl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvibipl {
            #[inline(always)]
            fn from(val: u8) -> Dvibipl {
                Dvibipl::from_bits(val)
            }
        }
        impl From<Dvibipl> for u8 {
            #[inline(always)]
            fn from(val: Dvibipl) -> u8 {
                Dvibipl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dvide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvide {
            #[inline(always)]
            fn from(val: u8) -> Dvide {
                Dvide::from_bits(val)
            }
        }
        impl From<Dvide> for u8 {
            #[inline(always)]
            fn from(val: Dvide) -> u8 {
                Dvide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvidf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dvidf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvidf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvidf {
            #[inline(always)]
            fn from(val: u8) -> Dvidf {
                Dvidf::from_bits(val)
            }
        }
        impl From<Dvidf> for u8 {
            #[inline(always)]
            fn from(val: Dvidf) -> u8 {
                Dvidf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvmrrj {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dvmrrj {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvmrrj {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvmrrj {
            #[inline(always)]
            fn from(val: u8) -> Dvmrrj {
                Dvmrrj::from_bits(val)
            }
        }
        impl From<Dvmrrj> for u8 {
            #[inline(always)]
            fn from(val: Dvmrrj) -> u8 {
                Dvmrrj::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvsirrj {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dvsirrj {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvsirrj {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvsirrj {
            #[inline(always)]
            fn from(val: u8) -> Dvsirrj {
                Dvsirrj::from_bits(val)
            }
        }
        impl From<Dvsirrj> for u8 {
            #[inline(always)]
            fn from(val: Dvsirrj) -> u8 {
                Dvsirrj::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dvtyp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dvtyp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dvtyp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dvtyp {
            #[inline(always)]
            fn from(val: u8) -> Dvtyp {
                Dvtyp::from_bits(val)
            }
        }
        impl From<Dvtyp> for u8 {
            #[inline(always)]
            fn from(val: Dvtyp) -> u8 {
                Dvtyp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edtyp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Edtyp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edtyp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edtyp {
            #[inline(always)]
            fn from(val: u8) -> Edtyp {
                Edtyp::from_bits(val)
            }
        }
        impl From<Edtyp> for u8 {
            #[inline(always)]
            fn from(val: Edtyp) -> u8 {
                Edtyp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Excyc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Excyc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Excyc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Excyc {
            #[inline(always)]
            fn from(val: u8) -> Excyc {
                Excyc::from_bits(val)
            }
        }
        impl From<Excyc> for u8 {
            #[inline(always)]
            fn from(val: Excyc) -> u8 {
                Excyc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fmpe {
            #[inline(always)]
            fn from(val: u8) -> Fmpe {
                Fmpe::from_bits(val)
            }
        }
        impl From<Fmpe> for u8 {
            #[inline(always)]
            fn from(val: Fmpe) -> u8 {
                Fmpe::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Freq(u8);
        impl Freq {}
        impl Freq {
            pub const fn from_bits(val: u8) -> Freq {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Freq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freq {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Freq {
            #[inline(always)]
            fn from(val: u8) -> Freq {
                Freq::from_bits(val)
            }
        }
        impl From<Freq> for u8 {
            #[inline(always)]
            fn from(val: Freq) -> u8 {
                Freq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gcae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gcae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gcae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gcae {
            #[inline(always)]
            fn from(val: u8) -> Gcae {
                Gcae::from_bits(val)
            }
        }
        impl From<Gcae> for u8 {
            #[inline(always)]
            fn from(val: Gcae) -> u8 {
                Gcae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gcaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gcaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gcaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gcaf {
            #[inline(always)]
            fn from(val: u8) -> Gcaf {
                Gcaf::from_bits(val)
            }
        }
        impl From<Gcaf> for u8 {
            #[inline(always)]
            fn from(val: Gcaf) -> u8 {
                Gcaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hdrexde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hdrexde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hdrexde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hdrexde {
            #[inline(always)]
            fn from(val: u8) -> Hdrexde {
                Hdrexde::from_bits(val)
            }
        }
        impl From<Hdrexde> for u8 {
            #[inline(always)]
            fn from(val: Hdrexde) -> u8 {
                Hdrexde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hdrexdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hdrexdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hdrexdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hdrexdf {
            #[inline(always)]
            fn from(val: u8) -> Hdrexdf {
                Hdrexdf::from_bits(val)
            }
        }
        impl From<Hdrexdf> for u8 {
            #[inline(always)]
            fn from(val: Hdrexdf) -> u8 {
                Hdrexdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hdrexdfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hdrexdfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hdrexdfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hdrexdfc {
            #[inline(always)]
            fn from(val: u8) -> Hdrexdfc {
                Hdrexdfc::from_bits(val)
            }
        }
        impl From<Hdrexdfc> for u8 {
            #[inline(always)]
            fn from(val: Hdrexdfc) -> u8 {
                Hdrexdfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hdrexdie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hdrexdie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hdrexdie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hdrexdie {
            #[inline(always)]
            fn from(val: u8) -> Hdrexdie {
                Hdrexdie::from_bits(val)
            }
        }
        impl From<Hdrexdie> for u8 {
            #[inline(always)]
            fn from(val: Hdrexdie) -> u8 {
                Hdrexdie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hjackctl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hjackctl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hjackctl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hjackctl {
            #[inline(always)]
            fn from(val: u8) -> Hjackctl {
                Hjackctl::from_bits(val)
            }
        }
        impl From<Hjackctl> for u8 {
            #[inline(always)]
            fn from(val: Hjackctl) -> u8 {
                Hjackctl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hjeve {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hjeve {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hjeve {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hjeve {
            #[inline(always)]
            fn from(val: u8) -> Hjeve {
                Hjeve::from_bits(val)
            }
        }
        impl From<Hjeve> for u8 {
            #[inline(always)]
            fn from(val: Hjeve) -> u8 {
                Hjeve::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hoae {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hoae {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hoae {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hoae {
            #[inline(always)]
            fn from(val: u8) -> Hoae {
                Hoae::from_bits(val)
            }
        }
        impl From<Hoae> for u8 {
            #[inline(always)]
            fn from(val: Hoae) -> u8 {
                Hoae::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hoaf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hoaf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hoaf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hoaf {
            #[inline(always)]
            fn from(val: u8) -> Hoaf {
                Hoaf::from_bits(val)
            }
        }
        impl From<Hoaf> for u8 {
            #[inline(always)]
            fn from(val: Hoaf) -> u8 {
                Hoaf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hsmce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hsmce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hsmce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hsmce {
            #[inline(always)]
            fn from(val: u8) -> Hsmce {
                Hsmce::from_bits(val)
            }
        }
        impl From<Hsmce> for u8 {
            #[inline(always)]
            fn from(val: Hsmce) -> u8 {
                Hsmce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hsmcf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hsmcf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hsmcf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hsmcf {
            #[inline(always)]
            fn from(val: u8) -> Hsmcf {
                Hsmcf::from_bits(val)
            }
        }
        impl From<Hsmcf> for u8 {
            #[inline(always)]
            fn from(val: Hsmcf) -> u8 {
                Hsmcf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hsme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hsme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hsme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hsme {
            #[inline(always)]
            fn from(val: u8) -> Hsme {
                Hsme::from_bits(val)
            }
        }
        impl From<Hsme> for u8 {
            #[inline(always)]
            fn from(val: Hsme) -> u8 {
                Hsme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ibiqefe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ibiqefe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ibiqefe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ibiqefe {
            #[inline(always)]
            fn from(val: u8) -> Ibiqefe {
                Ibiqefe::from_bits(val)
            }
        }
        impl From<Ibiqefe> for u8 {
            #[inline(always)]
            fn from(val: Ibiqefe) -> u8 {
                Ibiqefe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ibiqeff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ibiqeff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ibiqeff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ibiqeff {
            #[inline(always)]
            fn from(val: u8) -> Ibiqeff {
                Ibiqeff::from_bits(val)
            }
        }
        impl From<Ibiqeff> for u8 {
            #[inline(always)]
            fn from(val: Ibiqeff) -> u8 {
                Ibiqeff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ibiqeffc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ibiqeffc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ibiqeffc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ibiqeffc {
            #[inline(always)]
            fn from(val: u8) -> Ibiqeffc {
                Ibiqeffc::from_bits(val)
            }
        }
        impl From<Ibiqeffc> for u8 {
            #[inline(always)]
            fn from(val: Ibiqeffc) -> u8 {
                Ibiqeffc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ibiqefie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ibiqefie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ibiqefie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ibiqefie {
            #[inline(always)]
            fn from(val: u8) -> Ibiqefie {
                Ibiqefie::from_bits(val)
            }
        }
        impl From<Ibiqefie> for u8 {
            #[inline(always)]
            fn from(val: Ibiqefie) -> u8 {
                Ibiqefie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ibiqrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ibiqrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ibiqrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ibiqrst {
            #[inline(always)]
            fn from(val: u8) -> Ibiqrst {
                Ibiqrst::from_bits(val)
            }
        }
        impl From<Ibiqrst> for u8 {
            #[inline(always)]
            fn from(val: Ibiqrst) -> u8 {
                Ibiqrst::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ibiqth(u8);
        impl Ibiqth {}
        impl Ibiqth {
            pub const fn from_bits(val: u8) -> Ibiqth {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Ibiqth {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ibiqth {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Ibiqth {
            #[inline(always)]
            fn from(val: u8) -> Ibiqth {
                Ibiqth::from_bits(val)
            }
        }
        impl From<Ibiqth> for u8 {
            #[inline(always)]
            fn from(val: Ibiqth) -> u8 {
                Ibiqth::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Inac(u8);
        impl Inac {}
        impl Inac {
            pub const fn from_bits(val: u8) -> Inac {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Inac {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inac {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Inac {
            #[inline(always)]
            fn from(val: u8) -> Inac {
                Inac::from_bits(val)
            }
        }
        impl From<Inac> for u8 {
            #[inline(always)]
            fn from(val: Inac) -> u8 {
                Inac::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Incba {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Incba {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Incba {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Incba {
            #[inline(always)]
            fn from(val: u8) -> Incba {
                Incba::from_bits(val)
            }
        }
        impl From<Incba> for u8 {
            #[inline(always)]
            fn from(val: Incba) -> u8 {
                Incba::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inee {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inee {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inee {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inee {
            #[inline(always)]
            fn from(val: u8) -> Inee {
                Inee::from_bits(val)
            }
        }
        impl From<Inee> for u8 {
            #[inline(always)]
            fn from(val: Inee) -> u8 {
                Inee::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inef {
            #[inline(always)]
            fn from(val: u8) -> Inef {
                Inef::from_bits(val)
            }
        }
        impl From<Inef> for u8 {
            #[inline(always)]
            fn from(val: Inef) -> u8 {
                Inef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inefc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Inefc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inefc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inefc {
            #[inline(always)]
            fn from(val: u8) -> Inefc {
                Inefc::from_bits(val)
            }
        }
        impl From<Inefc> for u8 {
            #[inline(always)]
            fn from(val: Inefc) -> u8 {
                Inefc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ineie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ineie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ineie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ineie {
            #[inline(always)]
            fn from(val: u8) -> Ineie {
                Ineie::from_bits(val)
            }
        }
        impl From<Ineie> for u8 {
            #[inline(always)]
            fn from(val: Ineie) -> u8 {
                Ineie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Intlrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Intlrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Intlrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Intlrst {
            #[inline(always)]
            fn from(val: u8) -> Intlrst {
                Intlrst::from_bits(val)
            }
        }
        impl From<Intlrst> for u8 {
            #[inline(always)]
            fn from(val: Intlrst) -> u8 {
                Intlrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irefcks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Irefcks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irefcks {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irefcks {
            #[inline(always)]
            fn from(val: u8) -> Irefcks {
                Irefcks::from_bits(val)
            }
        }
        impl From<Irefcks> for u8 {
            #[inline(always)]
            fn from(val: Irefcks) -> u8 {
                Irefcks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Male {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Male {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Male {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Male {
            #[inline(always)]
            fn from(val: u8) -> Male {
                Male::from_bits(val)
            }
        }
        impl From<Male> for u8 {
            #[inline(always)]
            fn from(val: Male) -> u8 {
                Male::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mdyadv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mdyadv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mdyadv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mdyadv {
            #[inline(always)]
            fn from(val: u8) -> Mdyadv {
                Mdyadv::from_bits(val)
            }
        }
        impl From<Mdyadv> for u8 {
            #[inline(always)]
            fn from(val: Mdyadv) -> u8 {
                Mdyadv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mrte {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mrte {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mrte {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mrte {
            #[inline(always)]
            fn from(val: u8) -> Mrte {
                Mrte::from_bits(val)
            }
        }
        impl From<Mrte> for u8 {
            #[inline(always)]
            fn from(val: Mrte) -> u8 {
                Mrte::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Msrdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Msrdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Msrdr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Msrdr {
            #[inline(always)]
            fn from(val: u8) -> Msrdr {
                Msrdr::from_bits(val)
            }
        }
        impl From<Msrdr> for u8 {
            #[inline(always)]
            fn from(val: Msrdr) -> u8 {
                Msrdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Msrqe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Msrqe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Msrqe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Msrqe {
            #[inline(always)]
            fn from(val: u8) -> Msrqe {
                Msrqe::from_bits(val)
            }
        }
        impl From<Msrqe> for u8 {
            #[inline(always)]
            fn from(val: Msrqe) -> u8 {
                Msrqe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mswdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Mswdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mswdr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mswdr {
            #[inline(always)]
            fn from(val: u8) -> Mswdr {
                Mswdr::from_bits(val)
            }
        }
        impl From<Mswdr> for u8 {
            #[inline(always)]
            fn from(val: Mswdr) -> u8 {
                Mswdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nackde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nackde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nackde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nackde {
            #[inline(always)]
            fn from(val: u8) -> Nackde {
                Nackde::from_bits(val)
            }
        }
        impl From<Nackde> for u8 {
            #[inline(always)]
            fn from(val: Nackde) -> u8 {
                Nackde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nackdf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nackdf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nackdf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nackdf {
            #[inline(always)]
            fn from(val: u8) -> Nackdf {
                Nackdf::from_bits(val)
            }
        }
        impl From<Nackdf> for u8 {
            #[inline(always)]
            fn from(val: Nackdf) -> u8 {
                Nackdf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nackdfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nackdfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nackdfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nackdfc {
            #[inline(always)]
            fn from(val: u8) -> Nackdfc {
                Nackdfc::from_bits(val)
            }
        }
        impl From<Nackdfc> for u8 {
            #[inline(always)]
            fn from(val: Nackdfc) -> u8 {
                Nackdfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nackdie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nackdie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nackdie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nackdie {
            #[inline(always)]
            fn from(val: u8) -> Nackdie {
                Nackdie::from_bits(val)
            }
        }
        impl From<Nackdie> for u8 {
            #[inline(always)]
            fn from(val: Nackdie) -> u8 {
                Nackdie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nale {
            #[inline(always)]
            fn from(val: u8) -> Nale {
                Nale::from_bits(val)
            }
        }
        impl From<Nale> for u8 {
            #[inline(always)]
            fn from(val: Nale) -> u8 {
                Nale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nrhjctl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nrhjctl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nrhjctl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nrhjctl {
            #[inline(always)]
            fn from(val: u8) -> Nrhjctl {
                Nrhjctl::from_bits(val)
            }
        }
        impl From<Nrhjctl> for u8 {
            #[inline(always)]
            fn from(val: Nrhjctl) -> u8 {
                Nrhjctl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nrmrctl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nrmrctl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nrmrctl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nrmrctl {
            #[inline(always)]
            fn from(val: u8) -> Nrmrctl {
                Nrmrctl::from_bits(val)
            }
        }
        impl From<Nrmrctl> for u8 {
            #[inline(always)]
            fn from(val: Nrmrctl) -> u8 {
                Nrmrctl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nrsirctl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nrsirctl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nrsirctl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nrsirctl {
            #[inline(always)]
            fn from(val: u8) -> Nrsirctl {
                Nrsirctl::from_bits(val)
            }
        }
        impl From<Nrsirctl> for u8 {
            #[inline(always)]
            fn from(val: Nrsirctl) -> u8 {
                Nrsirctl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Parpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Parpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Parpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Parpe {
            #[inline(always)]
            fn from(val: u8) -> Parpe {
                Parpe::from_bits(val)
            }
        }
        impl From<Parpe> for u8 {
            #[inline(always)]
            fn from(val: Parpe) -> u8 {
                Parpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prsstwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prsstwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prsstwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prsstwp {
            #[inline(always)]
            fn from(val: u8) -> Prsstwp {
                Prsstwp::from_bits(val)
            }
        }
        impl From<Prsstwp> for u8 {
            #[inline(always)]
            fn from(val: Prsstwp) -> u8 {
                Prsstwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prte {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prte {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prte {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prte {
            #[inline(always)]
            fn from(val: u8) -> Prte {
                Prte::from_bits(val)
            }
        }
        impl From<Prte> for u8 {
            #[inline(always)]
            fn from(val: Prte) -> u8 {
                Prte::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prtmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prtmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prtmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prtmd {
            #[inline(always)]
            fn from(val: u8) -> Prtmd {
                Prtmd::from_bits(val)
            }
        }
        impl From<Prtmd> for u8 {
            #[inline(always)]
            fn from(val: Prtmd) -> u8 {
                Prtmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rbcr0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rbcr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rbcr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rbcr0 {
            #[inline(always)]
            fn from(val: u8) -> Rbcr0 {
                Rbcr0::from_bits(val)
            }
        }
        impl From<Rbcr0> for u8 {
            #[inline(always)]
            fn from(val: Rbcr0) -> u8 {
                Rbcr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rbcr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rbcr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rbcr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rbcr1 {
            #[inline(always)]
            fn from(val: u8) -> Rbcr1 {
                Rbcr1::from_bits(val)
            }
        }
        impl From<Rbcr1> for u8 {
            #[inline(always)]
            fn from(val: Rbcr1) -> u8 {
                Rbcr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rbcr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rbcr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rbcr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rbcr2 {
            #[inline(always)]
            fn from(val: u8) -> Rbcr2 {
                Rbcr2::from_bits(val)
            }
        }
        impl From<Rbcr2> for u8 {
            #[inline(always)]
            fn from(val: Rbcr2) -> u8 {
                Rbcr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rbcr3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rbcr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rbcr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rbcr3 {
            #[inline(always)]
            fn from(val: u8) -> Rbcr3 {
                Rbcr3::from_bits(val)
            }
        }
        impl From<Rbcr3> for u8 {
            #[inline(always)]
            fn from(val: Rbcr3) -> u8 {
                Rbcr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rbcr76 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rbcr76 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rbcr76 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rbcr76 {
            #[inline(always)]
            fn from(val: u8) -> Rbcr76 {
                Rbcr76::from_bits(val)
            }
        }
        impl From<Rbcr76> for u8 {
            #[inline(always)]
            fn from(val: Rbcr76) -> u8 {
                Rbcr76::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdbfe0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdbfe0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdbfe0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdbfe0 {
            #[inline(always)]
            fn from(val: u8) -> Rdbfe0 {
                Rdbfe0::from_bits(val)
            }
        }
        impl From<Rdbfe0> for u8 {
            #[inline(always)]
            fn from(val: Rdbfe0) -> u8 {
                Rdbfe0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdbff0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdbff0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdbff0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdbff0 {
            #[inline(always)]
            fn from(val: u8) -> Rdbff0 {
                Rdbff0::from_bits(val)
            }
        }
        impl From<Rdbff0> for u8 {
            #[inline(always)]
            fn from(val: Rdbff0) -> u8 {
                Rdbff0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdbffc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdbffc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdbffc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdbffc0 {
            #[inline(always)]
            fn from(val: u8) -> Rdbffc0 {
                Rdbffc0::from_bits(val)
            }
        }
        impl From<Rdbffc0> for u8 {
            #[inline(always)]
            fn from(val: Rdbffc0) -> u8 {
                Rdbffc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdbfie0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdbfie0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdbfie0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdbfie0 {
            #[inline(always)]
            fn from(val: u8) -> Rdbfie0 {
                Rdbfie0::from_bits(val)
            }
        }
        impl From<Rdbfie0> for u8 {
            #[inline(always)]
            fn from(val: Rdbfie0) -> u8 {
                Rdbfie0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rdbrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rdbrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rdbrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rdbrst {
            #[inline(always)]
            fn from(val: u8) -> Rdbrst {
                Rdbrst::from_bits(val)
            }
        }
        impl From<Rdbrst> for u8 {
            #[inline(always)]
            fn from(val: Rdbrst) -> u8 {
                Rdbrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ri3crst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ri3crst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ri3crst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ri3crst {
            #[inline(always)]
            fn from(val: u8) -> Ri3crst {
                Ri3crst::from_bits(val)
            }
        }
        impl From<Ri3crst> for u8 {
            #[inline(always)]
            fn from(val: Ri3crst) -> u8 {
                Ri3crst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rsm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rsm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rsm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rsm {
            #[inline(always)]
            fn from(val: u8) -> Rsm {
                Rsm::from_bits(val)
            }
        }
        impl From<Rsm> for u8 {
            #[inline(always)]
            fn from(val: Rsm) -> u8 {
                Rsm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rspqfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rspqfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rspqfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rspqfe {
            #[inline(always)]
            fn from(val: u8) -> Rspqfe {
                Rspqfe::from_bits(val)
            }
        }
        impl From<Rspqfe> for u8 {
            #[inline(always)]
            fn from(val: Rspqfe) -> u8 {
                Rspqfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rspqff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rspqff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rspqff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rspqff {
            #[inline(always)]
            fn from(val: u8) -> Rspqff {
                Rspqff::from_bits(val)
            }
        }
        impl From<Rspqff> for u8 {
            #[inline(always)]
            fn from(val: Rspqff) -> u8 {
                Rspqff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rspqffc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rspqffc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rspqffc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rspqffc {
            #[inline(always)]
            fn from(val: u8) -> Rspqffc {
                Rspqffc::from_bits(val)
            }
        }
        impl From<Rspqffc> for u8 {
            #[inline(always)]
            fn from(val: Rspqffc) -> u8 {
                Rspqffc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rspqfie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rspqfie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rspqfie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rspqfie {
            #[inline(always)]
            fn from(val: u8) -> Rspqfie {
                Rspqfie::from_bits(val)
            }
        }
        impl From<Rspqfie> for u8 {
            #[inline(always)]
            fn from(val: Rspqfie) -> u8 {
                Rspqfie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rspqrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rspqrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rspqrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rspqrst {
            #[inline(always)]
            fn from(val: u8) -> Rspqrst {
                Rspqrst::from_bits(val)
            }
        }
        impl From<Rspqrst> for u8 {
            #[inline(always)]
            fn from(val: Rspqrst) -> u8 {
                Rspqrst::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rspqth(u8);
        impl Rspqth {}
        impl Rspqth {
            pub const fn from_bits(val: u8) -> Rspqth {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Rspqth {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rspqth {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Rspqth {
            #[inline(always)]
            fn from(val: u8) -> Rspqth {
                Rspqth::from_bits(val)
            }
        }
        impl From<Rspqth> for u8 {
            #[inline(always)]
            fn from(val: Rspqth) -> u8 {
                Rspqth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rsqfe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rsqfe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rsqfe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rsqfe {
            #[inline(always)]
            fn from(val: u8) -> Rsqfe {
                Rsqfe::from_bits(val)
            }
        }
        impl From<Rsqfe> for u8 {
            #[inline(always)]
            fn from(val: Rsqfe) -> u8 {
                Rsqfe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rsqff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rsqff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rsqff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rsqff {
            #[inline(always)]
            fn from(val: u8) -> Rsqff {
                Rsqff::from_bits(val)
            }
        }
        impl From<Rsqff> for u8 {
            #[inline(always)]
            fn from(val: Rsqff) -> u8 {
                Rsqff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rsqffc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rsqffc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rsqffc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rsqffc {
            #[inline(always)]
            fn from(val: u8) -> Rsqffc {
                Rsqffc::from_bits(val)
            }
        }
        impl From<Rsqffc> for u8 {
            #[inline(always)]
            fn from(val: Rsqffc) -> u8 {
                Rsqffc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rsqfie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rsqfie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rsqfie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rsqfie {
            #[inline(always)]
            fn from(val: u8) -> Rsqfie {
                Rsqfie::from_bits(val)
            }
        }
        impl From<Rsqfie> for u8 {
            #[inline(always)]
            fn from(val: Rsqfie) -> u8 {
                Rsqfie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rsqrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rsqrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rsqrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rsqrst {
            #[inline(always)]
            fn from(val: u8) -> Rsqrst {
                Rsqrst::from_bits(val)
            }
        }
        impl From<Rsqrst> for u8 {
            #[inline(always)]
            fn from(val: Rsqrst) -> u8 {
                Rsqrst::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rsqth(u8);
        impl Rsqth {}
        impl Rsqth {
            pub const fn from_bits(val: u8) -> Rsqth {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Rsqth {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rsqth {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Rsqth {
            #[inline(always)]
            fn from(val: u8) -> Rsqth {
                Rsqth::from_bits(val)
            }
        }
        impl From<Rsqth> for u8 {
            #[inline(always)]
            fn from(val: Rsqth) -> u8 {
                Rsqth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rwe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rwe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rwe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rwe {
            #[inline(always)]
            fn from(val: u8) -> Rwe {
                Rwe::from_bits(val)
            }
        }
        impl From<Rwe> for u8 {
            #[inline(always)]
            fn from(val: Rwe) -> u8 {
                Rwe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdbth {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rxdbth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdbth {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdbth {
            #[inline(always)]
            fn from(val: u8) -> Rxdbth {
                Rxdbth::from_bits(val)
            }
        }
        impl From<Rxdbth> for u8 {
            #[inline(always)]
            fn from(val: Rxdbth) -> u8 {
                Rxdbth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxstth {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rxstth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxstth {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxstth {
            #[inline(always)]
            fn from(val: u8) -> Rxstth {
                Rxstth::from_bits(val)
            }
        }
        impl From<Rxstth> for u8 {
            #[inline(always)]
            fn from(val: Rxstth) -> u8 {
                Rxstth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sadlg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sadlg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sadlg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sadlg {
            #[inline(always)]
            fn from(val: u8) -> Sadlg {
                Sadlg::from_bits(val)
            }
        }
        impl From<Sadlg> for u8 {
            #[inline(always)]
            fn from(val: Sadlg) -> u8 {
                Sadlg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sale {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sale {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sale {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sale {
            #[inline(always)]
            fn from(val: u8) -> Sale {
                Sale::from_bits(val)
            }
        }
        impl From<Sale> for u8 {
            #[inline(always)]
            fn from(val: Sale) -> u8 {
                Sale::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scoc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scoc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scoc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scoc {
            #[inline(always)]
            fn from(val: u8) -> Scoc {
                Scoc::from_bits(val)
            }
        }
        impl From<Scoc> for u8 {
            #[inline(always)]
            fn from(val: Scoc) -> u8 {
                Scoc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scolv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scolv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scolv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scolv {
            #[inline(always)]
            fn from(val: u8) -> Scolv {
                Scolv::from_bits(val)
            }
        }
        impl From<Scolv> for u8 {
            #[inline(always)]
            fn from(val: Scolv) -> u8 {
                Scolv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Scsyne {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Scsyne {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Scsyne {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Scsyne {
            #[inline(always)]
            fn from(val: u8) -> Scsyne {
                Scsyne::from_bits(val)
            }
        }
        impl From<Scsyne> for u8 {
            #[inline(always)]
            fn from(val: Scsyne) -> u8 {
                Scsyne::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdadls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdadls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdadls {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdadls {
            #[inline(always)]
            fn from(val: u8) -> Sdadls {
                Sdadls::from_bits(val)
            }
        }
        impl From<Sdadls> for u8 {
            #[inline(always)]
            fn from(val: Sdadls) -> u8 {
                Sdadls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdibipl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdibipl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdibipl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdibipl {
            #[inline(always)]
            fn from(val: u8) -> Sdibipl {
                Sdibipl::from_bits(val)
            }
        }
        impl From<Sdibipl> for u8 {
            #[inline(always)]
            fn from(val: Sdibipl) -> u8 {
                Sdibipl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdoc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdoc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdoc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdoc {
            #[inline(always)]
            fn from(val: u8) -> Sdoc {
                Sdoc::from_bits(val)
            }
        }
        impl From<Sdoc> for u8 {
            #[inline(always)]
            fn from(val: Sdoc) -> u8 {
                Sdoc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdod {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sdod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdod {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdod {
            #[inline(always)]
            fn from(val: u8) -> Sdod {
                Sdod::from_bits(val)
            }
        }
        impl From<Sdod> for u8 {
            #[inline(always)]
            fn from(val: Sdod) -> u8 {
                Sdod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdodcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdodcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdodcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdodcs {
            #[inline(always)]
            fn from(val: u8) -> Sdodcs {
                Sdodcs::from_bits(val)
            }
        }
        impl From<Sdodcs> for u8 {
            #[inline(always)]
            fn from(val: Sdodcs) -> u8 {
                Sdodcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdolv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdolv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdolv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdolv {
            #[inline(always)]
            fn from(val: u8) -> Sdolv {
                Sdolv::from_bits(val)
            }
        }
        impl From<Sdolv> for u8 {
            #[inline(always)]
            fn from(val: Sdolv) -> u8 {
                Sdolv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdyadv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdyadv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdyadv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdyadv {
            #[inline(always)]
            fn from(val: u8) -> Sdyadv {
                Sdyadv::from_bits(val)
            }
        }
        impl From<Sdyadv> for u8 {
            #[inline(always)]
            fn from(val: Sdyadv) -> u8 {
                Sdyadv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smbs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smbs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smbs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smbs {
            #[inline(always)]
            fn from(val: u8) -> Smbs {
                Smbs::from_bits(val)
            }
        }
        impl From<Smbs> for u8 {
            #[inline(always)]
            fn from(val: Smbs) -> u8 {
                Smbs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Socwp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Socwp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Socwp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Socwp {
            #[inline(always)]
            fn from(val: u8) -> Socwp {
                Socwp::from_bits(val)
            }
        }
        impl From<Socwp> for u8 {
            #[inline(always)]
            fn from(val: Socwp) -> u8 {
                Socwp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spcnd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spcnd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spcnd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spcnd {
            #[inline(always)]
            fn from(val: u8) -> Spcnd {
                Spcnd::from_bits(val)
            }
        }
        impl From<Spcnd> for u8 {
            #[inline(always)]
            fn from(val: Spcnd) -> u8 {
                Spcnd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spcndde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spcndde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spcndde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spcndde {
            #[inline(always)]
            fn from(val: u8) -> Spcndde {
                Spcndde::from_bits(val)
            }
        }
        impl From<Spcndde> for u8 {
            #[inline(always)]
            fn from(val: Spcndde) -> u8 {
                Spcndde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spcnddf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spcnddf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spcnddf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spcnddf {
            #[inline(always)]
            fn from(val: u8) -> Spcnddf {
                Spcnddf::from_bits(val)
            }
        }
        impl From<Spcnddf> for u8 {
            #[inline(always)]
            fn from(val: Spcnddf) -> u8 {
                Spcnddf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spcnddfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spcnddfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spcnddfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spcnddfc {
            #[inline(always)]
            fn from(val: u8) -> Spcnddfc {
                Spcnddfc::from_bits(val)
            }
        }
        impl From<Spcnddfc> for u8 {
            #[inline(always)]
            fn from(val: Spcnddfc) -> u8 {
                Spcnddfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spcnddie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spcnddie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spcnddie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spcnddie {
            #[inline(always)]
            fn from(val: u8) -> Spcnddie {
                Spcnddie::from_bits(val)
            }
        }
        impl From<Spcnddie> for u8 {
            #[inline(always)]
            fn from(val: Spcnddie) -> u8 {
                Spcnddie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Srcnd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Srcnd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Srcnd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Srcnd {
            #[inline(always)]
            fn from(val: u8) -> Srcnd {
                Srcnd::from_bits(val)
            }
        }
        impl From<Srcnd> for u8 {
            #[inline(always)]
            fn from(val: Srcnd) -> u8 {
                Srcnd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sstadv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sstadv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sstadv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sstadv {
            #[inline(always)]
            fn from(val: u8) -> Sstadv {
                Sstadv::from_bits(val)
            }
        }
        impl From<Sstadv> for u8 {
            #[inline(always)]
            fn from(val: Sstadv) -> u8 {
                Sstadv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stcnd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stcnd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stcnd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stcnd {
            #[inline(always)]
            fn from(val: u8) -> Stcnd {
                Stcnd::from_bits(val)
            }
        }
        impl From<Stcnd> for u8 {
            #[inline(always)]
            fn from(val: Stcnd) -> u8 {
                Stcnd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stcndde {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stcndde {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stcndde {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stcndde {
            #[inline(always)]
            fn from(val: u8) -> Stcndde {
                Stcndde::from_bits(val)
            }
        }
        impl From<Stcndde> for u8 {
            #[inline(always)]
            fn from(val: Stcndde) -> u8 {
                Stcndde::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stcnddf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stcnddf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stcnddf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stcnddf {
            #[inline(always)]
            fn from(val: u8) -> Stcnddf {
                Stcnddf::from_bits(val)
            }
        }
        impl From<Stcnddf> for u8 {
            #[inline(always)]
            fn from(val: Stcnddf) -> u8 {
                Stcnddf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stcnddfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stcnddfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stcnddfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stcnddfc {
            #[inline(always)]
            fn from(val: u8) -> Stcnddfc {
                Stcnddfc::from_bits(val)
            }
        }
        impl From<Stcnddfc> for u8 {
            #[inline(always)]
            fn from(val: Stcnddfc) -> u8 {
                Stcnddfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stcnddie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stcnddie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stcnddie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stcnddie {
            #[inline(always)]
            fn from(val: u8) -> Stcnddie {
                Stcnddie::from_bits(val)
            }
        }
        impl From<Stcnddie> for u8 {
            #[inline(always)]
            fn from(val: Stcnddie) -> u8 {
                Stcnddie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Svae0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Svae0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Svae0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Svae0 {
            #[inline(always)]
            fn from(val: u8) -> Svae0 {
                Svae0::from_bits(val)
            }
        }
        impl From<Svae0> for u8 {
            #[inline(always)]
            fn from(val: Svae0) -> u8 {
                Svae0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Svaf0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Svaf0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Svaf0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Svaf0 {
            #[inline(always)]
            fn from(val: u8) -> Svaf0 {
                Svaf0::from_bits(val)
            }
        }
        impl From<Svaf0> for u8 {
            #[inline(always)]
            fn from(val: Svaf0) -> u8 {
                Svaf0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Svirqe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Svirqe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Svirqe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Svirqe {
            #[inline(always)]
            fn from(val: u8) -> Svirqe {
                Svirqe::from_bits(val)
            }
        }
        impl From<Svirqe> for u8 {
            #[inline(always)]
            fn from(val: Svirqe) -> u8 {
                Svirqe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tabte {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tabte {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tabte {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tabte {
            #[inline(always)]
            fn from(val: u8) -> Tabte {
                Tabte::from_bits(val)
            }
        }
        impl From<Tabte> for u8 {
            #[inline(always)]
            fn from(val: Tabte) -> u8 {
                Tabte::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tabtf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tabtf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tabtf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tabtf {
            #[inline(always)]
            fn from(val: u8) -> Tabtf {
                Tabtf::from_bits(val)
            }
        }
        impl From<Tabtf> for u8 {
            #[inline(always)]
            fn from(val: Tabtf) -> u8 {
                Tabtf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tabtfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tabtfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tabtfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tabtfc {
            #[inline(always)]
            fn from(val: u8) -> Tabtfc {
                Tabtfc::from_bits(val)
            }
        }
        impl From<Tabtfc> for u8 {
            #[inline(always)]
            fn from(val: Tabtfc) -> u8 {
                Tabtfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tabtie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tabtie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tabtie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tabtie {
            #[inline(always)]
            fn from(val: u8) -> Tabtie {
                Tabtie::from_bits(val)
            }
        }
        impl From<Tabtie> for u8 {
            #[inline(always)]
            fn from(val: Tabtie) -> u8 {
                Tabtie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tbcr0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tbcr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tbcr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tbcr0 {
            #[inline(always)]
            fn from(val: u8) -> Tbcr0 {
                Tbcr0::from_bits(val)
            }
        }
        impl From<Tbcr0> for u8 {
            #[inline(always)]
            fn from(val: Tbcr0) -> u8 {
                Tbcr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tbcr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tbcr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tbcr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tbcr1 {
            #[inline(always)]
            fn from(val: u8) -> Tbcr1 {
                Tbcr1::from_bits(val)
            }
        }
        impl From<Tbcr1> for u8 {
            #[inline(always)]
            fn from(val: Tbcr1) -> u8 {
                Tbcr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tbcr2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tbcr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tbcr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tbcr2 {
            #[inline(always)]
            fn from(val: u8) -> Tbcr2 {
                Tbcr2::from_bits(val)
            }
        }
        impl From<Tbcr2> for u8 {
            #[inline(always)]
            fn from(val: Tbcr2) -> u8 {
                Tbcr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tbcr3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tbcr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tbcr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tbcr3 {
            #[inline(always)]
            fn from(val: u8) -> Tbcr3 {
                Tbcr3::from_bits(val)
            }
        }
        impl From<Tbcr3> for u8 {
            #[inline(always)]
            fn from(val: Tbcr3) -> u8 {
                Tbcr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tbcr76 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tbcr76 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tbcr76 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tbcr76 {
            #[inline(always)]
            fn from(val: u8) -> Tbcr76 {
                Tbcr76::from_bits(val)
            }
        }
        impl From<Tbcr76> for u8 {
            #[inline(always)]
            fn from(val: Tbcr76) -> u8 {
                Tbcr76::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdbee0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdbee0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdbee0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdbee0 {
            #[inline(always)]
            fn from(val: u8) -> Tdbee0 {
                Tdbee0::from_bits(val)
            }
        }
        impl From<Tdbee0> for u8 {
            #[inline(always)]
            fn from(val: Tdbee0) -> u8 {
                Tdbee0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdbef0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdbef0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdbef0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdbef0 {
            #[inline(always)]
            fn from(val: u8) -> Tdbef0 {
                Tdbef0::from_bits(val)
            }
        }
        impl From<Tdbef0> for u8 {
            #[inline(always)]
            fn from(val: Tdbef0) -> u8 {
                Tdbef0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdbefc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdbefc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdbefc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdbefc0 {
            #[inline(always)]
            fn from(val: u8) -> Tdbefc0 {
                Tdbefc0::from_bits(val)
            }
        }
        impl From<Tdbefc0> for u8 {
            #[inline(always)]
            fn from(val: Tdbefc0) -> u8 {
                Tdbefc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdbeie0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdbeie0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdbeie0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdbeie0 {
            #[inline(always)]
            fn from(val: u8) -> Tdbeie0 {
                Tdbeie0::from_bits(val)
            }
        }
        impl From<Tdbeie0> for u8 {
            #[inline(always)]
            fn from(val: Tdbeie0) -> u8 {
                Tdbeie0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tdbrst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tdbrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tdbrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tdbrst {
            #[inline(always)]
            fn from(val: u8) -> Tdbrst {
                Tdbrst::from_bits(val)
            }
        }
        impl From<Tdbrst> for u8 {
            #[inline(always)]
            fn from(val: Tdbrst) -> u8 {
                Tdbrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tee {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tee {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tee {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tee {
            #[inline(always)]
            fn from(val: u8) -> Tee {
                Tee::from_bits(val)
            }
        }
        impl From<Tee> for u8 {
            #[inline(always)]
            fn from(val: Tee) -> u8 {
                Tee::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tef {
            #[inline(always)]
            fn from(val: u8) -> Tef {
                Tef::from_bits(val)
            }
        }
        impl From<Tef> for u8 {
            #[inline(always)]
            fn from(val: Tef) -> u8 {
                Tef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tefc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tefc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tefc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tefc {
            #[inline(always)]
            fn from(val: u8) -> Tefc {
                Tefc::from_bits(val)
            }
        }
        impl From<Tefc> for u8 {
            #[inline(always)]
            fn from(val: Tefc) -> u8 {
                Tefc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tende {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tende {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tende {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tende {
            #[inline(always)]
            fn from(val: u8) -> Tende {
                Tende::from_bits(val)
            }
        }
        impl From<Tende> for u8 {
            #[inline(always)]
            fn from(val: Tende) -> u8 {
                Tende::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tendf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tendf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tendf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tendf {
            #[inline(always)]
            fn from(val: u8) -> Tendf {
                Tendf::from_bits(val)
            }
        }
        impl From<Tendf> for u8 {
            #[inline(always)]
            fn from(val: Tendf) -> u8 {
                Tendf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tendfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tendfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tendfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tendfc {
            #[inline(always)]
            fn from(val: u8) -> Tendfc {
                Tendfc::from_bits(val)
            }
        }
        impl From<Tendfc> for u8 {
            #[inline(always)]
            fn from(val: Tendfc) -> u8 {
                Tendfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tendie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tendie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tendie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tendie {
            #[inline(always)]
            fn from(val: u8) -> Tendie {
                Tendie::from_bits(val)
            }
        }
        impl From<Tendie> for u8 {
            #[inline(always)]
            fn from(val: Tendie) -> u8 {
                Tendie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tode {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tode {
            #[inline(always)]
            fn from(val: u8) -> Tode {
                Tode::from_bits(val)
            }
        }
        impl From<Tode> for u8 {
            #[inline(always)]
            fn from(val: Tode) -> u8 {
                Tode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Todf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Todf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Todf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Todf {
            #[inline(always)]
            fn from(val: u8) -> Todf {
                Todf::from_bits(val)
            }
        }
        impl From<Todf> for u8 {
            #[inline(always)]
            fn from(val: Todf) -> u8 {
                Todf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Todfc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Todfc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Todfc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Todfc {
            #[inline(always)]
            fn from(val: u8) -> Todfc {
                Todfc::from_bits(val)
            }
        }
        impl From<Todfc> for u8 {
            #[inline(always)]
            fn from(val: Todfc) -> u8 {
                Todfc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Todie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Todie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Todie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Todie {
            #[inline(always)]
            fn from(val: u8) -> Todie {
                Todie::from_bits(val)
            }
        }
        impl From<Todie> for u8 {
            #[inline(always)]
            fn from(val: Todie) -> u8 {
                Todie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Todts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Todts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Todts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Todts {
            #[inline(always)]
            fn from(val: u8) -> Todts {
                Todts::from_bits(val)
            }
        }
        impl From<Todts> for u8 {
            #[inline(always)]
            fn from(val: Todts) -> u8 {
                Todts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tohctl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tohctl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tohctl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tohctl {
            #[inline(always)]
            fn from(val: u8) -> Tohctl {
                Tohctl::from_bits(val)
            }
        }
        impl From<Tohctl> for u8 {
            #[inline(always)]
            fn from(val: Tohctl) -> u8 {
                Tohctl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tolctl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Tolctl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tolctl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tolctl {
            #[inline(always)]
            fn from(val: u8) -> Tolctl {
                Tolctl::from_bits(val)
            }
        }
        impl From<Tolctl> for u8 {
            #[inline(always)]
            fn from(val: Tolctl) -> u8 {
                Tolctl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tomds {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tomds {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tomds {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tomds {
            #[inline(always)]
            fn from(val: u8) -> Tomds {
                Tomds::from_bits(val)
            }
        }
        impl From<Tomds> for u8 {
            #[inline(always)]
            fn from(val: Tomds) -> u8 {
                Tomds::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trape {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trape {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trape {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trape {
            #[inline(always)]
            fn from(val: u8) -> Trape {
                Trape::from_bits(val)
            }
        }
        impl From<Trape> for u8 {
            #[inline(always)]
            fn from(val: Trape) -> u8 {
                Trape::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Trmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trmd {
            #[inline(always)]
            fn from(val: u8) -> Trmd {
                Trmd::from_bits(val)
            }
        }
        impl From<Trmd> for u8 {
            #[inline(always)]
            fn from(val: Trmd) -> u8 {
                Trmd::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Tstmd(u8);
        impl Tstmd {}
        impl Tstmd {
            pub const fn from_bits(val: u8) -> Tstmd {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Tstmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tstmd {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Tstmd {
            #[inline(always)]
            fn from(val: u8) -> Tstmd {
                Tstmd::from_bits(val)
            }
        }
        impl From<Tstmd> for u8 {
            #[inline(always)]
            fn from(val: Tstmd) -> u8 {
                Tstmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txdbth {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Txdbth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txdbth {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txdbth {
            #[inline(always)]
            fn from(val: u8) -> Txdbth {
                Txdbth::from_bits(val)
            }
        }
        impl From<Txdbth> for u8 {
            #[inline(always)]
            fn from(val: Txdbth) -> u8 {
                Txdbth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txstth {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Txstth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txstth {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txstth {
            #[inline(always)]
            fn from(val: u8) -> Txstth {
                Txstth::from_bits(val)
            }
        }
        impl From<Txstth> for u8 {
            #[inline(always)]
            fn from(val: Txstth) -> u8 {
                Txstth::to_bits(val)
            }
        }
    }
}
pub mod icu {
    #[doc = "ICU for CPU"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Icu {
        ptr: *mut u8,
    }
    unsafe impl Send for Icu {}
    unsafe impl Sync for Icu {}
    impl Icu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IRQ Control Register %s"]
        #[inline(always)]
        pub const fn irqcr(self, n: usize) -> crate::common::Reg<regs::Irqcr, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 1usize) as _) }
        }
        #[doc = "NMI Pin Interrupt Control Register"]
        #[inline(always)]
        pub const fn nmicr(self) -> crate::common::Reg<regs::Nmicr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Enable Register"]
        #[inline(always)]
        pub const fn nmier(self) -> crate::common::Reg<regs::Nmier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Status Clear Register"]
        #[inline(always)]
        pub const fn nmiclr(self) -> crate::common::Reg<regs::Nmiclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Non,Maskable Interrupt Status Register"]
        #[inline(always)]
        pub const fn nmisr(self) -> crate::common::Reg<regs::Nmisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "Wake Up Interrupt Enable Register"]
        #[inline(always)]
        pub const fn wupen(self) -> crate::common::Reg<regs::Wupen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a0usize) as _) }
        }
        #[doc = "ICU event Enable Register"]
        #[inline(always)]
        pub const fn ielen(self) -> crate::common::Reg<regs::Ielen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "SYS Event Link Setting Register"]
        #[inline(always)]
        pub const fn selsr0(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "ICU Event Link Setting Register %s"]
        #[inline(always)]
        pub const fn ielsr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "ICU event Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ielen(pub u8);
        impl Ielen {
            #[doc = "Parts Asynchronous Interrupts Enable (when LPOPTEN bit = 1)"]
            #[inline(always)]
            pub const fn ielen(&self) -> super::vals::Ielen {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ielen::from_bits(val as u8)
            }
            #[doc = "Parts Asynchronous Interrupts Enable (when LPOPTEN bit = 1)"]
            #[inline(always)]
            pub fn set_ielen(&mut self, val: super::vals::Ielen) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Ielen {
            #[inline(always)]
            fn default() -> Ielen {
                Ielen(0)
            }
        }
        impl core::fmt::Debug for Ielen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ielen")
                    .field("ielen", &self.ielen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ielen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ielen {{ ielen: {:?} }}", self.ielen())
            }
        }
        #[doc = "IRQ Control Register %s"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Irqcr(pub u8);
        impl Irqcr {
            #[doc = "IRQi Detection Sense Select"]
            #[inline(always)]
            pub const fn irqmd(&self) -> super::vals::Irqmd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Irqmd::from_bits(val as u8)
            }
            #[doc = "IRQi Detection Sense Select"]
            #[inline(always)]
            pub fn set_irqmd(&mut self, val: super::vals::Irqmd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "IRQi Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub const fn fclksel(&self) -> super::vals::Fclksel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Fclksel::from_bits(val as u8)
            }
            #[doc = "IRQi Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub fn set_fclksel(&mut self, val: super::vals::Fclksel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "IRQi Digital Filter Enable"]
            #[inline(always)]
            pub const fn flten(&self) -> super::vals::Flten {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Flten::from_bits(val as u8)
            }
            #[doc = "IRQi Digital Filter Enable"]
            #[inline(always)]
            pub fn set_flten(&mut self, val: super::vals::Flten) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Irqcr {
            #[inline(always)]
            fn default() -> Irqcr {
                Irqcr(0)
            }
        }
        impl core::fmt::Debug for Irqcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Irqcr")
                    .field("irqmd", &self.irqmd())
                    .field("fclksel", &self.fclksel())
                    .field("flten", &self.flten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Irqcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Irqcr {{ irqmd: {:?}, fclksel: {:?}, flten: {:?} }}",
                    self.irqmd(),
                    self.fclksel(),
                    self.flten()
                )
            }
        }
        #[doc = "Non,Maskable Interrupt Status Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmiclr(pub u16);
        impl Nmiclr {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn iwdtclr(&self) -> super::vals::Iwdtclr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtclr::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_iwdtclr(&mut self, val: super::vals::Iwdtclr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn wdtclr(&self) -> super::vals::Wdtclr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtclr::from_bits(val as u8)
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_wdtclr(&mut self, val: super::vals::Wdtclr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn lvd1clr(&self) -> super::vals::Lvd1clr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1clr::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_lvd1clr(&mut self, val: super::vals::Lvd1clr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn lvd2clr(&self) -> super::vals::Lvd2clr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2clr::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_lvd2clr(&mut self, val: super::vals::Lvd2clr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "NMI Pin Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn nmiclr(&self) -> super::vals::Nmiclr {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmiclr::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_nmiclr(&mut self, val: super::vals::Nmiclr) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn rpeclr(&self) -> super::vals::Rpeclr {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpeclr::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_rpeclr(&mut self, val: super::vals::Rpeclr) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Bus Slave MPU Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn bussclr(&self) -> super::vals::Bussclr {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussclr::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_bussclr(&mut self, val: super::vals::Bussclr) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn busmclr(&self) -> super::vals::Busmclr {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmclr::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Error Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_busmclr(&mut self, val: super::vals::Busmclr) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag Clear"]
            #[inline(always)]
            pub const fn speclr(&self) -> super::vals::Speclr {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Speclr::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag Clear"]
            #[inline(always)]
            pub fn set_speclr(&mut self, val: super::vals::Speclr) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Nmiclr {
            #[inline(always)]
            fn default() -> Nmiclr {
                Nmiclr(0)
            }
        }
        impl core::fmt::Debug for Nmiclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmiclr")
                    .field("iwdtclr", &self.iwdtclr())
                    .field("wdtclr", &self.wdtclr())
                    .field("lvd1clr", &self.lvd1clr())
                    .field("lvd2clr", &self.lvd2clr())
                    .field("nmiclr", &self.nmiclr())
                    .field("rpeclr", &self.rpeclr())
                    .field("bussclr", &self.bussclr())
                    .field("busmclr", &self.busmclr())
                    .field("speclr", &self.speclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmiclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmiclr {{ iwdtclr: {:?}, wdtclr: {:?}, lvd1clr: {:?}, lvd2clr: {:?}, nmiclr: {:?}, rpeclr: {:?}, bussclr: {:?}, busmclr: {:?}, speclr: {:?} }}" , self . iwdtclr () , self . wdtclr () , self . lvd1clr () , self . lvd2clr () , self . nmiclr () , self . rpeclr () , self . bussclr () , self . busmclr () , self . speclr ())
            }
        }
        #[doc = "NMI Pin Interrupt Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmicr(pub u8);
        impl Nmicr {
            #[doc = "NMI Detection Set"]
            #[inline(always)]
            pub const fn nmimd(&self) -> super::vals::Nmimd {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Nmimd::from_bits(val as u8)
            }
            #[doc = "NMI Detection Set"]
            #[inline(always)]
            pub fn set_nmimd(&mut self, val: super::vals::Nmimd) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "NMI Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub const fn nfclksel(&self) -> super::vals::Nfclksel {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Nfclksel::from_bits(val as u8)
            }
            #[doc = "NMI Digital Filter Sampling Clock Select"]
            #[inline(always)]
            pub fn set_nfclksel(&mut self, val: super::vals::Nfclksel) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "NMI Digital Filter Enable"]
            #[inline(always)]
            pub const fn nflten(&self) -> super::vals::Nflten {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nflten::from_bits(val as u8)
            }
            #[doc = "NMI Digital Filter Enable"]
            #[inline(always)]
            pub fn set_nflten(&mut self, val: super::vals::Nflten) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Nmicr {
            #[inline(always)]
            fn default() -> Nmicr {
                Nmicr(0)
            }
        }
        impl core::fmt::Debug for Nmicr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmicr")
                    .field("nmimd", &self.nmimd())
                    .field("nfclksel", &self.nfclksel())
                    .field("nflten", &self.nflten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmicr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nmicr {{ nmimd: {:?}, nfclksel: {:?}, nflten: {:?} }}",
                    self.nmimd(),
                    self.nfclksel(),
                    self.nflten()
                )
            }
        }
        #[doc = "Non,Maskable Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmier(pub u16);
        impl Nmier {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub const fn iwdten(&self) -> super::vals::Iwdten {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdten::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_iwdten(&mut self, val: super::vals::Iwdten) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub const fn wdten(&self) -> super::vals::Wdten {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdten::from_bits(val as u8)
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_wdten(&mut self, val: super::vals::Wdten) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Voltage monitor 1 Interrupt Enable"]
            #[inline(always)]
            pub const fn lvd1en(&self) -> super::vals::Lvd1en {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1en::from_bits(val as u8)
            }
            #[doc = "Voltage monitor 1 Interrupt Enable"]
            #[inline(always)]
            pub fn set_lvd1en(&mut self, val: super::vals::Lvd1en) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Voltage monitor 2 Interrupt Enable"]
            #[inline(always)]
            pub const fn lvd2en(&self) -> super::vals::Lvd2en {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2en::from_bits(val as u8)
            }
            #[doc = "Voltage monitor 2 Interrupt Enable"]
            #[inline(always)]
            pub fn set_lvd2en(&mut self, val: super::vals::Lvd2en) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "NMI Pin Interrupt Enable"]
            #[inline(always)]
            pub const fn nmien(&self) -> super::vals::Nmien {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmien::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Enable"]
            #[inline(always)]
            pub fn set_nmien(&mut self, val: super::vals::Nmien) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Enable"]
            #[inline(always)]
            pub const fn rpeen(&self) -> super::vals::Rpeen {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpeen::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_rpeen(&mut self, val: super::vals::Rpeen) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Bus Slave MPU Error Interrupt Enable"]
            #[inline(always)]
            pub const fn bussen(&self) -> super::vals::Bussen {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussen::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_bussen(&mut self, val: super::vals::Bussen) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Error Interrupt Enable"]
            #[inline(always)]
            pub const fn busmen(&self) -> super::vals::Busmen {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmen::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_busmen(&mut self, val: super::vals::Busmen) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Enable"]
            #[inline(always)]
            pub const fn speen(&self) -> super::vals::Speen {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Speen::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Enable"]
            #[inline(always)]
            pub fn set_speen(&mut self, val: super::vals::Speen) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Nmier {
            #[inline(always)]
            fn default() -> Nmier {
                Nmier(0)
            }
        }
        impl core::fmt::Debug for Nmier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmier")
                    .field("iwdten", &self.iwdten())
                    .field("wdten", &self.wdten())
                    .field("lvd1en", &self.lvd1en())
                    .field("lvd2en", &self.lvd2en())
                    .field("nmien", &self.nmien())
                    .field("rpeen", &self.rpeen())
                    .field("bussen", &self.bussen())
                    .field("busmen", &self.busmen())
                    .field("speen", &self.speen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmier {{ iwdten: {:?}, wdten: {:?}, lvd1en: {:?}, lvd2en: {:?}, nmien: {:?}, rpeen: {:?}, bussen: {:?}, busmen: {:?}, speen: {:?} }}" , self . iwdten () , self . wdten () , self . lvd1en () , self . lvd2en () , self . nmien () , self . rpeen () , self . bussen () , self . busmen () , self . speen ())
            }
        }
        #[doc = "Non,Maskable Interrupt Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmisr(pub u16);
        impl Nmisr {
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn iwdtst(&self) -> super::vals::Iwdtst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtst::from_bits(val as u8)
            }
            #[doc = "IWDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_iwdtst(&mut self, val: super::vals::Iwdtst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn wdtst(&self) -> super::vals::Wdtst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtst::from_bits(val as u8)
            }
            #[doc = "WDT Underflow/Refresh Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_wdtst(&mut self, val: super::vals::Wdtst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag"]
            #[inline(always)]
            pub const fn lvd1st(&self) -> super::vals::Lvd1st {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1st::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_lvd1st(&mut self, val: super::vals::Lvd1st) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Interrupt Status Flag"]
            #[inline(always)]
            pub const fn lvd2st(&self) -> super::vals::Lvd2st {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2st::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_lvd2st(&mut self, val: super::vals::Lvd2st) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "NMI Pin Interrupt Status Flag"]
            #[inline(always)]
            pub const fn nmist(&self) -> super::vals::Nmist {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nmist::from_bits(val as u8)
            }
            #[doc = "NMI Pin Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_nmist(&mut self, val: super::vals::Nmist) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn rpest(&self) -> super::vals::Rpest {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rpest::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_rpest(&mut self, val: super::vals::Rpest) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Bus Slave MPU Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn bussst(&self) -> super::vals::Bussst {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussst::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_bussst(&mut self, val: super::vals::Bussst) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Error Interrupt Status Flag"]
            #[inline(always)]
            pub const fn busmst(&self) -> super::vals::Busmst {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmst::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Error Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_busmst(&mut self, val: super::vals::Busmst) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag"]
            #[inline(always)]
            pub const fn spest(&self) -> super::vals::Spest {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Spest::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Monitor Interrupt Status Flag"]
            #[inline(always)]
            pub fn set_spest(&mut self, val: super::vals::Spest) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Nmisr {
            #[inline(always)]
            fn default() -> Nmisr {
                Nmisr(0)
            }
        }
        impl core::fmt::Debug for Nmisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmisr")
                    .field("iwdtst", &self.iwdtst())
                    .field("wdtst", &self.wdtst())
                    .field("lvd1st", &self.lvd1st())
                    .field("lvd2st", &self.lvd2st())
                    .field("nmist", &self.nmist())
                    .field("rpest", &self.rpest())
                    .field("bussst", &self.bussst())
                    .field("busmst", &self.busmst())
                    .field("spest", &self.spest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmisr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Nmisr {{ iwdtst: {:?}, wdtst: {:?}, lvd1st: {:?}, lvd2st: {:?}, nmist: {:?}, rpest: {:?}, bussst: {:?}, busmst: {:?}, spest: {:?} }}" , self . iwdtst () , self . wdtst () , self . lvd1st () , self . lvd2st () , self . nmist () , self . rpest () , self . bussst () , self . busmst () , self . spest ())
            }
        }
        #[doc = "Wake Up Interrupt Enable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wupen(pub u32);
        impl Wupen {
            #[doc = "IRQ Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn irqwupen(&self) -> super::vals::Irqwupen {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Irqwupen::from_bits(val as u8)
            }
            #[doc = "IRQ Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_irqwupen(&mut self, val: super::vals::Irqwupen) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
            #[doc = "IWDT Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn iwdtwupen(&self) -> super::vals::Iwdtwupen {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Iwdtwupen::from_bits(val as u8)
            }
            #[doc = "IWDT Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_iwdtwupen(&mut self, val: super::vals::Iwdtwupen) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Key Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn keywupen(&self) -> super::vals::Keywupen {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Keywupen::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_keywupen(&mut self, val: super::vals::Keywupen) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "LVD1 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn lvd1wupen(&self) -> super::vals::Lvd1wupen {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Lvd1wupen::from_bits(val as u8)
            }
            #[doc = "LVD1 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_lvd1wupen(&mut self, val: super::vals::Lvd1wupen) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "LVD2 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn lvd2wupen(&self) -> super::vals::Lvd2wupen {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Lvd2wupen::from_bits(val as u8)
            }
            #[doc = "LVD2 Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_lvd2wupen(&mut self, val: super::vals::Lvd2wupen) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "AGT1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt1udwupen(&self) -> super::vals::Agt1udwupen {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Agt1udwupen::from_bits(val as u8)
            }
            #[doc = "AGT1 Underflow Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt1udwupen(&mut self, val: super::vals::Agt1udwupen) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "AGT1 Compare Match A Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt1cawupen(&self) -> super::vals::Agt1cawupen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Agt1cawupen::from_bits(val as u8)
            }
            #[doc = "AGT1 Compare Match A Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt1cawupen(&mut self, val: super::vals::Agt1cawupen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "AGT1 Compare Match B Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub const fn agt1cbwupen(&self) -> super::vals::Agt1cbwupen {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Agt1cbwupen::from_bits(val as u8)
            }
            #[doc = "AGT1 Compare Match B Interrupt Software Standby/Snooze Mode Returns Enable"]
            #[inline(always)]
            pub fn set_agt1cbwupen(&mut self, val: super::vals::Agt1cbwupen) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Wupen {
            #[inline(always)]
            fn default() -> Wupen {
                Wupen(0)
            }
        }
        impl core::fmt::Debug for Wupen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wupen")
                    .field("irqwupen", &self.irqwupen())
                    .field("iwdtwupen", &self.iwdtwupen())
                    .field("keywupen", &self.keywupen())
                    .field("lvd1wupen", &self.lvd1wupen())
                    .field("lvd2wupen", &self.lvd2wupen())
                    .field("agt1udwupen", &self.agt1udwupen())
                    .field("agt1cawupen", &self.agt1cawupen())
                    .field("agt1cbwupen", &self.agt1cbwupen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wupen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Wupen {{ irqwupen: {:?}, iwdtwupen: {:?}, keywupen: {:?}, lvd1wupen: {:?}, lvd2wupen: {:?}, agt1udwupen: {:?}, agt1cawupen: {:?}, agt1cbwupen: {:?} }}" , self . irqwupen () , self . iwdtwupen () , self . keywupen () , self . lvd1wupen () , self . lvd2wupen () , self . agt1udwupen () , self . agt1cawupen () , self . agt1cbwupen ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt1cawupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt1cawupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt1cawupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt1cawupen {
            #[inline(always)]
            fn from(val: u8) -> Agt1cawupen {
                Agt1cawupen::from_bits(val)
            }
        }
        impl From<Agt1cawupen> for u8 {
            #[inline(always)]
            fn from(val: Agt1cawupen) -> u8 {
                Agt1cawupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt1cbwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt1cbwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt1cbwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt1cbwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt1cbwupen {
                Agt1cbwupen::from_bits(val)
            }
        }
        impl From<Agt1cbwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt1cbwupen) -> u8 {
                Agt1cbwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agt1udwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agt1udwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agt1udwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agt1udwupen {
            #[inline(always)]
            fn from(val: u8) -> Agt1udwupen {
                Agt1udwupen::from_bits(val)
            }
        }
        impl From<Agt1udwupen> for u8 {
            #[inline(always)]
            fn from(val: Agt1udwupen) -> u8 {
                Agt1udwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmclr {
            #[inline(always)]
            fn from(val: u8) -> Busmclr {
                Busmclr::from_bits(val)
            }
        }
        impl From<Busmclr> for u8 {
            #[inline(always)]
            fn from(val: Busmclr) -> u8 {
                Busmclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmen {
            #[inline(always)]
            fn from(val: u8) -> Busmen {
                Busmen::from_bits(val)
            }
        }
        impl From<Busmen> for u8 {
            #[inline(always)]
            fn from(val: Busmen) -> u8 {
                Busmen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmst {
            #[inline(always)]
            fn from(val: u8) -> Busmst {
                Busmst::from_bits(val)
            }
        }
        impl From<Busmst> for u8 {
            #[inline(always)]
            fn from(val: Busmst) -> u8 {
                Busmst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussclr {
            #[inline(always)]
            fn from(val: u8) -> Bussclr {
                Bussclr::from_bits(val)
            }
        }
        impl From<Bussclr> for u8 {
            #[inline(always)]
            fn from(val: Bussclr) -> u8 {
                Bussclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussen {
            #[inline(always)]
            fn from(val: u8) -> Bussen {
                Bussen::from_bits(val)
            }
        }
        impl From<Bussen> for u8 {
            #[inline(always)]
            fn from(val: Bussen) -> u8 {
                Bussen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussst {
            #[inline(always)]
            fn from(val: u8) -> Bussst {
                Bussst::from_bits(val)
            }
        }
        impl From<Bussst> for u8 {
            #[inline(always)]
            fn from(val: Bussst) -> u8 {
                Bussst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fclksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Fclksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fclksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fclksel {
            #[inline(always)]
            fn from(val: u8) -> Fclksel {
                Fclksel::from_bits(val)
            }
        }
        impl From<Fclksel> for u8 {
            #[inline(always)]
            fn from(val: Fclksel) -> u8 {
                Fclksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Flten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flten {
            #[inline(always)]
            fn from(val: u8) -> Flten {
                Flten::from_bits(val)
            }
        }
        impl From<Flten> for u8 {
            #[inline(always)]
            fn from(val: Flten) -> u8 {
                Flten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ielen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ielen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ielen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ielen {
            #[inline(always)]
            fn from(val: u8) -> Ielen {
                Ielen::from_bits(val)
            }
        }
        impl From<Ielen> for u8 {
            #[inline(always)]
            fn from(val: Ielen) -> u8 {
                Ielen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Irqmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Irqmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Irqmd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Irqmd {
            #[inline(always)]
            fn from(val: u8) -> Irqmd {
                Irqmd::from_bits(val)
            }
        }
        impl From<Irqmd> for u8 {
            #[inline(always)]
            fn from(val: Irqmd) -> u8 {
                Irqmd::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Irqwupen(u8);
        impl Irqwupen {}
        impl Irqwupen {
            pub const fn from_bits(val: u8) -> Irqwupen {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Irqwupen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Irqwupen {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Irqwupen {
            #[inline(always)]
            fn from(val: u8) -> Irqwupen {
                Irqwupen::from_bits(val)
            }
        }
        impl From<Irqwupen> for u8 {
            #[inline(always)]
            fn from(val: Irqwupen) -> u8 {
                Irqwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtclr {
            #[inline(always)]
            fn from(val: u8) -> Iwdtclr {
                Iwdtclr::from_bits(val)
            }
        }
        impl From<Iwdtclr> for u8 {
            #[inline(always)]
            fn from(val: Iwdtclr) -> u8 {
                Iwdtclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdten {
            #[inline(always)]
            fn from(val: u8) -> Iwdten {
                Iwdten::from_bits(val)
            }
        }
        impl From<Iwdten> for u8 {
            #[inline(always)]
            fn from(val: Iwdten) -> u8 {
                Iwdten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtst {
            #[inline(always)]
            fn from(val: u8) -> Iwdtst {
                Iwdtst::from_bits(val)
            }
        }
        impl From<Iwdtst> for u8 {
            #[inline(always)]
            fn from(val: Iwdtst) -> u8 {
                Iwdtst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtwupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtwupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtwupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtwupen {
            #[inline(always)]
            fn from(val: u8) -> Iwdtwupen {
                Iwdtwupen::from_bits(val)
            }
        }
        impl From<Iwdtwupen> for u8 {
            #[inline(always)]
            fn from(val: Iwdtwupen) -> u8 {
                Iwdtwupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Keywupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Keywupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Keywupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Keywupen {
            #[inline(always)]
            fn from(val: u8) -> Keywupen {
                Keywupen::from_bits(val)
            }
        }
        impl From<Keywupen> for u8 {
            #[inline(always)]
            fn from(val: Keywupen) -> u8 {
                Keywupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1clr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1clr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1clr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1clr {
            #[inline(always)]
            fn from(val: u8) -> Lvd1clr {
                Lvd1clr::from_bits(val)
            }
        }
        impl From<Lvd1clr> for u8 {
            #[inline(always)]
            fn from(val: Lvd1clr) -> u8 {
                Lvd1clr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1en {
            #[inline(always)]
            fn from(val: u8) -> Lvd1en {
                Lvd1en::from_bits(val)
            }
        }
        impl From<Lvd1en> for u8 {
            #[inline(always)]
            fn from(val: Lvd1en) -> u8 {
                Lvd1en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1st {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1st {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1st {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1st {
            #[inline(always)]
            fn from(val: u8) -> Lvd1st {
                Lvd1st::from_bits(val)
            }
        }
        impl From<Lvd1st> for u8 {
            #[inline(always)]
            fn from(val: Lvd1st) -> u8 {
                Lvd1st::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1wupen {
            #[inline(always)]
            fn from(val: u8) -> Lvd1wupen {
                Lvd1wupen::from_bits(val)
            }
        }
        impl From<Lvd1wupen> for u8 {
            #[inline(always)]
            fn from(val: Lvd1wupen) -> u8 {
                Lvd1wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2clr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2clr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2clr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2clr {
            #[inline(always)]
            fn from(val: u8) -> Lvd2clr {
                Lvd2clr::from_bits(val)
            }
        }
        impl From<Lvd2clr> for u8 {
            #[inline(always)]
            fn from(val: Lvd2clr) -> u8 {
                Lvd2clr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2en {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2en {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2en {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2en {
            #[inline(always)]
            fn from(val: u8) -> Lvd2en {
                Lvd2en::from_bits(val)
            }
        }
        impl From<Lvd2en> for u8 {
            #[inline(always)]
            fn from(val: Lvd2en) -> u8 {
                Lvd2en::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2st {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2st {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2st {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2st {
            #[inline(always)]
            fn from(val: u8) -> Lvd2st {
                Lvd2st::from_bits(val)
            }
        }
        impl From<Lvd2st> for u8 {
            #[inline(always)]
            fn from(val: Lvd2st) -> u8 {
                Lvd2st::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2wupen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2wupen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2wupen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2wupen {
            #[inline(always)]
            fn from(val: u8) -> Lvd2wupen {
                Lvd2wupen::from_bits(val)
            }
        }
        impl From<Lvd2wupen> for u8 {
            #[inline(always)]
            fn from(val: Lvd2wupen) -> u8 {
                Lvd2wupen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfclksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfclksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfclksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfclksel {
            #[inline(always)]
            fn from(val: u8) -> Nfclksel {
                Nfclksel::from_bits(val)
            }
        }
        impl From<Nfclksel> for u8 {
            #[inline(always)]
            fn from(val: Nfclksel) -> u8 {
                Nfclksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nflten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nflten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nflten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nflten {
            #[inline(always)]
            fn from(val: u8) -> Nflten {
                Nflten::from_bits(val)
            }
        }
        impl From<Nflten> for u8 {
            #[inline(always)]
            fn from(val: Nflten) -> u8 {
                Nflten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmiclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmiclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmiclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmiclr {
            #[inline(always)]
            fn from(val: u8) -> Nmiclr {
                Nmiclr::from_bits(val)
            }
        }
        impl From<Nmiclr> for u8 {
            #[inline(always)]
            fn from(val: Nmiclr) -> u8 {
                Nmiclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmien {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmien {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmien {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmien {
            #[inline(always)]
            fn from(val: u8) -> Nmien {
                Nmien::from_bits(val)
            }
        }
        impl From<Nmien> for u8 {
            #[inline(always)]
            fn from(val: Nmien) -> u8 {
                Nmien::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmimd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmimd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmimd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmimd {
            #[inline(always)]
            fn from(val: u8) -> Nmimd {
                Nmimd::from_bits(val)
            }
        }
        impl From<Nmimd> for u8 {
            #[inline(always)]
            fn from(val: Nmimd) -> u8 {
                Nmimd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmist {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nmist {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmist {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmist {
            #[inline(always)]
            fn from(val: u8) -> Nmist {
                Nmist::from_bits(val)
            }
        }
        impl From<Nmist> for u8 {
            #[inline(always)]
            fn from(val: Nmist) -> u8 {
                Nmist::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpeclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpeclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpeclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpeclr {
            #[inline(always)]
            fn from(val: u8) -> Rpeclr {
                Rpeclr::from_bits(val)
            }
        }
        impl From<Rpeclr> for u8 {
            #[inline(always)]
            fn from(val: Rpeclr) -> u8 {
                Rpeclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpeen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpeen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpeen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpeen {
            #[inline(always)]
            fn from(val: u8) -> Rpeen {
                Rpeen::from_bits(val)
            }
        }
        impl From<Rpeen> for u8 {
            #[inline(always)]
            fn from(val: Rpeen) -> u8 {
                Rpeen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rpest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpest {
            #[inline(always)]
            fn from(val: u8) -> Rpest {
                Rpest::from_bits(val)
            }
        }
        impl From<Rpest> for u8 {
            #[inline(always)]
            fn from(val: Rpest) -> u8 {
                Rpest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speclr {
            #[inline(always)]
            fn from(val: u8) -> Speclr {
                Speclr::from_bits(val)
            }
        }
        impl From<Speclr> for u8 {
            #[inline(always)]
            fn from(val: Speclr) -> u8 {
                Speclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speen {
            #[inline(always)]
            fn from(val: u8) -> Speen {
                Speen::from_bits(val)
            }
        }
        impl From<Speen> for u8 {
            #[inline(always)]
            fn from(val: Speen) -> u8 {
                Speen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spest {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spest {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spest {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spest {
            #[inline(always)]
            fn from(val: u8) -> Spest {
                Spest::from_bits(val)
            }
        }
        impl From<Spest> for u8 {
            #[inline(always)]
            fn from(val: Spest) -> u8 {
                Spest::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtclr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtclr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtclr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtclr {
            #[inline(always)]
            fn from(val: u8) -> Wdtclr {
                Wdtclr::from_bits(val)
            }
        }
        impl From<Wdtclr> for u8 {
            #[inline(always)]
            fn from(val: Wdtclr) -> u8 {
                Wdtclr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdten {
            #[inline(always)]
            fn from(val: u8) -> Wdten {
                Wdten::from_bits(val)
            }
        }
        impl From<Wdten> for u8 {
            #[inline(always)]
            fn from(val: Wdten) -> u8 {
                Wdten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtst {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtst {
            #[inline(always)]
            fn from(val: u8) -> Wdtst {
                Wdtst::from_bits(val)
            }
        }
        impl From<Wdtst> for u8 {
            #[inline(always)]
            fn from(val: Wdtst) -> u8 {
                Wdtst::to_bits(val)
            }
        }
    }
}
pub mod iwdt {
    #[doc = "Independent Watchdog Timer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iwdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Iwdt {}
    unsafe impl Sync for Iwdt {}
    impl Iwdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "IWDT Refresh Register"]
        #[inline(always)]
        pub const fn iwdtrr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "IWDT Status Register"]
        #[inline(always)]
        pub const fn iwdtsr(self) -> crate::common::Reg<regs::Iwdtsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "IWDT Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iwdtsr(pub u16);
        impl Iwdtsr {
            #[doc = "Down,counter Value"]
            #[inline(always)]
            pub const fn cntval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Down,counter Value"]
            #[inline(always)]
            pub fn set_cntval(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn undff(&self) -> super::vals::Undff {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Undff::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_undff(&mut self, val: super::vals::Undff) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub const fn refef(&self) -> super::vals::Refef {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Refef::from_bits(val as u8)
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub fn set_refef(&mut self, val: super::vals::Refef) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Iwdtsr {
            #[inline(always)]
            fn default() -> Iwdtsr {
                Iwdtsr(0)
            }
        }
        impl core::fmt::Debug for Iwdtsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iwdtsr")
                    .field("cntval", &self.cntval())
                    .field("undff", &self.undff())
                    .field("refef", &self.refef())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iwdtsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iwdtsr {{ cntval: {=u16:?}, undff: {:?}, refef: {:?} }}",
                    self.cntval(),
                    self.undff(),
                    self.refef()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Refef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refef {
            #[inline(always)]
            fn from(val: u8) -> Refef {
                Refef::from_bits(val)
            }
        }
        impl From<Refef> for u8 {
            #[inline(always)]
            fn from(val: Refef) -> u8 {
                Refef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Undff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Undff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Undff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Undff {
            #[inline(always)]
            fn from(val: u8) -> Undff {
                Undff::from_bits(val)
            }
        }
        impl From<Undff> for u8 {
            #[inline(always)]
            fn from(val: Undff) -> u8 {
                Undff::to_bits(val)
            }
        }
    }
}
pub mod kint {
    #[doc = "Key Interrupt Function"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kint {
        ptr: *mut u8,
    }
    unsafe impl Send for Kint {}
    unsafe impl Sync for Kint {}
    impl Kint {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Key Return Control Register"]
        #[inline(always)]
        pub const fn krctl(self) -> crate::common::Reg<regs::Krctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Key Return Flag Register"]
        #[inline(always)]
        pub const fn krf(self) -> crate::common::Reg<regs::Krf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Key Return Mode Register"]
        #[inline(always)]
        pub const fn krm(self) -> crate::common::Reg<regs::Krm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Key Return Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Krctl(pub u8);
        impl Krctl {
            #[doc = "Detection Edge Selection (KR00 to KR03 pins)"]
            #[inline(always)]
            pub const fn kreg(&self) -> super::vals::Kreg {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Kreg::from_bits(val as u8)
            }
            #[doc = "Detection Edge Selection (KR00 to KR03 pins)"]
            #[inline(always)]
            pub fn set_kreg(&mut self, val: super::vals::Kreg) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Usage of Key Interrupt Flags (KRF.KIF0 to KRF.KIF3)"]
            #[inline(always)]
            pub const fn krmd(&self) -> super::vals::Krmd {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Krmd::from_bits(val as u8)
            }
            #[doc = "Usage of Key Interrupt Flags (KRF.KIF0 to KRF.KIF3)"]
            #[inline(always)]
            pub fn set_krmd(&mut self, val: super::vals::Krmd) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Krctl {
            #[inline(always)]
            fn default() -> Krctl {
                Krctl(0)
            }
        }
        impl core::fmt::Debug for Krctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Krctl")
                    .field("kreg", &self.kreg())
                    .field("krmd", &self.krmd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Krctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Krctl {{ kreg: {:?}, krmd: {:?} }}",
                    self.kreg(),
                    self.krmd()
                )
            }
        }
        #[doc = "Key Return Flag Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Krf(pub u8);
        impl Krf {
            #[doc = "Key Interrupt Flag n"]
            #[inline(always)]
            pub const fn kif0(&self) -> super::vals::Kif0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Kif0::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Flag n"]
            #[inline(always)]
            pub fn set_kif0(&mut self, val: super::vals::Kif0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Key Interrupt Flag n"]
            #[inline(always)]
            pub const fn kif1(&self) -> super::vals::Kif1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Kif1::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Flag n"]
            #[inline(always)]
            pub fn set_kif1(&mut self, val: super::vals::Kif1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Key Interrupt Flag n"]
            #[inline(always)]
            pub const fn kif2(&self) -> super::vals::Kif2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Kif2::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Flag n"]
            #[inline(always)]
            pub fn set_kif2(&mut self, val: super::vals::Kif2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Key Interrupt Flag n"]
            #[inline(always)]
            pub const fn kif3(&self) -> super::vals::Kif3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Kif3::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Flag n"]
            #[inline(always)]
            pub fn set_kif3(&mut self, val: super::vals::Kif3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
        }
        impl Default for Krf {
            #[inline(always)]
            fn default() -> Krf {
                Krf(0)
            }
        }
        impl core::fmt::Debug for Krf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Krf")
                    .field("kif0", &self.kif0())
                    .field("kif1", &self.kif1())
                    .field("kif2", &self.kif2())
                    .field("kif3", &self.kif3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Krf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Krf {{ kif0: {:?}, kif1: {:?}, kif2: {:?}, kif3: {:?} }}",
                    self.kif0(),
                    self.kif1(),
                    self.kif2(),
                    self.kif3()
                )
            }
        }
        #[doc = "Key Return Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Krm(pub u8);
        impl Krm {
            #[doc = "Key Interrupt Mode Control n"]
            #[inline(always)]
            pub const fn kimc0(&self) -> super::vals::Kimc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Kimc0::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Mode Control n"]
            #[inline(always)]
            pub fn set_kimc0(&mut self, val: super::vals::Kimc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Key Interrupt Mode Control n"]
            #[inline(always)]
            pub const fn kimc1(&self) -> super::vals::Kimc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Kimc1::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Mode Control n"]
            #[inline(always)]
            pub fn set_kimc1(&mut self, val: super::vals::Kimc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Key Interrupt Mode Control n"]
            #[inline(always)]
            pub const fn kimc2(&self) -> super::vals::Kimc2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Kimc2::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Mode Control n"]
            #[inline(always)]
            pub fn set_kimc2(&mut self, val: super::vals::Kimc2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Key Interrupt Mode Control n"]
            #[inline(always)]
            pub const fn kimc3(&self) -> super::vals::Kimc3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Kimc3::from_bits(val as u8)
            }
            #[doc = "Key Interrupt Mode Control n"]
            #[inline(always)]
            pub fn set_kimc3(&mut self, val: super::vals::Kimc3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
        }
        impl Default for Krm {
            #[inline(always)]
            fn default() -> Krm {
                Krm(0)
            }
        }
        impl core::fmt::Debug for Krm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Krm")
                    .field("kimc0", &self.kimc0())
                    .field("kimc1", &self.kimc1())
                    .field("kimc2", &self.kimc2())
                    .field("kimc3", &self.kimc3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Krm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Krm {{ kimc0: {:?}, kimc1: {:?}, kimc2: {:?}, kimc3: {:?} }}",
                    self.kimc0(),
                    self.kimc1(),
                    self.kimc2(),
                    self.kimc3()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kif0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kif0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kif0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kif0 {
            #[inline(always)]
            fn from(val: u8) -> Kif0 {
                Kif0::from_bits(val)
            }
        }
        impl From<Kif0> for u8 {
            #[inline(always)]
            fn from(val: Kif0) -> u8 {
                Kif0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kif1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kif1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kif1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kif1 {
            #[inline(always)]
            fn from(val: u8) -> Kif1 {
                Kif1::from_bits(val)
            }
        }
        impl From<Kif1> for u8 {
            #[inline(always)]
            fn from(val: Kif1) -> u8 {
                Kif1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kif2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kif2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kif2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kif2 {
            #[inline(always)]
            fn from(val: u8) -> Kif2 {
                Kif2::from_bits(val)
            }
        }
        impl From<Kif2> for u8 {
            #[inline(always)]
            fn from(val: Kif2) -> u8 {
                Kif2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kif3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kif3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kif3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kif3 {
            #[inline(always)]
            fn from(val: u8) -> Kif3 {
                Kif3::from_bits(val)
            }
        }
        impl From<Kif3> for u8 {
            #[inline(always)]
            fn from(val: Kif3) -> u8 {
                Kif3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kimc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kimc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kimc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kimc0 {
            #[inline(always)]
            fn from(val: u8) -> Kimc0 {
                Kimc0::from_bits(val)
            }
        }
        impl From<Kimc0> for u8 {
            #[inline(always)]
            fn from(val: Kimc0) -> u8 {
                Kimc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kimc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kimc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kimc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kimc1 {
            #[inline(always)]
            fn from(val: u8) -> Kimc1 {
                Kimc1::from_bits(val)
            }
        }
        impl From<Kimc1> for u8 {
            #[inline(always)]
            fn from(val: Kimc1) -> u8 {
                Kimc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kimc2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kimc2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kimc2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kimc2 {
            #[inline(always)]
            fn from(val: u8) -> Kimc2 {
                Kimc2::from_bits(val)
            }
        }
        impl From<Kimc2> for u8 {
            #[inline(always)]
            fn from(val: Kimc2) -> u8 {
                Kimc2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kimc3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kimc3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kimc3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kimc3 {
            #[inline(always)]
            fn from(val: u8) -> Kimc3 {
                Kimc3::from_bits(val)
            }
        }
        impl From<Kimc3> for u8 {
            #[inline(always)]
            fn from(val: Kimc3) -> u8 {
                Kimc3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Kreg {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Kreg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Kreg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Kreg {
            #[inline(always)]
            fn from(val: u8) -> Kreg {
                Kreg::from_bits(val)
            }
        }
        impl From<Kreg> for u8 {
            #[inline(always)]
            fn from(val: Kreg) -> u8 {
                Kreg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Krmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Krmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Krmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Krmd {
            #[inline(always)]
            fn from(val: u8) -> Krmd {
                Krmd::from_bits(val)
            }
        }
        impl From<Krmd> for u8 {
            #[inline(always)]
            fn from(val: Krmd) -> u8 {
                Krmd::to_bits(val)
            }
        }
    }
}
pub mod mstp {
    #[doc = "Module Stop Control B, C, D"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mstp {
        ptr: *mut u8,
    }
    unsafe impl Send for Mstp {}
    unsafe impl Sync for Mstp {}
    impl Mstp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Module Stop Control Register B"]
        #[inline(always)]
        pub const fn mstpcrb(self) -> crate::common::Reg<regs::Mstpcrb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Module Stop Control Register C"]
        #[inline(always)]
        pub const fn mstpcrc(self) -> crate::common::Reg<regs::Mstpcrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Module Stop Control Register D"]
        #[inline(always)]
        pub const fn mstpcrd(self) -> crate::common::Reg<regs::Mstpcrd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Low Speed Module R/W Disable Control Register"]
        #[inline(always)]
        pub const fn lsmrwdis(self) -> crate::common::Reg<regs::Lsmrwdis, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Low Speed Module R/W Disable Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsmrwdis(pub u16);
        impl Lsmrwdis {
            #[doc = "WDT Operate Clock Control"]
            #[inline(always)]
            pub const fn wdtdis(&self) -> super::vals::Wdtdis {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtdis::from_bits(val as u8)
            }
            #[doc = "WDT Operate Clock Control"]
            #[inline(always)]
            pub fn set_wdtdis(&mut self, val: super::vals::Wdtdis) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "IWDT Register Clock Control"]
            #[inline(always)]
            pub const fn iwdtids(&self) -> super::vals::Iwdtids {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Iwdtids::from_bits(val as u8)
            }
            #[doc = "IWDT Register Clock Control"]
            #[inline(always)]
            pub fn set_iwdtids(&mut self, val: super::vals::Iwdtids) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Write Enable for bits \\[2:0\\]"]
            #[inline(always)]
            pub const fn wren(&self) -> super::vals::Wren {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Wren::from_bits(val as u8)
            }
            #[doc = "Write Enable for bits \\[2:0\\]"]
            #[inline(always)]
            pub fn set_wren(&mut self, val: super::vals::Wren) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "LSMRWDIS Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "LSMRWDIS Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Lsmrwdis {
            #[inline(always)]
            fn default() -> Lsmrwdis {
                Lsmrwdis(0)
            }
        }
        impl core::fmt::Debug for Lsmrwdis {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsmrwdis")
                    .field("wdtdis", &self.wdtdis())
                    .field("iwdtids", &self.iwdtids())
                    .field("wren", &self.wren())
                    .field("prkey", &self.prkey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsmrwdis {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lsmrwdis {{ wdtdis: {:?}, iwdtids: {:?}, wren: {:?}, prkey: {=u8:?} }}",
                    self.wdtdis(),
                    self.iwdtids(),
                    self.wren(),
                    self.prkey()
                )
            }
        }
        #[doc = "Module Stop Control Register B"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrb(pub u32);
        impl Mstpcrb {
            #[doc = "IIC/I3C Bus Interface 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb9(&self) -> super::vals::Mstpb9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Mstpb9::from_bits(val as u8)
            }
            #[doc = "IIC/I3C Bus Interface 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb9(&mut self, val: super::vals::Mstpb9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Serial Peripheral Interface 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpb19(&self) -> super::vals::Mstpb19 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Mstpb19::from_bits(val as u8)
            }
            #[doc = "Serial Peripheral Interface 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb19(&mut self, val: super::vals::Mstpb19) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Serial Communication Interface 9 Module Stop"]
            #[inline(always)]
            pub const fn mstpb22(&self) -> super::vals::Mstpb22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Mstpb22::from_bits(val as u8)
            }
            #[doc = "Serial Communication Interface 9 Module Stop"]
            #[inline(always)]
            pub fn set_mstpb22(&mut self, val: super::vals::Mstpb22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Mstpcrb {
            #[inline(always)]
            fn default() -> Mstpcrb {
                Mstpcrb(0)
            }
        }
        impl core::fmt::Debug for Mstpcrb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrb")
                    .field("mstpb9", &self.mstpb9())
                    .field("mstpb19", &self.mstpb19())
                    .field("mstpb22", &self.mstpb22())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mstpcrb {{ mstpb9: {:?}, mstpb19: {:?}, mstpb22: {:?} }}",
                    self.mstpb9(),
                    self.mstpb19(),
                    self.mstpb22()
                )
            }
        }
        #[doc = "Module Stop Control Register C"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrc(pub u32);
        impl Mstpcrc {
            #[doc = "Clock Frequency Accuracy Measurement Circuit Module Stop"]
            #[inline(always)]
            pub const fn mstpc0(&self) -> super::vals::Mstpc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mstpc0::from_bits(val as u8)
            }
            #[doc = "Clock Frequency Accuracy Measurement Circuit Module Stop"]
            #[inline(always)]
            pub fn set_mstpc0(&mut self, val: super::vals::Mstpc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Cyclic Redundancy Check Calculator Module Stop"]
            #[inline(always)]
            pub const fn mstpc1(&self) -> super::vals::Mstpc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mstpc1::from_bits(val as u8)
            }
            #[doc = "Cyclic Redundancy Check Calculator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc1(&mut self, val: super::vals::Mstpc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Data Operation Circuit Module Stop"]
            #[inline(always)]
            pub const fn mstpc13(&self) -> super::vals::Mstpc13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Mstpc13::from_bits(val as u8)
            }
            #[doc = "Data Operation Circuit Module Stop"]
            #[inline(always)]
            pub fn set_mstpc13(&mut self, val: super::vals::Mstpc13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Event Link Controller Module Stop"]
            #[inline(always)]
            pub const fn mstpc14(&self) -> super::vals::Mstpc14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Mstpc14::from_bits(val as u8)
            }
            #[doc = "Event Link Controller Module Stop"]
            #[inline(always)]
            pub fn set_mstpc14(&mut self, val: super::vals::Mstpc14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "True Random Number Generator Module Stop"]
            #[inline(always)]
            pub const fn mstpc28(&self) -> super::vals::Mstpc28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Mstpc28::from_bits(val as u8)
            }
            #[doc = "True Random Number Generator Module Stop"]
            #[inline(always)]
            pub fn set_mstpc28(&mut self, val: super::vals::Mstpc28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "AES Module Stop"]
            #[inline(always)]
            pub const fn mstpc31(&self) -> super::vals::Mstpc31 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mstpc31::from_bits(val as u8)
            }
            #[doc = "AES Module Stop"]
            #[inline(always)]
            pub fn set_mstpc31(&mut self, val: super::vals::Mstpc31) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Mstpcrc {
            #[inline(always)]
            fn default() -> Mstpcrc {
                Mstpcrc(0)
            }
        }
        impl core::fmt::Debug for Mstpcrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrc")
                    .field("mstpc0", &self.mstpc0())
                    .field("mstpc1", &self.mstpc1())
                    .field("mstpc13", &self.mstpc13())
                    .field("mstpc14", &self.mstpc14())
                    .field("mstpc28", &self.mstpc28())
                    .field("mstpc31", &self.mstpc31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcrc {{ mstpc0: {:?}, mstpc1: {:?}, mstpc13: {:?}, mstpc14: {:?}, mstpc28: {:?}, mstpc31: {:?} }}" , self . mstpc0 () , self . mstpc1 () , self . mstpc13 () , self . mstpc14 () , self . mstpc28 () , self . mstpc31 ())
            }
        }
        #[doc = "Module Stop Control Register D"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcrd(pub u32);
        impl Mstpcrd {
            #[doc = "Low Power Asynchronous General Purpose Timer 1 Module Stop"]
            #[inline(always)]
            pub const fn mstpd2(&self) -> super::vals::Mstpd2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mstpd2::from_bits(val as u8)
            }
            #[doc = "Low Power Asynchronous General Purpose Timer 1 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd2(&mut self, val: super::vals::Mstpd2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Low Power Asynchronous General Purpose Timer 0 Module Stop"]
            #[inline(always)]
            pub const fn mstpd3(&self) -> super::vals::Mstpd3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mstpd3::from_bits(val as u8)
            }
            #[doc = "Low Power Asynchronous General Purpose Timer 0 Module Stop"]
            #[inline(always)]
            pub fn set_mstpd3(&mut self, val: super::vals::Mstpd3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "General PWM Timer 164 to 169 and PWM Delay Generation Circuit Module Stop"]
            #[inline(always)]
            pub const fn mstpd6(&self) -> super::vals::Mstpd6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Mstpd6::from_bits(val as u8)
            }
            #[doc = "General PWM Timer 164 to 169 and PWM Delay Generation Circuit Module Stop"]
            #[inline(always)]
            pub fn set_mstpd6(&mut self, val: super::vals::Mstpd6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Port Output Enable for GPT Module Stop"]
            #[inline(always)]
            pub const fn mstpd14(&self) -> super::vals::Mstpd14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Mstpd14::from_bits(val as u8)
            }
            #[doc = "Port Output Enable for GPT Module Stop"]
            #[inline(always)]
            pub fn set_mstpd14(&mut self, val: super::vals::Mstpd14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "12-bit A/D Converter Module Stop"]
            #[inline(always)]
            pub const fn mstpd16(&self) -> super::vals::Mstpd16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Mstpd16::from_bits(val as u8)
            }
            #[doc = "12-bit A/D Converter Module Stop"]
            #[inline(always)]
            pub fn set_mstpd16(&mut self, val: super::vals::Mstpd16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Mstpcrd {
            #[inline(always)]
            fn default() -> Mstpcrd {
                Mstpcrd(0)
            }
        }
        impl core::fmt::Debug for Mstpcrd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcrd")
                    .field("mstpd2", &self.mstpd2())
                    .field("mstpd3", &self.mstpd3())
                    .field("mstpd6", &self.mstpd6())
                    .field("mstpd14", &self.mstpd14())
                    .field("mstpd16", &self.mstpd16())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcrd {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mstpcrd {{ mstpd2: {:?}, mstpd3: {:?}, mstpd6: {:?}, mstpd14: {:?}, mstpd16: {:?} }}" , self . mstpd2 () , self . mstpd3 () , self . mstpd6 () , self . mstpd14 () , self . mstpd16 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtids {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtids {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtids {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtids {
            #[inline(always)]
            fn from(val: u8) -> Iwdtids {
                Iwdtids::from_bits(val)
            }
        }
        impl From<Iwdtids> for u8 {
            #[inline(always)]
            fn from(val: Iwdtids) -> u8 {
                Iwdtids::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb19 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb19 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb19 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb19 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb19 {
                Mstpb19::from_bits(val)
            }
        }
        impl From<Mstpb19> for u8 {
            #[inline(always)]
            fn from(val: Mstpb19) -> u8 {
                Mstpb19::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb22 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb22 {
                Mstpb22::from_bits(val)
            }
        }
        impl From<Mstpb22> for u8 {
            #[inline(always)]
            fn from(val: Mstpb22) -> u8 {
                Mstpb22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpb9 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpb9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpb9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpb9 {
            #[inline(always)]
            fn from(val: u8) -> Mstpb9 {
                Mstpb9::from_bits(val)
            }
        }
        impl From<Mstpb9> for u8 {
            #[inline(always)]
            fn from(val: Mstpb9) -> u8 {
                Mstpb9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc0 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc0 {
                Mstpc0::from_bits(val)
            }
        }
        impl From<Mstpc0> for u8 {
            #[inline(always)]
            fn from(val: Mstpc0) -> u8 {
                Mstpc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc1 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc1 {
                Mstpc1::from_bits(val)
            }
        }
        impl From<Mstpc1> for u8 {
            #[inline(always)]
            fn from(val: Mstpc1) -> u8 {
                Mstpc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc13 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc13 {
                Mstpc13::from_bits(val)
            }
        }
        impl From<Mstpc13> for u8 {
            #[inline(always)]
            fn from(val: Mstpc13) -> u8 {
                Mstpc13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc14 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc14 {
                Mstpc14::from_bits(val)
            }
        }
        impl From<Mstpc14> for u8 {
            #[inline(always)]
            fn from(val: Mstpc14) -> u8 {
                Mstpc14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc28 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc28 {
                Mstpc28::from_bits(val)
            }
        }
        impl From<Mstpc28> for u8 {
            #[inline(always)]
            fn from(val: Mstpc28) -> u8 {
                Mstpc28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpc31 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpc31 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpc31 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpc31 {
            #[inline(always)]
            fn from(val: u8) -> Mstpc31 {
                Mstpc31::from_bits(val)
            }
        }
        impl From<Mstpc31> for u8 {
            #[inline(always)]
            fn from(val: Mstpc31) -> u8 {
                Mstpc31::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd14 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd14 {
                Mstpd14::from_bits(val)
            }
        }
        impl From<Mstpd14> for u8 {
            #[inline(always)]
            fn from(val: Mstpd14) -> u8 {
                Mstpd14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd16 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd16 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd16 {
                Mstpd16::from_bits(val)
            }
        }
        impl From<Mstpd16> for u8 {
            #[inline(always)]
            fn from(val: Mstpd16) -> u8 {
                Mstpd16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd2 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd2 {
                Mstpd2::from_bits(val)
            }
        }
        impl From<Mstpd2> for u8 {
            #[inline(always)]
            fn from(val: Mstpd2) -> u8 {
                Mstpd2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd3 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd3 {
                Mstpd3::from_bits(val)
            }
        }
        impl From<Mstpd3> for u8 {
            #[inline(always)]
            fn from(val: Mstpd3) -> u8 {
                Mstpd3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpd6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpd6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpd6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpd6 {
            #[inline(always)]
            fn from(val: u8) -> Mstpd6 {
                Mstpd6::from_bits(val)
            }
        }
        impl From<Mstpd6> for u8 {
            #[inline(always)]
            fn from(val: Mstpd6) -> u8 {
                Mstpd6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtdis {
            #[inline(always)]
            fn from(val: u8) -> Wdtdis {
                Wdtdis::from_bits(val)
            }
        }
        impl From<Wdtdis> for u8 {
            #[inline(always)]
            fn from(val: Wdtdis) -> u8 {
                Wdtdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wren {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wren {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wren {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wren {
            #[inline(always)]
            fn from(val: u8) -> Wren {
                Wren::from_bits(val)
            }
        }
        impl From<Wren> for u8 {
            #[inline(always)]
            fn from(val: Wren) -> u8 {
                Wren::to_bits(val)
            }
        }
    }
}
pub mod pfs {
    #[doc = "Pmn Pin Function Control Register"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pfs {
        ptr: *mut u8,
    }
    unsafe impl Send for Pfs {}
    unsafe impl Sync for Pfs {}
    impl Pfs {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs(self, n: usize) -> crate::common::Reg<regs::P0pfs, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize + n * 4usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P0pfsHa, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2ausize + n * 4usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P0pfsBy, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2busize + n * 4usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P0pfs1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize + n * 4usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs_ha_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P0pfsHa1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3ausize + n * 4usize) as _) }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p0pfs_by_1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P0pfsBy1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3busize + n * 4usize) as _) }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p10pfs(self, n: usize) -> crate::common::Reg<regs::P10pfs, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 4usize) as _) }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p10pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P10pfsHa, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x42usize + n * 4usize) as _) }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p10pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P10pfsBy, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x43usize + n * 4usize) as _) }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p108pfs(self) -> crate::common::Reg<regs::P108pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p108pfs_ha(self) -> crate::common::Reg<regs::P108pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x62usize) as _) }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p108pfs_by(self) -> crate::common::Reg<regs::P108pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x63usize) as _) }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p109pfs(self) -> crate::common::Reg<regs::P109pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p109pfs_ha(self) -> crate::common::Reg<regs::P109pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x66usize) as _) }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p109pfs_by(self) -> crate::common::Reg<regs::P109pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x67usize) as _) }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p1pfs(self, n: usize) -> crate::common::Reg<regs::P1pfs, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize + n * 4usize) as _) }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p1pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P1pfsHa, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6ausize + n * 4usize) as _) }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p1pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P1pfsBy, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6busize + n * 4usize) as _) }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p200pfs(self) -> crate::common::Reg<regs::P200pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p200pfs_ha(self) -> crate::common::Reg<regs::P200pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x82usize) as _) }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p200pfs_by(self) -> crate::common::Reg<regs::P200pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x83usize) as _) }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p201pfs(self) -> crate::common::Reg<regs::P201pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p201pfs_ha(self) -> crate::common::Reg<regs::P201pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x86usize) as _) }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p201pfs_by(self) -> crate::common::Reg<regs::P201pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x87usize) as _) }
        }
        #[doc = "Port 205 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p205pfs(self) -> crate::common::Reg<regs::P205pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Port 205 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p205pfs_ha(self) -> crate::common::Reg<regs::P205pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x96usize) as _) }
        }
        #[doc = "Port 205 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p205pfs_by(self) -> crate::common::Reg<regs::P205pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x97usize) as _) }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p300pfs(self) -> crate::common::Reg<regs::P300pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p300pfs_ha(self) -> crate::common::Reg<regs::P300pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc2usize) as _) }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p300pfs_by(self) -> crate::common::Reg<regs::P300pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc3usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs(self, n: usize) -> crate::common::Reg<regs::P40pfs, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs_ha(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P40pfsHa, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize + n * 4usize) as _) }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[inline(always)]
        pub const fn p40pfs_by(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::P40pfsBy, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0103usize + n * 4usize) as _) }
        }
        #[doc = "Port 914 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p914pfs(self) -> crate::common::Reg<regs::P914pfs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0278usize) as _) }
        }
        #[doc = "Port 914 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p914pfs_ha(self) -> crate::common::Reg<regs::P914pfsHa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x027ausize) as _) }
        }
        #[doc = "Port 914 Pin Function Select Register"]
        #[inline(always)]
        pub const fn p914pfs_by(self) -> crate::common::Reg<regs::P914pfsBy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x027busize) as _) }
        }
        #[doc = "Write,Protect Register"]
        #[inline(always)]
        pub const fn pwpr(self) -> crate::common::Reg<regs::Pwpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0503usize) as _) }
        }
        #[doc = "Port Read Wait Control Register"]
        #[inline(always)]
        pub const fn prwcntr(self) -> crate::common::Reg<regs::Prwcntr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050fusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfs(pub u32);
        impl P0pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P0pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P0pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P0pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P0pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P0pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P0pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P0pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P0pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P0pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P0pfs {
            #[inline(always)]
            fn default() -> P0pfs {
                P0pfs(0)
            }
        }
        impl core::fmt::Debug for P0pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P0pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfs1(pub u32);
        impl P0pfs1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfs1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfs1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfs1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfs1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfs1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfs1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfs1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfs1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfs1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfs1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfs1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfs1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfs1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfs1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfs1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P0pfs1Isel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P0pfs1Isel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P0pfs1Isel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P0pfs1Asel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P0pfs1Asel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P0pfs1Asel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P0pfs1Pmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P0pfs1Pmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P0pfs1Pmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P0pfs1 {
            #[inline(always)]
            fn default() -> P0pfs1 {
                P0pfs1(0)
            }
        }
        impl core::fmt::Debug for P0pfs1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfs1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfs1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P0pfs1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfsBy(pub u8);
        impl P0pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P0pfsBy {
            #[inline(always)]
            fn default() -> P0pfsBy {
                P0pfsBy(0)
            }
        }
        impl core::fmt::Debug for P0pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P0pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfsBy1(pub u8);
        impl P0pfsBy1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsBy1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsBy1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsBy1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsBy1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsBy1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsBy1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsBy1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsBy1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsBy1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfsBy1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfsBy1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfsBy1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfsBy1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfsBy1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfsBy1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P0pfsBy1 {
            #[inline(always)]
            fn default() -> P0pfsBy1 {
                P0pfsBy1(0)
            }
        }
        impl core::fmt::Debug for P0pfsBy1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfsBy1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfsBy1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P0pfsBy1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfsHa(pub u16);
        impl P0pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P0pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P0pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P0pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P0pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P0pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P0pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P0pfsHa {
            #[inline(always)]
            fn default() -> P0pfsHa {
                P0pfsHa(0)
            }
        }
        impl core::fmt::Debug for P0pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P0pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 0%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P0pfsHa1(pub u16);
        impl P0pfsHa1 {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P0pfsHa1Podr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P0pfsHa1Podr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P0pfsHa1Podr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P0pfsHa1Pidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P0pfsHa1Pidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P0pfsHa1Pidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P0pfsHa1Pdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P0pfsHa1Pdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P0pfsHa1Pdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P0pfsHa1Pcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P0pfsHa1Pcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P0pfsHa1Pcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P0pfsHa1Ncodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P0pfsHa1Ncodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P0pfsHa1Ncodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P0pfsHa1Isel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P0pfsHa1Isel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P0pfsHa1Isel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P0pfsHa1Asel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P0pfsHa1Asel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P0pfsHa1Asel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P0pfsHa1 {
            #[inline(always)]
            fn default() -> P0pfsHa1 {
                P0pfsHa1(0)
            }
        }
        impl core::fmt::Debug for P0pfsHa1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P0pfsHa1")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P0pfsHa1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P0pfsHa1 {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P108pfs(pub u32);
        impl P108pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P108pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P108pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P108pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P108pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P108pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P108pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P108pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P108pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P108pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P108pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P108pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P108pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P108pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P108pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P108pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P108pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P108pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P108pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P108pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P108pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P108pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P108pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P108pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P108pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P108pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P108pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P108pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P108pfs {
            #[inline(always)]
            fn default() -> P108pfs {
                P108pfs(0)
            }
        }
        impl core::fmt::Debug for P108pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P108pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P108pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P108pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P108pfsBy(pub u8);
        impl P108pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P108pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P108pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P108pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P108pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P108pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P108pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P108pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P108pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P108pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P108pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P108pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P108pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P108pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P108pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P108pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P108pfsBy {
            #[inline(always)]
            fn default() -> P108pfsBy {
                P108pfsBy(0)
            }
        }
        impl core::fmt::Debug for P108pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P108pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P108pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P108pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 108 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P108pfsHa(pub u16);
        impl P108pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P108pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P108pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P108pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P108pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P108pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P108pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P108pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P108pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P108pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P108pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P108pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P108pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P108pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P108pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P108pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P108pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P108pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P108pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P108pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P108pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P108pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P108pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P108pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P108pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P108pfsHa {
            #[inline(always)]
            fn default() -> P108pfsHa {
                P108pfsHa(0)
            }
        }
        impl core::fmt::Debug for P108pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P108pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P108pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P108pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P109pfs(pub u32);
        impl P109pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P109pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P109pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P109pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P109pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P109pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P109pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P109pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P109pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P109pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P109pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P109pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P109pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P109pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P109pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P109pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P109pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P109pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P109pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P109pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P109pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P109pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P109pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P109pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P109pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P109pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P109pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P109pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P109pfs {
            #[inline(always)]
            fn default() -> P109pfs {
                P109pfs(0)
            }
        }
        impl core::fmt::Debug for P109pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P109pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P109pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P109pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P109pfsBy(pub u8);
        impl P109pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P109pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P109pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P109pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P109pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P109pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P109pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P109pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P109pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P109pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P109pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P109pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P109pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P109pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P109pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P109pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P109pfsBy {
            #[inline(always)]
            fn default() -> P109pfsBy {
                P109pfsBy(0)
            }
        }
        impl core::fmt::Debug for P109pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P109pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P109pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P109pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 109 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P109pfsHa(pub u16);
        impl P109pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P109pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P109pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P109pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P109pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P109pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P109pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P109pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P109pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P109pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P109pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P109pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P109pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P109pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P109pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P109pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P109pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P109pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P109pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P109pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P109pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P109pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P109pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P109pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P109pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P109pfsHa {
            #[inline(always)]
            fn default() -> P109pfsHa {
                P109pfsHa(0)
            }
        }
        impl core::fmt::Debug for P109pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P109pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P109pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P109pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P10pfs(pub u32);
        impl P10pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P10pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P10pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P10pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P10pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P10pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P10pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P10pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P10pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P10pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P10pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P10pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P10pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P10pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P10pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P10pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P10pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P10pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P10pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P10pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P10pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P10pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P10pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P10pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P10pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P10pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P10pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P10pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P10pfs {
            #[inline(always)]
            fn default() -> P10pfs {
                P10pfs(0)
            }
        }
        impl core::fmt::Debug for P10pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P10pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P10pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P10pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P10pfsBy(pub u8);
        impl P10pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P10pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P10pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P10pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P10pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P10pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P10pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P10pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P10pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P10pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P10pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P10pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P10pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P10pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P10pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P10pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P10pfsBy {
            #[inline(always)]
            fn default() -> P10pfsBy {
                P10pfsBy(0)
            }
        }
        impl core::fmt::Debug for P10pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P10pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P10pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P10pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 10%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P10pfsHa(pub u16);
        impl P10pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P10pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P10pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P10pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P10pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P10pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P10pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P10pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P10pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P10pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P10pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P10pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P10pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P10pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P10pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P10pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P10pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P10pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P10pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P10pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P10pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P10pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P10pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P10pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P10pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P10pfsHa {
            #[inline(always)]
            fn default() -> P10pfsHa {
                P10pfsHa(0)
            }
        }
        impl core::fmt::Debug for P10pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P10pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P10pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P10pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P1pfs(pub u32);
        impl P1pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P1pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P1pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P1pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P1pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P1pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P1pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P1pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P1pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P1pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P1pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P1pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P1pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P1pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P1pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P1pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P1pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P1pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P1pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P1pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P1pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P1pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P1pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P1pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P1pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P1pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P1pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P1pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P1pfs {
            #[inline(always)]
            fn default() -> P1pfs {
                P1pfs(0)
            }
        }
        impl core::fmt::Debug for P1pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P1pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P1pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P1pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P1pfsBy(pub u8);
        impl P1pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P1pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P1pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P1pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P1pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P1pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P1pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P1pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P1pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P1pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P1pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P1pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P1pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P1pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P1pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P1pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P1pfsBy {
            #[inline(always)]
            fn default() -> P1pfsBy {
                P1pfsBy(0)
            }
        }
        impl core::fmt::Debug for P1pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P1pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P1pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P1pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 1%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P1pfsHa(pub u16);
        impl P1pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P1pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P1pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P1pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P1pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P1pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P1pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P1pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P1pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P1pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P1pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P1pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P1pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P1pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P1pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P1pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P1pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P1pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P1pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P1pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P1pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P1pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P1pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P1pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P1pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P1pfsHa {
            #[inline(always)]
            fn default() -> P1pfsHa {
                P1pfsHa(0)
            }
        }
        impl core::fmt::Debug for P1pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P1pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P1pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P1pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P200pfs(pub u32);
        impl P200pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P200pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P200pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P200pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P200pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P200pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P200pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P200pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P200pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P200pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P200pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P200pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P200pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P200pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P200pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P200pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P200pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P200pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P200pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P200pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P200pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P200pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P200pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P200pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P200pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P200pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P200pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P200pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P200pfs {
            #[inline(always)]
            fn default() -> P200pfs {
                P200pfs(0)
            }
        }
        impl core::fmt::Debug for P200pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P200pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P200pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P200pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P200pfsBy(pub u8);
        impl P200pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P200pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P200pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P200pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P200pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P200pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P200pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P200pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P200pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P200pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P200pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P200pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P200pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P200pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P200pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P200pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P200pfsBy {
            #[inline(always)]
            fn default() -> P200pfsBy {
                P200pfsBy(0)
            }
        }
        impl core::fmt::Debug for P200pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P200pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P200pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P200pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 200 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P200pfsHa(pub u16);
        impl P200pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P200pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P200pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P200pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P200pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P200pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P200pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P200pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P200pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P200pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P200pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P200pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P200pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P200pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P200pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P200pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P200pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P200pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P200pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P200pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P200pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P200pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P200pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P200pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P200pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P200pfsHa {
            #[inline(always)]
            fn default() -> P200pfsHa {
                P200pfsHa(0)
            }
        }
        impl core::fmt::Debug for P200pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P200pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P200pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P200pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P201pfs(pub u32);
        impl P201pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P201pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P201pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P201pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P201pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P201pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P201pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P201pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P201pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P201pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P201pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P201pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P201pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P201pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P201pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P201pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P201pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P201pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P201pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P201pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P201pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P201pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P201pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P201pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P201pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P201pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P201pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P201pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P201pfs {
            #[inline(always)]
            fn default() -> P201pfs {
                P201pfs(0)
            }
        }
        impl core::fmt::Debug for P201pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P201pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P201pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P201pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P201pfsBy(pub u8);
        impl P201pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P201pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P201pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P201pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P201pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P201pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P201pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P201pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P201pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P201pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P201pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P201pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P201pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P201pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P201pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P201pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P201pfsBy {
            #[inline(always)]
            fn default() -> P201pfsBy {
                P201pfsBy(0)
            }
        }
        impl core::fmt::Debug for P201pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P201pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P201pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P201pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 201 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P201pfsHa(pub u16);
        impl P201pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P201pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P201pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P201pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P201pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P201pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P201pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P201pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P201pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P201pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P201pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P201pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P201pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P201pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P201pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P201pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P201pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P201pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P201pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P201pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P201pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P201pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P201pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P201pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P201pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P201pfsHa {
            #[inline(always)]
            fn default() -> P201pfsHa {
                P201pfsHa(0)
            }
        }
        impl core::fmt::Debug for P201pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P201pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P201pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P201pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 205 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P205pfs(pub u32);
        impl P205pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P205pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P205pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P205pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P205pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P205pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P205pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P205pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P205pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P205pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P205pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P205pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P205pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P205pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P205pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P205pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P205pfsEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P205pfsEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P205pfsEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P205pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P205pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P205pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P205pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P205pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P205pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P205pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P205pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P205pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P205pfs {
            #[inline(always)]
            fn default() -> P205pfs {
                P205pfs(0)
            }
        }
        impl core::fmt::Debug for P205pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P205pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P205pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P205pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 205 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P205pfsBy(pub u8);
        impl P205pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P205pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P205pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P205pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P205pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P205pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P205pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P205pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P205pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P205pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P205pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P205pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P205pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P205pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P205pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P205pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P205pfsBy {
            #[inline(always)]
            fn default() -> P205pfsBy {
                P205pfsBy(0)
            }
        }
        impl core::fmt::Debug for P205pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P205pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P205pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P205pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 205 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P205pfsHa(pub u16);
        impl P205pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P205pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P205pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P205pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P205pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P205pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P205pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P205pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P205pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P205pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P205pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P205pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P205pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P205pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P205pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P205pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub const fn eofr(&self) -> super::vals::P205pfsHaEofr {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::P205pfsHaEofr::from_bits(val as u8)
            }
            #[doc = "Event on Falling/Event on Rising"]
            #[inline(always)]
            pub fn set_eofr(&mut self, val: super::vals::P205pfsHaEofr) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P205pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P205pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P205pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P205pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P205pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P205pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P205pfsHa {
            #[inline(always)]
            fn default() -> P205pfsHa {
                P205pfsHa(0)
            }
        }
        impl core::fmt::Debug for P205pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P205pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("eofr", &self.eofr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P205pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P205pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, eofr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . eofr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P300pfs(pub u32);
        impl P300pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P300pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P300pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P300pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P300pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P300pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P300pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P300pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P300pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P300pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P300pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P300pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P300pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P300pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P300pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P300pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P300pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P300pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P300pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P300pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P300pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P300pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P300pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P300pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P300pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P300pfs {
            #[inline(always)]
            fn default() -> P300pfs {
                P300pfs(0)
            }
        }
        impl core::fmt::Debug for P300pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P300pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P300pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P300pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P300pfsBy(pub u8);
        impl P300pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P300pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P300pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P300pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P300pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P300pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P300pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P300pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P300pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P300pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P300pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P300pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P300pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P300pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P300pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P300pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P300pfsBy {
            #[inline(always)]
            fn default() -> P300pfsBy {
                P300pfsBy(0)
            }
        }
        impl core::fmt::Debug for P300pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P300pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P300pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P300pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 300 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P300pfsHa(pub u16);
        impl P300pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P300pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P300pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P300pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P300pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P300pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P300pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P300pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P300pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P300pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P300pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P300pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P300pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P300pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P300pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P300pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P300pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P300pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P300pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P300pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P300pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P300pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P300pfsHa {
            #[inline(always)]
            fn default() -> P300pfsHa {
                P300pfsHa(0)
            }
        }
        impl core::fmt::Debug for P300pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P300pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P300pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P300pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfs(pub u32);
        impl P40pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P40pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P40pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P40pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P40pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P40pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P40pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P40pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P40pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P40pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P40pfs {
            #[inline(always)]
            fn default() -> P40pfs {
                P40pfs(0)
            }
        }
        impl core::fmt::Debug for P40pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P40pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfsBy(pub u8);
        impl P40pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P40pfsBy {
            #[inline(always)]
            fn default() -> P40pfsBy {
                P40pfsBy(0)
            }
        }
        impl core::fmt::Debug for P40pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P40pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 40%s Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P40pfsHa(pub u16);
        impl P40pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P40pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P40pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P40pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P40pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P40pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P40pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P40pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P40pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P40pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P40pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P40pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P40pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P40pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P40pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P40pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P40pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P40pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P40pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P40pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P40pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P40pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P40pfsHa {
            #[inline(always)]
            fn default() -> P40pfsHa {
                P40pfsHa(0)
            }
        }
        impl core::fmt::Debug for P40pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P40pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P40pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P40pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port 914 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P914pfs(pub u32);
        impl P914pfs {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P914pfsPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P914pfsPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P914pfsPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P914pfsPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P914pfsPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P914pfsPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P914pfsPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P914pfsPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P914pfsPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P914pfsPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P914pfsPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P914pfsPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P914pfsNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P914pfsNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P914pfsNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P914pfsIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P914pfsIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P914pfsIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P914pfsAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P914pfsAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P914pfsAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub const fn pmr(&self) -> super::vals::P914pfsPmr {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::P914pfsPmr::from_bits(val as u8)
            }
            #[doc = "Port Mode Control"]
            #[inline(always)]
            pub fn set_pmr(&mut self, val: super::vals::P914pfsPmr) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Peripheral Select"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for P914pfs {
            #[inline(always)]
            fn default() -> P914pfs {
                P914pfs(0)
            }
        }
        impl core::fmt::Debug for P914pfs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P914pfs")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .field("pmr", &self.pmr())
                    .field("psel", &self.psel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P914pfs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P914pfs {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?}, pmr: {:?}, psel: {=u8:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel () , self . pmr () , self . psel ())
            }
        }
        #[doc = "Port 914 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P914pfsBy(pub u8);
        impl P914pfsBy {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P914pfsByPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P914pfsByPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P914pfsByPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P914pfsByPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P914pfsByPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P914pfsByPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P914pfsByPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P914pfsByPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P914pfsByPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P914pfsByPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P914pfsByPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P914pfsByPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P914pfsByNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P914pfsByNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P914pfsByNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for P914pfsBy {
            #[inline(always)]
            fn default() -> P914pfsBy {
                P914pfsBy(0)
            }
        }
        impl core::fmt::Debug for P914pfsBy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P914pfsBy")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P914pfsBy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "P914pfsBy {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?} }}",
                    self.podr(),
                    self.pidr(),
                    self.pdr(),
                    self.pcr(),
                    self.ncodr()
                )
            }
        }
        #[doc = "Port 914 Pin Function Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct P914pfsHa(pub u16);
        impl P914pfsHa {
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub const fn podr(&self) -> super::vals::P914pfsHaPodr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::P914pfsHaPodr::from_bits(val as u8)
            }
            #[doc = "Port Output Data"]
            #[inline(always)]
            pub fn set_podr(&mut self, val: super::vals::P914pfsHaPodr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub const fn pidr(&self) -> super::vals::P914pfsHaPidr {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::P914pfsHaPidr::from_bits(val as u8)
            }
            #[doc = "Port State"]
            #[inline(always)]
            pub fn set_pidr(&mut self, val: super::vals::P914pfsHaPidr) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub const fn pdr(&self) -> super::vals::P914pfsHaPdr {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::P914pfsHaPdr::from_bits(val as u8)
            }
            #[doc = "Port Direction"]
            #[inline(always)]
            pub fn set_pdr(&mut self, val: super::vals::P914pfsHaPdr) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub const fn pcr(&self) -> super::vals::P914pfsHaPcr {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::P914pfsHaPcr::from_bits(val as u8)
            }
            #[doc = "Pull,up Control"]
            #[inline(always)]
            pub fn set_pcr(&mut self, val: super::vals::P914pfsHaPcr) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub const fn ncodr(&self) -> super::vals::P914pfsHaNcodr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::P914pfsHaNcodr::from_bits(val as u8)
            }
            #[doc = "N,Channel Open,Drain Control"]
            #[inline(always)]
            pub fn set_ncodr(&mut self, val: super::vals::P914pfsHaNcodr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub const fn isel(&self) -> super::vals::P914pfsHaIsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::P914pfsHaIsel::from_bits(val as u8)
            }
            #[doc = "IRQ Input Enable"]
            #[inline(always)]
            pub fn set_isel(&mut self, val: super::vals::P914pfsHaIsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub const fn asel(&self) -> super::vals::P914pfsHaAsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::P914pfsHaAsel::from_bits(val as u8)
            }
            #[doc = "Analog Input Enable"]
            #[inline(always)]
            pub fn set_asel(&mut self, val: super::vals::P914pfsHaAsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for P914pfsHa {
            #[inline(always)]
            fn default() -> P914pfsHa {
                P914pfsHa(0)
            }
        }
        impl core::fmt::Debug for P914pfsHa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("P914pfsHa")
                    .field("podr", &self.podr())
                    .field("pidr", &self.pidr())
                    .field("pdr", &self.pdr())
                    .field("pcr", &self.pcr())
                    .field("ncodr", &self.ncodr())
                    .field("isel", &self.isel())
                    .field("asel", &self.asel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for P914pfsHa {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "P914pfsHa {{ podr: {:?}, pidr: {:?}, pdr: {:?}, pcr: {:?}, ncodr: {:?}, isel: {:?}, asel: {:?} }}" , self . podr () , self . pidr () , self . pdr () , self . pcr () , self . ncodr () , self . isel () , self . asel ())
            }
        }
        #[doc = "Port Read Wait Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prwcntr(pub u8);
        impl Prwcntr {
            #[doc = "Wait Cycle Control"]
            #[inline(always)]
            pub const fn wait(&self) -> super::vals::Wait {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Wait::from_bits(val as u8)
            }
            #[doc = "Wait Cycle Control"]
            #[inline(always)]
            pub fn set_wait(&mut self, val: super::vals::Wait) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Prwcntr {
            #[inline(always)]
            fn default() -> Prwcntr {
                Prwcntr(0)
            }
        }
        impl core::fmt::Debug for Prwcntr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prwcntr")
                    .field("wait", &self.wait())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prwcntr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prwcntr {{ wait: {:?} }}", self.wait())
            }
        }
        #[doc = "Write,Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwpr(pub u8);
        impl Pwpr {
            #[doc = "PmnPFS Register Write Enable"]
            #[inline(always)]
            pub const fn pfswe(&self) -> super::vals::Pfswe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pfswe::from_bits(val as u8)
            }
            #[doc = "PmnPFS Register Write Enable"]
            #[inline(always)]
            pub fn set_pfswe(&mut self, val: super::vals::Pfswe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "PFSWE Bit Write Disable"]
            #[inline(always)]
            pub const fn b0wi(&self) -> super::vals::B0wi {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::B0wi::from_bits(val as u8)
            }
            #[doc = "PFSWE Bit Write Disable"]
            #[inline(always)]
            pub fn set_b0wi(&mut self, val: super::vals::B0wi) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Pwpr {
            #[inline(always)]
            fn default() -> Pwpr {
                Pwpr(0)
            }
        }
        impl core::fmt::Debug for Pwpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwpr")
                    .field("pfswe", &self.pfswe())
                    .field("b0wi", &self.b0wi())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pwpr {{ pfswe: {:?}, b0wi: {:?} }}",
                    self.pfswe(),
                    self.b0wi()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum B0wi {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl B0wi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> B0wi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for B0wi {
            #[inline(always)]
            fn from(val: u8) -> B0wi {
                B0wi::from_bits(val)
            }
        }
        impl From<B0wi> for u8 {
            #[inline(always)]
            fn from(val: B0wi) -> u8 {
                B0wi::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfs1Asel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfs1Asel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfs1Asel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfs1Asel {
            #[inline(always)]
            fn from(val: u8) -> P0pfs1Asel {
                P0pfs1Asel::from_bits(val)
            }
        }
        impl From<P0pfs1Asel> for u8 {
            #[inline(always)]
            fn from(val: P0pfs1Asel) -> u8 {
                P0pfs1Asel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfs1Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfs1Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfs1Isel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfs1Isel {
            #[inline(always)]
            fn from(val: u8) -> P0pfs1Isel {
                P0pfs1Isel::from_bits(val)
            }
        }
        impl From<P0pfs1Isel> for u8 {
            #[inline(always)]
            fn from(val: P0pfs1Isel) -> u8 {
                P0pfs1Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfs1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfs1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfs1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfs1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfs1Ncodr {
                P0pfs1Ncodr::from_bits(val)
            }
        }
        impl From<P0pfs1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfs1Ncodr) -> u8 {
                P0pfs1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfs1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfs1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfs1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfs1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfs1Pcr {
                P0pfs1Pcr::from_bits(val)
            }
        }
        impl From<P0pfs1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfs1Pcr) -> u8 {
                P0pfs1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfs1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfs1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfs1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfs1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfs1Pdr {
                P0pfs1Pdr::from_bits(val)
            }
        }
        impl From<P0pfs1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfs1Pdr) -> u8 {
                P0pfs1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfs1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfs1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfs1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfs1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfs1Pidr {
                P0pfs1Pidr::from_bits(val)
            }
        }
        impl From<P0pfs1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfs1Pidr) -> u8 {
                P0pfs1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfs1Pmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfs1Pmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfs1Pmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfs1Pmr {
            #[inline(always)]
            fn from(val: u8) -> P0pfs1Pmr {
                P0pfs1Pmr::from_bits(val)
            }
        }
        impl From<P0pfs1Pmr> for u8 {
            #[inline(always)]
            fn from(val: P0pfs1Pmr) -> u8 {
                P0pfs1Pmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfs1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfs1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfs1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfs1Podr {
            #[inline(always)]
            fn from(val: u8) -> P0pfs1Podr {
                P0pfs1Podr::from_bits(val)
            }
        }
        impl From<P0pfs1Podr> for u8 {
            #[inline(always)]
            fn from(val: P0pfs1Podr) -> u8 {
                P0pfs1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsAsel {
                P0pfsAsel::from_bits(val)
            }
        }
        impl From<P0pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsAsel) -> u8 {
                P0pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsBy1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsBy1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsBy1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsBy1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsBy1Ncodr {
                P0pfsBy1Ncodr::from_bits(val)
            }
        }
        impl From<P0pfsBy1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsBy1Ncodr) -> u8 {
                P0pfsBy1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsBy1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsBy1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsBy1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsBy1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsBy1Pcr {
                P0pfsBy1Pcr::from_bits(val)
            }
        }
        impl From<P0pfsBy1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsBy1Pcr) -> u8 {
                P0pfsBy1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsBy1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsBy1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsBy1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsBy1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsBy1Pdr {
                P0pfsBy1Pdr::from_bits(val)
            }
        }
        impl From<P0pfsBy1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsBy1Pdr) -> u8 {
                P0pfsBy1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsBy1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsBy1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsBy1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsBy1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsBy1Pidr {
                P0pfsBy1Pidr::from_bits(val)
            }
        }
        impl From<P0pfsBy1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsBy1Pidr) -> u8 {
                P0pfsBy1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsBy1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsBy1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsBy1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsBy1Podr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsBy1Podr {
                P0pfsBy1Podr::from_bits(val)
            }
        }
        impl From<P0pfsBy1Podr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsBy1Podr) -> u8 {
                P0pfsBy1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByNcodr {
                P0pfsByNcodr::from_bits(val)
            }
        }
        impl From<P0pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByNcodr) -> u8 {
                P0pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByPcr {
                P0pfsByPcr::from_bits(val)
            }
        }
        impl From<P0pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByPcr) -> u8 {
                P0pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByPdr {
                P0pfsByPdr::from_bits(val)
            }
        }
        impl From<P0pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByPdr) -> u8 {
                P0pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByPidr {
                P0pfsByPidr::from_bits(val)
            }
        }
        impl From<P0pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByPidr) -> u8 {
                P0pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsByPodr {
                P0pfsByPodr::from_bits(val)
            }
        }
        impl From<P0pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsByPodr) -> u8 {
                P0pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHa1Asel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHa1Asel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHa1Asel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHa1Asel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHa1Asel {
                P0pfsHa1Asel::from_bits(val)
            }
        }
        impl From<P0pfsHa1Asel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHa1Asel) -> u8 {
                P0pfsHa1Asel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHa1Isel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHa1Isel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHa1Isel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHa1Isel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHa1Isel {
                P0pfsHa1Isel::from_bits(val)
            }
        }
        impl From<P0pfsHa1Isel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHa1Isel) -> u8 {
                P0pfsHa1Isel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHa1Ncodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHa1Ncodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHa1Ncodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHa1Ncodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHa1Ncodr {
                P0pfsHa1Ncodr::from_bits(val)
            }
        }
        impl From<P0pfsHa1Ncodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHa1Ncodr) -> u8 {
                P0pfsHa1Ncodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHa1Pcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHa1Pcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHa1Pcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHa1Pcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHa1Pcr {
                P0pfsHa1Pcr::from_bits(val)
            }
        }
        impl From<P0pfsHa1Pcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHa1Pcr) -> u8 {
                P0pfsHa1Pcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHa1Pdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHa1Pdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHa1Pdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHa1Pdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHa1Pdr {
                P0pfsHa1Pdr::from_bits(val)
            }
        }
        impl From<P0pfsHa1Pdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHa1Pdr) -> u8 {
                P0pfsHa1Pdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHa1Pidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHa1Pidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHa1Pidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHa1Pidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHa1Pidr {
                P0pfsHa1Pidr::from_bits(val)
            }
        }
        impl From<P0pfsHa1Pidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHa1Pidr) -> u8 {
                P0pfsHa1Pidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHa1Podr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHa1Podr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHa1Podr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHa1Podr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHa1Podr {
                P0pfsHa1Podr::from_bits(val)
            }
        }
        impl From<P0pfsHa1Podr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHa1Podr) -> u8 {
                P0pfsHa1Podr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaAsel {
                P0pfsHaAsel::from_bits(val)
            }
        }
        impl From<P0pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaAsel) -> u8 {
                P0pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaIsel {
                P0pfsHaIsel::from_bits(val)
            }
        }
        impl From<P0pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaIsel) -> u8 {
                P0pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaNcodr {
                P0pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P0pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaNcodr) -> u8 {
                P0pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaPcr {
                P0pfsHaPcr::from_bits(val)
            }
        }
        impl From<P0pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaPcr) -> u8 {
                P0pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaPdr {
                P0pfsHaPdr::from_bits(val)
            }
        }
        impl From<P0pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaPdr) -> u8 {
                P0pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaPidr {
                P0pfsHaPidr::from_bits(val)
            }
        }
        impl From<P0pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaPidr) -> u8 {
                P0pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsHaPodr {
                P0pfsHaPodr::from_bits(val)
            }
        }
        impl From<P0pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsHaPodr) -> u8 {
                P0pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P0pfsIsel {
                P0pfsIsel::from_bits(val)
            }
        }
        impl From<P0pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P0pfsIsel) -> u8 {
                P0pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsNcodr {
                P0pfsNcodr::from_bits(val)
            }
        }
        impl From<P0pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsNcodr) -> u8 {
                P0pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPcr {
                P0pfsPcr::from_bits(val)
            }
        }
        impl From<P0pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPcr) -> u8 {
                P0pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPdr {
                P0pfsPdr::from_bits(val)
            }
        }
        impl From<P0pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPdr) -> u8 {
                P0pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPidr {
                P0pfsPidr::from_bits(val)
            }
        }
        impl From<P0pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPidr) -> u8 {
                P0pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPmr {
                P0pfsPmr::from_bits(val)
            }
        }
        impl From<P0pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPmr) -> u8 {
                P0pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P0pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P0pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P0pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P0pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P0pfsPodr {
                P0pfsPodr::from_bits(val)
            }
        }
        impl From<P0pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P0pfsPodr) -> u8 {
                P0pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P108pfsAsel {
                P108pfsAsel::from_bits(val)
            }
        }
        impl From<P108pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P108pfsAsel) -> u8 {
                P108pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByNcodr {
                P108pfsByNcodr::from_bits(val)
            }
        }
        impl From<P108pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByNcodr) -> u8 {
                P108pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByPcr {
                P108pfsByPcr::from_bits(val)
            }
        }
        impl From<P108pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByPcr) -> u8 {
                P108pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByPdr {
                P108pfsByPdr::from_bits(val)
            }
        }
        impl From<P108pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByPdr) -> u8 {
                P108pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByPidr {
                P108pfsByPidr::from_bits(val)
            }
        }
        impl From<P108pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByPidr) -> u8 {
                P108pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsByPodr {
                P108pfsByPodr::from_bits(val)
            }
        }
        impl From<P108pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsByPodr) -> u8 {
                P108pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P108pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsEofr {
                P108pfsEofr::from_bits(val)
            }
        }
        impl From<P108pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsEofr) -> u8 {
                P108pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaAsel {
                P108pfsHaAsel::from_bits(val)
            }
        }
        impl From<P108pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaAsel) -> u8 {
                P108pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P108pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaEofr {
                P108pfsHaEofr::from_bits(val)
            }
        }
        impl From<P108pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaEofr) -> u8 {
                P108pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaIsel {
                P108pfsHaIsel::from_bits(val)
            }
        }
        impl From<P108pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaIsel) -> u8 {
                P108pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaNcodr {
                P108pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P108pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaNcodr) -> u8 {
                P108pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaPcr {
                P108pfsHaPcr::from_bits(val)
            }
        }
        impl From<P108pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaPcr) -> u8 {
                P108pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaPdr {
                P108pfsHaPdr::from_bits(val)
            }
        }
        impl From<P108pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaPdr) -> u8 {
                P108pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaPidr {
                P108pfsHaPidr::from_bits(val)
            }
        }
        impl From<P108pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaPidr) -> u8 {
                P108pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsHaPodr {
                P108pfsHaPodr::from_bits(val)
            }
        }
        impl From<P108pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsHaPodr) -> u8 {
                P108pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P108pfsIsel {
                P108pfsIsel::from_bits(val)
            }
        }
        impl From<P108pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P108pfsIsel) -> u8 {
                P108pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsNcodr {
                P108pfsNcodr::from_bits(val)
            }
        }
        impl From<P108pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsNcodr) -> u8 {
                P108pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPcr {
                P108pfsPcr::from_bits(val)
            }
        }
        impl From<P108pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPcr) -> u8 {
                P108pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPdr {
                P108pfsPdr::from_bits(val)
            }
        }
        impl From<P108pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPdr) -> u8 {
                P108pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPidr {
                P108pfsPidr::from_bits(val)
            }
        }
        impl From<P108pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPidr) -> u8 {
                P108pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPmr {
                P108pfsPmr::from_bits(val)
            }
        }
        impl From<P108pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPmr) -> u8 {
                P108pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P108pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P108pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P108pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P108pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P108pfsPodr {
                P108pfsPodr::from_bits(val)
            }
        }
        impl From<P108pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P108pfsPodr) -> u8 {
                P108pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsAsel {
                P109pfsAsel::from_bits(val)
            }
        }
        impl From<P109pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsAsel) -> u8 {
                P109pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByNcodr {
                P109pfsByNcodr::from_bits(val)
            }
        }
        impl From<P109pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByNcodr) -> u8 {
                P109pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByPcr {
                P109pfsByPcr::from_bits(val)
            }
        }
        impl From<P109pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByPcr) -> u8 {
                P109pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByPdr {
                P109pfsByPdr::from_bits(val)
            }
        }
        impl From<P109pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByPdr) -> u8 {
                P109pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByPidr {
                P109pfsByPidr::from_bits(val)
            }
        }
        impl From<P109pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByPidr) -> u8 {
                P109pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsByPodr {
                P109pfsByPodr::from_bits(val)
            }
        }
        impl From<P109pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsByPodr) -> u8 {
                P109pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P109pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsEofr {
                P109pfsEofr::from_bits(val)
            }
        }
        impl From<P109pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsEofr) -> u8 {
                P109pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaAsel {
                P109pfsHaAsel::from_bits(val)
            }
        }
        impl From<P109pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaAsel) -> u8 {
                P109pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P109pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaEofr {
                P109pfsHaEofr::from_bits(val)
            }
        }
        impl From<P109pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaEofr) -> u8 {
                P109pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaIsel {
                P109pfsHaIsel::from_bits(val)
            }
        }
        impl From<P109pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaIsel) -> u8 {
                P109pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaNcodr {
                P109pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P109pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaNcodr) -> u8 {
                P109pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaPcr {
                P109pfsHaPcr::from_bits(val)
            }
        }
        impl From<P109pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaPcr) -> u8 {
                P109pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaPdr {
                P109pfsHaPdr::from_bits(val)
            }
        }
        impl From<P109pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaPdr) -> u8 {
                P109pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaPidr {
                P109pfsHaPidr::from_bits(val)
            }
        }
        impl From<P109pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaPidr) -> u8 {
                P109pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsHaPodr {
                P109pfsHaPodr::from_bits(val)
            }
        }
        impl From<P109pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsHaPodr) -> u8 {
                P109pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P109pfsIsel {
                P109pfsIsel::from_bits(val)
            }
        }
        impl From<P109pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P109pfsIsel) -> u8 {
                P109pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsNcodr {
                P109pfsNcodr::from_bits(val)
            }
        }
        impl From<P109pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsNcodr) -> u8 {
                P109pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPcr {
                P109pfsPcr::from_bits(val)
            }
        }
        impl From<P109pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPcr) -> u8 {
                P109pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPdr {
                P109pfsPdr::from_bits(val)
            }
        }
        impl From<P109pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPdr) -> u8 {
                P109pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPidr {
                P109pfsPidr::from_bits(val)
            }
        }
        impl From<P109pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPidr) -> u8 {
                P109pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPmr {
                P109pfsPmr::from_bits(val)
            }
        }
        impl From<P109pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPmr) -> u8 {
                P109pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P109pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P109pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P109pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P109pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P109pfsPodr {
                P109pfsPodr::from_bits(val)
            }
        }
        impl From<P109pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P109pfsPodr) -> u8 {
                P109pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsAsel {
                P10pfsAsel::from_bits(val)
            }
        }
        impl From<P10pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsAsel) -> u8 {
                P10pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByNcodr {
                P10pfsByNcodr::from_bits(val)
            }
        }
        impl From<P10pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByNcodr) -> u8 {
                P10pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByPcr {
                P10pfsByPcr::from_bits(val)
            }
        }
        impl From<P10pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByPcr) -> u8 {
                P10pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByPdr {
                P10pfsByPdr::from_bits(val)
            }
        }
        impl From<P10pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByPdr) -> u8 {
                P10pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByPidr {
                P10pfsByPidr::from_bits(val)
            }
        }
        impl From<P10pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByPidr) -> u8 {
                P10pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsByPodr {
                P10pfsByPodr::from_bits(val)
            }
        }
        impl From<P10pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsByPodr) -> u8 {
                P10pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P10pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsEofr {
                P10pfsEofr::from_bits(val)
            }
        }
        impl From<P10pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsEofr) -> u8 {
                P10pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaAsel {
                P10pfsHaAsel::from_bits(val)
            }
        }
        impl From<P10pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaAsel) -> u8 {
                P10pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P10pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaEofr {
                P10pfsHaEofr::from_bits(val)
            }
        }
        impl From<P10pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaEofr) -> u8 {
                P10pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaIsel {
                P10pfsHaIsel::from_bits(val)
            }
        }
        impl From<P10pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaIsel) -> u8 {
                P10pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaNcodr {
                P10pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P10pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaNcodr) -> u8 {
                P10pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaPcr {
                P10pfsHaPcr::from_bits(val)
            }
        }
        impl From<P10pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaPcr) -> u8 {
                P10pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaPdr {
                P10pfsHaPdr::from_bits(val)
            }
        }
        impl From<P10pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaPdr) -> u8 {
                P10pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaPidr {
                P10pfsHaPidr::from_bits(val)
            }
        }
        impl From<P10pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaPidr) -> u8 {
                P10pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsHaPodr {
                P10pfsHaPodr::from_bits(val)
            }
        }
        impl From<P10pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsHaPodr) -> u8 {
                P10pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P10pfsIsel {
                P10pfsIsel::from_bits(val)
            }
        }
        impl From<P10pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P10pfsIsel) -> u8 {
                P10pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsNcodr {
                P10pfsNcodr::from_bits(val)
            }
        }
        impl From<P10pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsNcodr) -> u8 {
                P10pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPcr {
                P10pfsPcr::from_bits(val)
            }
        }
        impl From<P10pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPcr) -> u8 {
                P10pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPdr {
                P10pfsPdr::from_bits(val)
            }
        }
        impl From<P10pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPdr) -> u8 {
                P10pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPidr {
                P10pfsPidr::from_bits(val)
            }
        }
        impl From<P10pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPidr) -> u8 {
                P10pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPmr {
                P10pfsPmr::from_bits(val)
            }
        }
        impl From<P10pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPmr) -> u8 {
                P10pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P10pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P10pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P10pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P10pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P10pfsPodr {
                P10pfsPodr::from_bits(val)
            }
        }
        impl From<P10pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P10pfsPodr) -> u8 {
                P10pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P1pfsAsel {
                P1pfsAsel::from_bits(val)
            }
        }
        impl From<P1pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P1pfsAsel) -> u8 {
                P1pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByNcodr {
                P1pfsByNcodr::from_bits(val)
            }
        }
        impl From<P1pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByNcodr) -> u8 {
                P1pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByPcr {
                P1pfsByPcr::from_bits(val)
            }
        }
        impl From<P1pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByPcr) -> u8 {
                P1pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByPdr {
                P1pfsByPdr::from_bits(val)
            }
        }
        impl From<P1pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByPdr) -> u8 {
                P1pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByPidr {
                P1pfsByPidr::from_bits(val)
            }
        }
        impl From<P1pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByPidr) -> u8 {
                P1pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsByPodr {
                P1pfsByPodr::from_bits(val)
            }
        }
        impl From<P1pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsByPodr) -> u8 {
                P1pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P1pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsEofr {
                P1pfsEofr::from_bits(val)
            }
        }
        impl From<P1pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsEofr) -> u8 {
                P1pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaAsel {
                P1pfsHaAsel::from_bits(val)
            }
        }
        impl From<P1pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaAsel) -> u8 {
                P1pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P1pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaEofr {
                P1pfsHaEofr::from_bits(val)
            }
        }
        impl From<P1pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaEofr) -> u8 {
                P1pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaIsel {
                P1pfsHaIsel::from_bits(val)
            }
        }
        impl From<P1pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaIsel) -> u8 {
                P1pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaNcodr {
                P1pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P1pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaNcodr) -> u8 {
                P1pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaPcr {
                P1pfsHaPcr::from_bits(val)
            }
        }
        impl From<P1pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaPcr) -> u8 {
                P1pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaPdr {
                P1pfsHaPdr::from_bits(val)
            }
        }
        impl From<P1pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaPdr) -> u8 {
                P1pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaPidr {
                P1pfsHaPidr::from_bits(val)
            }
        }
        impl From<P1pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaPidr) -> u8 {
                P1pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsHaPodr {
                P1pfsHaPodr::from_bits(val)
            }
        }
        impl From<P1pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsHaPodr) -> u8 {
                P1pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P1pfsIsel {
                P1pfsIsel::from_bits(val)
            }
        }
        impl From<P1pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P1pfsIsel) -> u8 {
                P1pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsNcodr {
                P1pfsNcodr::from_bits(val)
            }
        }
        impl From<P1pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsNcodr) -> u8 {
                P1pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPcr {
                P1pfsPcr::from_bits(val)
            }
        }
        impl From<P1pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPcr) -> u8 {
                P1pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPdr {
                P1pfsPdr::from_bits(val)
            }
        }
        impl From<P1pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPdr) -> u8 {
                P1pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPidr {
                P1pfsPidr::from_bits(val)
            }
        }
        impl From<P1pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPidr) -> u8 {
                P1pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPmr {
                P1pfsPmr::from_bits(val)
            }
        }
        impl From<P1pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPmr) -> u8 {
                P1pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P1pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P1pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P1pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P1pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P1pfsPodr {
                P1pfsPodr::from_bits(val)
            }
        }
        impl From<P1pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P1pfsPodr) -> u8 {
                P1pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsAsel {
                P200pfsAsel::from_bits(val)
            }
        }
        impl From<P200pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsAsel) -> u8 {
                P200pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByNcodr {
                P200pfsByNcodr::from_bits(val)
            }
        }
        impl From<P200pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByNcodr) -> u8 {
                P200pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByPcr {
                P200pfsByPcr::from_bits(val)
            }
        }
        impl From<P200pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByPcr) -> u8 {
                P200pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByPdr {
                P200pfsByPdr::from_bits(val)
            }
        }
        impl From<P200pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByPdr) -> u8 {
                P200pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByPidr {
                P200pfsByPidr::from_bits(val)
            }
        }
        impl From<P200pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByPidr) -> u8 {
                P200pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsByPodr {
                P200pfsByPodr::from_bits(val)
            }
        }
        impl From<P200pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsByPodr) -> u8 {
                P200pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P200pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsEofr {
                P200pfsEofr::from_bits(val)
            }
        }
        impl From<P200pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsEofr) -> u8 {
                P200pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaAsel {
                P200pfsHaAsel::from_bits(val)
            }
        }
        impl From<P200pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaAsel) -> u8 {
                P200pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P200pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaEofr {
                P200pfsHaEofr::from_bits(val)
            }
        }
        impl From<P200pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaEofr) -> u8 {
                P200pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaIsel {
                P200pfsHaIsel::from_bits(val)
            }
        }
        impl From<P200pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaIsel) -> u8 {
                P200pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaNcodr {
                P200pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P200pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaNcodr) -> u8 {
                P200pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaPcr {
                P200pfsHaPcr::from_bits(val)
            }
        }
        impl From<P200pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaPcr) -> u8 {
                P200pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaPdr {
                P200pfsHaPdr::from_bits(val)
            }
        }
        impl From<P200pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaPdr) -> u8 {
                P200pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaPidr {
                P200pfsHaPidr::from_bits(val)
            }
        }
        impl From<P200pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaPidr) -> u8 {
                P200pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsHaPodr {
                P200pfsHaPodr::from_bits(val)
            }
        }
        impl From<P200pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsHaPodr) -> u8 {
                P200pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P200pfsIsel {
                P200pfsIsel::from_bits(val)
            }
        }
        impl From<P200pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P200pfsIsel) -> u8 {
                P200pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsNcodr {
                P200pfsNcodr::from_bits(val)
            }
        }
        impl From<P200pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsNcodr) -> u8 {
                P200pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPcr {
                P200pfsPcr::from_bits(val)
            }
        }
        impl From<P200pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPcr) -> u8 {
                P200pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPdr {
                P200pfsPdr::from_bits(val)
            }
        }
        impl From<P200pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPdr) -> u8 {
                P200pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPidr {
                P200pfsPidr::from_bits(val)
            }
        }
        impl From<P200pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPidr) -> u8 {
                P200pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPmr {
                P200pfsPmr::from_bits(val)
            }
        }
        impl From<P200pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPmr) -> u8 {
                P200pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P200pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P200pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P200pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P200pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P200pfsPodr {
                P200pfsPodr::from_bits(val)
            }
        }
        impl From<P200pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P200pfsPodr) -> u8 {
                P200pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsAsel {
                P201pfsAsel::from_bits(val)
            }
        }
        impl From<P201pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsAsel) -> u8 {
                P201pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByNcodr {
                P201pfsByNcodr::from_bits(val)
            }
        }
        impl From<P201pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByNcodr) -> u8 {
                P201pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByPcr {
                P201pfsByPcr::from_bits(val)
            }
        }
        impl From<P201pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByPcr) -> u8 {
                P201pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByPdr {
                P201pfsByPdr::from_bits(val)
            }
        }
        impl From<P201pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByPdr) -> u8 {
                P201pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByPidr {
                P201pfsByPidr::from_bits(val)
            }
        }
        impl From<P201pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByPidr) -> u8 {
                P201pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsByPodr {
                P201pfsByPodr::from_bits(val)
            }
        }
        impl From<P201pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsByPodr) -> u8 {
                P201pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P201pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsEofr {
                P201pfsEofr::from_bits(val)
            }
        }
        impl From<P201pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsEofr) -> u8 {
                P201pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaAsel {
                P201pfsHaAsel::from_bits(val)
            }
        }
        impl From<P201pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaAsel) -> u8 {
                P201pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P201pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaEofr {
                P201pfsHaEofr::from_bits(val)
            }
        }
        impl From<P201pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaEofr) -> u8 {
                P201pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaIsel {
                P201pfsHaIsel::from_bits(val)
            }
        }
        impl From<P201pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaIsel) -> u8 {
                P201pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaNcodr {
                P201pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P201pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaNcodr) -> u8 {
                P201pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaPcr {
                P201pfsHaPcr::from_bits(val)
            }
        }
        impl From<P201pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaPcr) -> u8 {
                P201pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaPdr {
                P201pfsHaPdr::from_bits(val)
            }
        }
        impl From<P201pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaPdr) -> u8 {
                P201pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaPidr {
                P201pfsHaPidr::from_bits(val)
            }
        }
        impl From<P201pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaPidr) -> u8 {
                P201pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsHaPodr {
                P201pfsHaPodr::from_bits(val)
            }
        }
        impl From<P201pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsHaPodr) -> u8 {
                P201pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P201pfsIsel {
                P201pfsIsel::from_bits(val)
            }
        }
        impl From<P201pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P201pfsIsel) -> u8 {
                P201pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsNcodr {
                P201pfsNcodr::from_bits(val)
            }
        }
        impl From<P201pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsNcodr) -> u8 {
                P201pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPcr {
                P201pfsPcr::from_bits(val)
            }
        }
        impl From<P201pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPcr) -> u8 {
                P201pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPdr {
                P201pfsPdr::from_bits(val)
            }
        }
        impl From<P201pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPdr) -> u8 {
                P201pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPidr {
                P201pfsPidr::from_bits(val)
            }
        }
        impl From<P201pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPidr) -> u8 {
                P201pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPmr {
                P201pfsPmr::from_bits(val)
            }
        }
        impl From<P201pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPmr) -> u8 {
                P201pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P201pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P201pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P201pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P201pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P201pfsPodr {
                P201pfsPodr::from_bits(val)
            }
        }
        impl From<P201pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P201pfsPodr) -> u8 {
                P201pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P205pfsAsel {
                P205pfsAsel::from_bits(val)
            }
        }
        impl From<P205pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P205pfsAsel) -> u8 {
                P205pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsByNcodr {
                P205pfsByNcodr::from_bits(val)
            }
        }
        impl From<P205pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsByNcodr) -> u8 {
                P205pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsByPcr {
                P205pfsByPcr::from_bits(val)
            }
        }
        impl From<P205pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsByPcr) -> u8 {
                P205pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsByPdr {
                P205pfsByPdr::from_bits(val)
            }
        }
        impl From<P205pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsByPdr) -> u8 {
                P205pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsByPidr {
                P205pfsByPidr::from_bits(val)
            }
        }
        impl From<P205pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsByPidr) -> u8 {
                P205pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsByPodr {
                P205pfsByPodr::from_bits(val)
            }
        }
        impl From<P205pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsByPodr) -> u8 {
                P205pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P205pfsEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsEofr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsEofr {
                P205pfsEofr::from_bits(val)
            }
        }
        impl From<P205pfsEofr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsEofr) -> u8 {
                P205pfsEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P205pfsHaAsel {
                P205pfsHaAsel::from_bits(val)
            }
        }
        impl From<P205pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P205pfsHaAsel) -> u8 {
                P205pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsHaEofr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl P205pfsHaEofr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsHaEofr {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsHaEofr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsHaEofr {
                P205pfsHaEofr::from_bits(val)
            }
        }
        impl From<P205pfsHaEofr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsHaEofr) -> u8 {
                P205pfsHaEofr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P205pfsHaIsel {
                P205pfsHaIsel::from_bits(val)
            }
        }
        impl From<P205pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P205pfsHaIsel) -> u8 {
                P205pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsHaNcodr {
                P205pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P205pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsHaNcodr) -> u8 {
                P205pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsHaPcr {
                P205pfsHaPcr::from_bits(val)
            }
        }
        impl From<P205pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsHaPcr) -> u8 {
                P205pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsHaPdr {
                P205pfsHaPdr::from_bits(val)
            }
        }
        impl From<P205pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsHaPdr) -> u8 {
                P205pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsHaPidr {
                P205pfsHaPidr::from_bits(val)
            }
        }
        impl From<P205pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsHaPidr) -> u8 {
                P205pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsHaPodr {
                P205pfsHaPodr::from_bits(val)
            }
        }
        impl From<P205pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsHaPodr) -> u8 {
                P205pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P205pfsIsel {
                P205pfsIsel::from_bits(val)
            }
        }
        impl From<P205pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P205pfsIsel) -> u8 {
                P205pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsNcodr {
                P205pfsNcodr::from_bits(val)
            }
        }
        impl From<P205pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsNcodr) -> u8 {
                P205pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsPcr {
                P205pfsPcr::from_bits(val)
            }
        }
        impl From<P205pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsPcr) -> u8 {
                P205pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsPdr {
                P205pfsPdr::from_bits(val)
            }
        }
        impl From<P205pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsPdr) -> u8 {
                P205pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsPidr {
                P205pfsPidr::from_bits(val)
            }
        }
        impl From<P205pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsPidr) -> u8 {
                P205pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsPmr {
                P205pfsPmr::from_bits(val)
            }
        }
        impl From<P205pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsPmr) -> u8 {
                P205pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P205pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P205pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P205pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P205pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P205pfsPodr {
                P205pfsPodr::from_bits(val)
            }
        }
        impl From<P205pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P205pfsPodr) -> u8 {
                P205pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P300pfsAsel {
                P300pfsAsel::from_bits(val)
            }
        }
        impl From<P300pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P300pfsAsel) -> u8 {
                P300pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByNcodr {
                P300pfsByNcodr::from_bits(val)
            }
        }
        impl From<P300pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByNcodr) -> u8 {
                P300pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByPcr {
                P300pfsByPcr::from_bits(val)
            }
        }
        impl From<P300pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByPcr) -> u8 {
                P300pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByPdr {
                P300pfsByPdr::from_bits(val)
            }
        }
        impl From<P300pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByPdr) -> u8 {
                P300pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByPidr {
                P300pfsByPidr::from_bits(val)
            }
        }
        impl From<P300pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByPidr) -> u8 {
                P300pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsByPodr {
                P300pfsByPodr::from_bits(val)
            }
        }
        impl From<P300pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsByPodr) -> u8 {
                P300pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaAsel {
                P300pfsHaAsel::from_bits(val)
            }
        }
        impl From<P300pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaAsel) -> u8 {
                P300pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaIsel {
                P300pfsHaIsel::from_bits(val)
            }
        }
        impl From<P300pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaIsel) -> u8 {
                P300pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaNcodr {
                P300pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P300pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaNcodr) -> u8 {
                P300pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaPcr {
                P300pfsHaPcr::from_bits(val)
            }
        }
        impl From<P300pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaPcr) -> u8 {
                P300pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaPdr {
                P300pfsHaPdr::from_bits(val)
            }
        }
        impl From<P300pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaPdr) -> u8 {
                P300pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaPidr {
                P300pfsHaPidr::from_bits(val)
            }
        }
        impl From<P300pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaPidr) -> u8 {
                P300pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsHaPodr {
                P300pfsHaPodr::from_bits(val)
            }
        }
        impl From<P300pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsHaPodr) -> u8 {
                P300pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P300pfsIsel {
                P300pfsIsel::from_bits(val)
            }
        }
        impl From<P300pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P300pfsIsel) -> u8 {
                P300pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsNcodr {
                P300pfsNcodr::from_bits(val)
            }
        }
        impl From<P300pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsNcodr) -> u8 {
                P300pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPcr {
                P300pfsPcr::from_bits(val)
            }
        }
        impl From<P300pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPcr) -> u8 {
                P300pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPdr {
                P300pfsPdr::from_bits(val)
            }
        }
        impl From<P300pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPdr) -> u8 {
                P300pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPidr {
                P300pfsPidr::from_bits(val)
            }
        }
        impl From<P300pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPidr) -> u8 {
                P300pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPmr {
                P300pfsPmr::from_bits(val)
            }
        }
        impl From<P300pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPmr) -> u8 {
                P300pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P300pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P300pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P300pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P300pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P300pfsPodr {
                P300pfsPodr::from_bits(val)
            }
        }
        impl From<P300pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P300pfsPodr) -> u8 {
                P300pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsAsel {
                P40pfsAsel::from_bits(val)
            }
        }
        impl From<P40pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsAsel) -> u8 {
                P40pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByNcodr {
                P40pfsByNcodr::from_bits(val)
            }
        }
        impl From<P40pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByNcodr) -> u8 {
                P40pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByPcr {
                P40pfsByPcr::from_bits(val)
            }
        }
        impl From<P40pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByPcr) -> u8 {
                P40pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByPdr {
                P40pfsByPdr::from_bits(val)
            }
        }
        impl From<P40pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByPdr) -> u8 {
                P40pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByPidr {
                P40pfsByPidr::from_bits(val)
            }
        }
        impl From<P40pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByPidr) -> u8 {
                P40pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsByPodr {
                P40pfsByPodr::from_bits(val)
            }
        }
        impl From<P40pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsByPodr) -> u8 {
                P40pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaAsel {
                P40pfsHaAsel::from_bits(val)
            }
        }
        impl From<P40pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaAsel) -> u8 {
                P40pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaIsel {
                P40pfsHaIsel::from_bits(val)
            }
        }
        impl From<P40pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaIsel) -> u8 {
                P40pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaNcodr {
                P40pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P40pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaNcodr) -> u8 {
                P40pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaPcr {
                P40pfsHaPcr::from_bits(val)
            }
        }
        impl From<P40pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaPcr) -> u8 {
                P40pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaPdr {
                P40pfsHaPdr::from_bits(val)
            }
        }
        impl From<P40pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaPdr) -> u8 {
                P40pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaPidr {
                P40pfsHaPidr::from_bits(val)
            }
        }
        impl From<P40pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaPidr) -> u8 {
                P40pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsHaPodr {
                P40pfsHaPodr::from_bits(val)
            }
        }
        impl From<P40pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsHaPodr) -> u8 {
                P40pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P40pfsIsel {
                P40pfsIsel::from_bits(val)
            }
        }
        impl From<P40pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P40pfsIsel) -> u8 {
                P40pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsNcodr {
                P40pfsNcodr::from_bits(val)
            }
        }
        impl From<P40pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsNcodr) -> u8 {
                P40pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPcr {
                P40pfsPcr::from_bits(val)
            }
        }
        impl From<P40pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPcr) -> u8 {
                P40pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPdr {
                P40pfsPdr::from_bits(val)
            }
        }
        impl From<P40pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPdr) -> u8 {
                P40pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPidr {
                P40pfsPidr::from_bits(val)
            }
        }
        impl From<P40pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPidr) -> u8 {
                P40pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPmr {
                P40pfsPmr::from_bits(val)
            }
        }
        impl From<P40pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPmr) -> u8 {
                P40pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P40pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P40pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P40pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P40pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P40pfsPodr {
                P40pfsPodr::from_bits(val)
            }
        }
        impl From<P40pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P40pfsPodr) -> u8 {
                P40pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsAsel {
            #[inline(always)]
            fn from(val: u8) -> P914pfsAsel {
                P914pfsAsel::from_bits(val)
            }
        }
        impl From<P914pfsAsel> for u8 {
            #[inline(always)]
            fn from(val: P914pfsAsel) -> u8 {
                P914pfsAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsByNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsByNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsByNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsByNcodr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsByNcodr {
                P914pfsByNcodr::from_bits(val)
            }
        }
        impl From<P914pfsByNcodr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsByNcodr) -> u8 {
                P914pfsByNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsByPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsByPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsByPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsByPcr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsByPcr {
                P914pfsByPcr::from_bits(val)
            }
        }
        impl From<P914pfsByPcr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsByPcr) -> u8 {
                P914pfsByPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsByPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsByPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsByPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsByPdr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsByPdr {
                P914pfsByPdr::from_bits(val)
            }
        }
        impl From<P914pfsByPdr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsByPdr) -> u8 {
                P914pfsByPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsByPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsByPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsByPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsByPidr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsByPidr {
                P914pfsByPidr::from_bits(val)
            }
        }
        impl From<P914pfsByPidr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsByPidr) -> u8 {
                P914pfsByPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsByPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsByPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsByPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsByPodr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsByPodr {
                P914pfsByPodr::from_bits(val)
            }
        }
        impl From<P914pfsByPodr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsByPodr) -> u8 {
                P914pfsByPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsHaAsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsHaAsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsHaAsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsHaAsel {
            #[inline(always)]
            fn from(val: u8) -> P914pfsHaAsel {
                P914pfsHaAsel::from_bits(val)
            }
        }
        impl From<P914pfsHaAsel> for u8 {
            #[inline(always)]
            fn from(val: P914pfsHaAsel) -> u8 {
                P914pfsHaAsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsHaIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsHaIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsHaIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsHaIsel {
            #[inline(always)]
            fn from(val: u8) -> P914pfsHaIsel {
                P914pfsHaIsel::from_bits(val)
            }
        }
        impl From<P914pfsHaIsel> for u8 {
            #[inline(always)]
            fn from(val: P914pfsHaIsel) -> u8 {
                P914pfsHaIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsHaNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsHaNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsHaNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsHaNcodr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsHaNcodr {
                P914pfsHaNcodr::from_bits(val)
            }
        }
        impl From<P914pfsHaNcodr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsHaNcodr) -> u8 {
                P914pfsHaNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsHaPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsHaPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsHaPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsHaPcr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsHaPcr {
                P914pfsHaPcr::from_bits(val)
            }
        }
        impl From<P914pfsHaPcr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsHaPcr) -> u8 {
                P914pfsHaPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsHaPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsHaPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsHaPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsHaPdr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsHaPdr {
                P914pfsHaPdr::from_bits(val)
            }
        }
        impl From<P914pfsHaPdr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsHaPdr) -> u8 {
                P914pfsHaPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsHaPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsHaPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsHaPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsHaPidr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsHaPidr {
                P914pfsHaPidr::from_bits(val)
            }
        }
        impl From<P914pfsHaPidr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsHaPidr) -> u8 {
                P914pfsHaPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsHaPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsHaPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsHaPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsHaPodr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsHaPodr {
                P914pfsHaPodr::from_bits(val)
            }
        }
        impl From<P914pfsHaPodr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsHaPodr) -> u8 {
                P914pfsHaPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsIsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsIsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsIsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsIsel {
            #[inline(always)]
            fn from(val: u8) -> P914pfsIsel {
                P914pfsIsel::from_bits(val)
            }
        }
        impl From<P914pfsIsel> for u8 {
            #[inline(always)]
            fn from(val: P914pfsIsel) -> u8 {
                P914pfsIsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsNcodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsNcodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsNcodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsNcodr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsNcodr {
                P914pfsNcodr::from_bits(val)
            }
        }
        impl From<P914pfsNcodr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsNcodr) -> u8 {
                P914pfsNcodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsPcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsPcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsPcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsPcr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsPcr {
                P914pfsPcr::from_bits(val)
            }
        }
        impl From<P914pfsPcr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsPcr) -> u8 {
                P914pfsPcr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsPdr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsPdr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsPdr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsPdr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsPdr {
                P914pfsPdr::from_bits(val)
            }
        }
        impl From<P914pfsPdr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsPdr) -> u8 {
                P914pfsPdr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsPidr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsPidr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsPidr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsPidr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsPidr {
                P914pfsPidr::from_bits(val)
            }
        }
        impl From<P914pfsPidr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsPidr) -> u8 {
                P914pfsPidr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsPmr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsPmr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsPmr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsPmr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsPmr {
                P914pfsPmr::from_bits(val)
            }
        }
        impl From<P914pfsPmr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsPmr) -> u8 {
                P914pfsPmr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum P914pfsPodr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl P914pfsPodr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> P914pfsPodr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for P914pfsPodr {
            #[inline(always)]
            fn from(val: u8) -> P914pfsPodr {
                P914pfsPodr::from_bits(val)
            }
        }
        impl From<P914pfsPodr> for u8 {
            #[inline(always)]
            fn from(val: P914pfsPodr) -> u8 {
                P914pfsPodr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pfswe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pfswe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pfswe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pfswe {
            #[inline(always)]
            fn from(val: u8) -> Pfswe {
                Pfswe::from_bits(val)
            }
        }
        impl From<Pfswe> for u8 {
            #[inline(always)]
            fn from(val: Pfswe) -> u8 {
                Pfswe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Wait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wait {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wait {
            #[inline(always)]
            fn from(val: u8) -> Wait {
                Wait::from_bits(val)
            }
        }
        impl From<Wait> for u8 {
            #[inline(always)]
            fn from(val: Wait) -> u8 {
                Wait::to_bits(val)
            }
        }
    }
}
pub mod poeg {
    #[doc = "Port Output Enable Module for GPT"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Poeg {
        ptr: *mut u8,
    }
    unsafe impl Send for Poeg {}
    unsafe impl Sync for Poeg {}
    impl Poeg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "POEG Group A Setting Register"]
        #[inline(always)]
        pub const fn poegga(self) -> crate::common::Reg<regs::Poegga, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "POEG Group B Setting Register"]
        #[inline(always)]
        pub const fn poeggb(self) -> crate::common::Reg<regs::Poeggb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "POEG Group A Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Poegga(pub u32);
        impl Poegga {
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub const fn pidf(&self) -> super::vals::PoeggaPidf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PoeggaPidf::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub fn set_pidf(&mut self, val: super::vals::PoeggaPidf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Detection Flag for GPT Output,Disable Request"]
            #[inline(always)]
            pub const fn iocf(&self) -> super::vals::PoeggaIocf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PoeggaIocf::from_bits(val as u8)
            }
            #[doc = "Detection Flag for GPT Output,Disable Request"]
            #[inline(always)]
            pub fn set_iocf(&mut self, val: super::vals::PoeggaIocf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub const fn ssf(&self) -> super::vals::PoeggaSsf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PoeggaSsf::from_bits(val as u8)
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub fn set_ssf(&mut self, val: super::vals::PoeggaSsf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Port Input Detection Enable"]
            #[inline(always)]
            pub const fn pide(&self) -> super::vals::PoeggaPide {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PoeggaPide::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Enable"]
            #[inline(always)]
            pub fn set_pide(&mut self, val: super::vals::PoeggaPide) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable for GPT Output,Disable Request"]
            #[inline(always)]
            pub const fn ioce(&self) -> super::vals::PoeggaIoce {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PoeggaIoce::from_bits(val as u8)
            }
            #[doc = "Enable for GPT Output,Disable Request"]
            #[inline(always)]
            pub fn set_ioce(&mut self, val: super::vals::PoeggaIoce) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "GTETRGn Input Status Flag"]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::PoeggaSt {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::PoeggaSt::from_bits(val as u8)
            }
            #[doc = "GTETRGn Input Status Flag"]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::PoeggaSt) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "GTETRGn Input Reverse"]
            #[inline(always)]
            pub const fn inv(&self) -> super::vals::PoeggaInv {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::PoeggaInv::from_bits(val as u8)
            }
            #[doc = "GTETRGn Input Reverse"]
            #[inline(always)]
            pub fn set_inv(&mut self, val: super::vals::PoeggaInv) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::PoeggaNfen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::PoeggaNfen::from_bits(val as u8)
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::PoeggaNfen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::PoeggaNfcs {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PoeggaNfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::PoeggaNfcs) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Poegga {
            #[inline(always)]
            fn default() -> Poegga {
                Poegga(0)
            }
        }
        impl core::fmt::Debug for Poegga {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Poegga")
                    .field("pidf", &self.pidf())
                    .field("iocf", &self.iocf())
                    .field("ssf", &self.ssf())
                    .field("pide", &self.pide())
                    .field("ioce", &self.ioce())
                    .field("st", &self.st())
                    .field("inv", &self.inv())
                    .field("nfen", &self.nfen())
                    .field("nfcs", &self.nfcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Poegga {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Poegga {{ pidf: {:?}, iocf: {:?}, ssf: {:?}, pide: {:?}, ioce: {:?}, st: {:?}, inv: {:?}, nfen: {:?}, nfcs: {:?} }}" , self . pidf () , self . iocf () , self . ssf () , self . pide () , self . ioce () , self . st () , self . inv () , self . nfen () , self . nfcs ())
            }
        }
        #[doc = "POEG Group B Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Poeggb(pub u32);
        impl Poeggb {
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub const fn pidf(&self) -> super::vals::PoeggbPidf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PoeggbPidf::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Flag"]
            #[inline(always)]
            pub fn set_pidf(&mut self, val: super::vals::PoeggbPidf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Detection Flag for GPT Output,Disable Request"]
            #[inline(always)]
            pub const fn iocf(&self) -> super::vals::PoeggbIocf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PoeggbIocf::from_bits(val as u8)
            }
            #[doc = "Detection Flag for GPT Output,Disable Request"]
            #[inline(always)]
            pub fn set_iocf(&mut self, val: super::vals::PoeggbIocf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub const fn ssf(&self) -> super::vals::PoeggbSsf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PoeggbSsf::from_bits(val as u8)
            }
            #[doc = "Software Stop Flag"]
            #[inline(always)]
            pub fn set_ssf(&mut self, val: super::vals::PoeggbSsf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Port Input Detection Enable"]
            #[inline(always)]
            pub const fn pide(&self) -> super::vals::PoeggbPide {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PoeggbPide::from_bits(val as u8)
            }
            #[doc = "Port Input Detection Enable"]
            #[inline(always)]
            pub fn set_pide(&mut self, val: super::vals::PoeggbPide) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable for GPT Output,Disable Request"]
            #[inline(always)]
            pub const fn ioce(&self) -> super::vals::PoeggbIoce {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PoeggbIoce::from_bits(val as u8)
            }
            #[doc = "Enable for GPT Output,Disable Request"]
            #[inline(always)]
            pub fn set_ioce(&mut self, val: super::vals::PoeggbIoce) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "GTETRGn Input Status Flag"]
            #[inline(always)]
            pub const fn st(&self) -> super::vals::PoeggbSt {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::PoeggbSt::from_bits(val as u8)
            }
            #[doc = "GTETRGn Input Status Flag"]
            #[inline(always)]
            pub fn set_st(&mut self, val: super::vals::PoeggbSt) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "GTETRGn Input Reverse"]
            #[inline(always)]
            pub const fn inv(&self) -> super::vals::PoeggbInv {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::PoeggbInv::from_bits(val as u8)
            }
            #[doc = "GTETRGn Input Reverse"]
            #[inline(always)]
            pub fn set_inv(&mut self, val: super::vals::PoeggbInv) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::PoeggbNfen {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::PoeggbNfen::from_bits(val as u8)
            }
            #[doc = "Noise Filter Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::PoeggbNfen) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::PoeggbNfcs {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PoeggbNfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::PoeggbNfcs) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Poeggb {
            #[inline(always)]
            fn default() -> Poeggb {
                Poeggb(0)
            }
        }
        impl core::fmt::Debug for Poeggb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Poeggb")
                    .field("pidf", &self.pidf())
                    .field("iocf", &self.iocf())
                    .field("ssf", &self.ssf())
                    .field("pide", &self.pide())
                    .field("ioce", &self.ioce())
                    .field("st", &self.st())
                    .field("inv", &self.inv())
                    .field("nfen", &self.nfen())
                    .field("nfcs", &self.nfcs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Poeggb {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Poeggb {{ pidf: {:?}, iocf: {:?}, ssf: {:?}, pide: {:?}, ioce: {:?}, st: {:?}, inv: {:?}, nfen: {:?}, nfcs: {:?} }}" , self . pidf () , self . iocf () , self . ssf () , self . pide () , self . ioce () , self . st () , self . inv () , self . nfen () , self . nfcs ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaInv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaInv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaInv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaInv {
            #[inline(always)]
            fn from(val: u8) -> PoeggaInv {
                PoeggaInv::from_bits(val)
            }
        }
        impl From<PoeggaInv> for u8 {
            #[inline(always)]
            fn from(val: PoeggaInv) -> u8 {
                PoeggaInv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaIoce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaIoce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaIoce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaIoce {
            #[inline(always)]
            fn from(val: u8) -> PoeggaIoce {
                PoeggaIoce::from_bits(val)
            }
        }
        impl From<PoeggaIoce> for u8 {
            #[inline(always)]
            fn from(val: PoeggaIoce) -> u8 {
                PoeggaIoce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaIocf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaIocf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaIocf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaIocf {
            #[inline(always)]
            fn from(val: u8) -> PoeggaIocf {
                PoeggaIocf::from_bits(val)
            }
        }
        impl From<PoeggaIocf> for u8 {
            #[inline(always)]
            fn from(val: PoeggaIocf) -> u8 {
                PoeggaIocf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaNfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PoeggaNfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaNfcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaNfcs {
            #[inline(always)]
            fn from(val: u8) -> PoeggaNfcs {
                PoeggaNfcs::from_bits(val)
            }
        }
        impl From<PoeggaNfcs> for u8 {
            #[inline(always)]
            fn from(val: PoeggaNfcs) -> u8 {
                PoeggaNfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaNfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaNfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaNfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaNfen {
            #[inline(always)]
            fn from(val: u8) -> PoeggaNfen {
                PoeggaNfen::from_bits(val)
            }
        }
        impl From<PoeggaNfen> for u8 {
            #[inline(always)]
            fn from(val: PoeggaNfen) -> u8 {
                PoeggaNfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaPide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaPide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaPide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaPide {
            #[inline(always)]
            fn from(val: u8) -> PoeggaPide {
                PoeggaPide::from_bits(val)
            }
        }
        impl From<PoeggaPide> for u8 {
            #[inline(always)]
            fn from(val: PoeggaPide) -> u8 {
                PoeggaPide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaPidf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaPidf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaPidf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaPidf {
            #[inline(always)]
            fn from(val: u8) -> PoeggaPidf {
                PoeggaPidf::from_bits(val)
            }
        }
        impl From<PoeggaPidf> for u8 {
            #[inline(always)]
            fn from(val: PoeggaPidf) -> u8 {
                PoeggaPidf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaSsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaSsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaSsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaSsf {
            #[inline(always)]
            fn from(val: u8) -> PoeggaSsf {
                PoeggaSsf::from_bits(val)
            }
        }
        impl From<PoeggaSsf> for u8 {
            #[inline(always)]
            fn from(val: PoeggaSsf) -> u8 {
                PoeggaSsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggaSt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggaSt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggaSt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggaSt {
            #[inline(always)]
            fn from(val: u8) -> PoeggaSt {
                PoeggaSt::from_bits(val)
            }
        }
        impl From<PoeggaSt> for u8 {
            #[inline(always)]
            fn from(val: PoeggaSt) -> u8 {
                PoeggaSt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbInv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbInv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbInv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbInv {
            #[inline(always)]
            fn from(val: u8) -> PoeggbInv {
                PoeggbInv::from_bits(val)
            }
        }
        impl From<PoeggbInv> for u8 {
            #[inline(always)]
            fn from(val: PoeggbInv) -> u8 {
                PoeggbInv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbIoce {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbIoce {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbIoce {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbIoce {
            #[inline(always)]
            fn from(val: u8) -> PoeggbIoce {
                PoeggbIoce::from_bits(val)
            }
        }
        impl From<PoeggbIoce> for u8 {
            #[inline(always)]
            fn from(val: PoeggbIoce) -> u8 {
                PoeggbIoce::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbIocf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbIocf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbIocf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbIocf {
            #[inline(always)]
            fn from(val: u8) -> PoeggbIocf {
                PoeggbIocf::from_bits(val)
            }
        }
        impl From<PoeggbIocf> for u8 {
            #[inline(always)]
            fn from(val: PoeggbIocf) -> u8 {
                PoeggbIocf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbNfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PoeggbNfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbNfcs {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbNfcs {
            #[inline(always)]
            fn from(val: u8) -> PoeggbNfcs {
                PoeggbNfcs::from_bits(val)
            }
        }
        impl From<PoeggbNfcs> for u8 {
            #[inline(always)]
            fn from(val: PoeggbNfcs) -> u8 {
                PoeggbNfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbNfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbNfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbNfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbNfen {
            #[inline(always)]
            fn from(val: u8) -> PoeggbNfen {
                PoeggbNfen::from_bits(val)
            }
        }
        impl From<PoeggbNfen> for u8 {
            #[inline(always)]
            fn from(val: PoeggbNfen) -> u8 {
                PoeggbNfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbPide {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbPide {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbPide {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbPide {
            #[inline(always)]
            fn from(val: u8) -> PoeggbPide {
                PoeggbPide::from_bits(val)
            }
        }
        impl From<PoeggbPide> for u8 {
            #[inline(always)]
            fn from(val: PoeggbPide) -> u8 {
                PoeggbPide::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbPidf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbPidf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbPidf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbPidf {
            #[inline(always)]
            fn from(val: u8) -> PoeggbPidf {
                PoeggbPidf::from_bits(val)
            }
        }
        impl From<PoeggbPidf> for u8 {
            #[inline(always)]
            fn from(val: PoeggbPidf) -> u8 {
                PoeggbPidf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbSsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbSsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbSsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbSsf {
            #[inline(always)]
            fn from(val: u8) -> PoeggbSsf {
                PoeggbSsf::from_bits(val)
            }
        }
        impl From<PoeggbSsf> for u8 {
            #[inline(always)]
            fn from(val: PoeggbSsf) -> u8 {
                PoeggbSsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PoeggbSt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PoeggbSt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PoeggbSt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PoeggbSt {
            #[inline(always)]
            fn from(val: u8) -> PoeggbSt {
                PoeggbSt::from_bits(val)
            }
        }
        impl From<PoeggbSt> for u8 {
            #[inline(always)]
            fn from(val: PoeggbSt) -> u8 {
                PoeggbSt::to_bits(val)
            }
        }
    }
}
pub mod port0 {
    #[doc = "Port 0 Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port0 {}
    unsafe impl Sync for Port0 {}
    impl Port0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pcntr1(self) -> crate::common::Reg<regs::Pcntr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn podr(self) -> crate::common::Reg<regs::Podr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pdr(self) -> crate::common::Reg<regs::Pdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pcntr2(self) -> crate::common::Reg<regs::Pcntr2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pidr(self) -> crate::common::Reg<regs::Pidr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn pcntr3(self) -> crate::common::Reg<regs::Pcntr3, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn porr(self) -> crate::common::Reg<regs::Porr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn posr(self) -> crate::common::Reg<regs::Posr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr1(pub u32);
        impl Pcntr1 {
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::Pcntr1Pdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr1Pdr00::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::Pcntr1Pdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::Pcntr1Pdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr1Pdr01::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::Pcntr1Pdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::Pcntr1Pdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr1Pdr02::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::Pcntr1Pdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::Pcntr1Pdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr1Pdr03::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::Pcntr1Pdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr04(&self) -> super::vals::Pcntr1Pdr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr1Pdr04::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr04(&mut self, val: super::vals::Pcntr1Pdr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr05(&self) -> super::vals::Pcntr1Pdr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr1Pdr05::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr05(&mut self, val: super::vals::Pcntr1Pdr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::Pcntr1Pdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr1Pdr06::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::Pcntr1Pdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::Pcntr1Pdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr1Pdr07::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::Pcntr1Pdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::Pcntr1Pdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr1Pdr08::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::Pcntr1Pdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::Pcntr1Pdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr1Pdr09::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::Pcntr1Pdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::Pcntr1Pdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr1Pdr10::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::Pcntr1Pdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::Pcntr1Pdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr1Pdr11::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::Pcntr1Pdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::Pcntr1Pdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr1Pdr12::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::Pcntr1Pdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::Pcntr1Pdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr1Pdr13::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::Pcntr1Pdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::Pcntr1Pdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr1Pdr14::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::Pcntr1Pdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::Pcntr1Pdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr1Pdr15::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::Pcntr1Pdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::Pcntr1Podr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr1Podr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::Pcntr1Podr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::Pcntr1Podr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr1Podr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::Pcntr1Podr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::Pcntr1Podr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr1Podr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::Pcntr1Podr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::Pcntr1Podr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr1Podr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::Pcntr1Podr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr04(&self) -> super::vals::Pcntr1Podr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr1Podr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr04(&mut self, val: super::vals::Pcntr1Podr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr05(&self) -> super::vals::Pcntr1Podr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr1Podr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr05(&mut self, val: super::vals::Pcntr1Podr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::Pcntr1Podr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr1Podr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::Pcntr1Podr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::Pcntr1Podr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr1Podr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::Pcntr1Podr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::Pcntr1Podr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr1Podr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::Pcntr1Podr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::Pcntr1Podr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr1Podr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::Pcntr1Podr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::Pcntr1Podr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr1Podr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::Pcntr1Podr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::Pcntr1Podr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr1Podr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::Pcntr1Podr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::Pcntr1Podr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr1Podr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::Pcntr1Podr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::Pcntr1Podr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr1Podr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::Pcntr1Podr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::Pcntr1Podr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr1Podr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::Pcntr1Podr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::Pcntr1Podr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr1Podr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::Pcntr1Podr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr1 {
            #[inline(always)]
            fn default() -> Pcntr1 {
                Pcntr1(0)
            }
        }
        impl core::fmt::Debug for Pcntr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr1")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr04", &self.pdr04())
                    .field("pdr05", &self.pdr05())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr04", &self.podr04())
                    .field("podr05", &self.podr05())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr1 {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr04: {:?}, pdr05: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?}, podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr04: {:?}, podr05: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr04 () , self . pdr05 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 () , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr04 () , self . podr05 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr2(pub u32);
        impl Pcntr2 {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::Pcntr2Pidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr2Pidr00::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::Pcntr2Pidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::Pcntr2Pidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr2Pidr01::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::Pcntr2Pidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::Pcntr2Pidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr2Pidr02::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::Pcntr2Pidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::Pcntr2Pidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr2Pidr03::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::Pcntr2Pidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr04(&self) -> super::vals::Pcntr2Pidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr2Pidr04::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr04(&mut self, val: super::vals::Pcntr2Pidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr05(&self) -> super::vals::Pcntr2Pidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr2Pidr05::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr05(&mut self, val: super::vals::Pcntr2Pidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::Pcntr2Pidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr2Pidr06::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::Pcntr2Pidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::Pcntr2Pidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr2Pidr07::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::Pcntr2Pidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::Pcntr2Pidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr2Pidr08::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::Pcntr2Pidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::Pcntr2Pidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr2Pidr09::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::Pcntr2Pidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::Pcntr2Pidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr2Pidr10::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::Pcntr2Pidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::Pcntr2Pidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr2Pidr11::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::Pcntr2Pidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::Pcntr2Pidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr2Pidr12::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::Pcntr2Pidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::Pcntr2Pidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr2Pidr13::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::Pcntr2Pidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::Pcntr2Pidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr2Pidr14::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::Pcntr2Pidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::Pcntr2Pidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr2Pidr15::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::Pcntr2Pidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Pcntr2 {
            #[inline(always)]
            fn default() -> Pcntr2 {
                Pcntr2(0)
            }
        }
        impl core::fmt::Debug for Pcntr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr2")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr04", &self.pidr04())
                    .field("pidr05", &self.pidr05())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr2 {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr04: {:?}, pidr05: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr04 () , self . pidr05 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr3(pub u32);
        impl Pcntr3 {
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::Pcntr3Posr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr3Posr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::Pcntr3Posr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::Pcntr3Posr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr3Posr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::Pcntr3Posr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::Pcntr3Posr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr3Posr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::Pcntr3Posr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::Pcntr3Posr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr3Posr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::Pcntr3Posr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr04(&self) -> super::vals::Pcntr3Posr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr3Posr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr04(&mut self, val: super::vals::Pcntr3Posr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr05(&self) -> super::vals::Pcntr3Posr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr3Posr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr05(&mut self, val: super::vals::Pcntr3Posr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::Pcntr3Posr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr3Posr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::Pcntr3Posr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::Pcntr3Posr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr3Posr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::Pcntr3Posr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::Pcntr3Posr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr3Posr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::Pcntr3Posr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::Pcntr3Posr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr3Posr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::Pcntr3Posr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::Pcntr3Posr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr3Posr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::Pcntr3Posr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::Pcntr3Posr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr3Posr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::Pcntr3Posr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::Pcntr3Posr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr3Posr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::Pcntr3Posr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::Pcntr3Posr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr3Posr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::Pcntr3Posr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::Pcntr3Posr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr3Posr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::Pcntr3Posr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::Pcntr3Posr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr3Posr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::Pcntr3Posr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::Pcntr3Porr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr3Porr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::Pcntr3Porr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::Pcntr3Porr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr3Porr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::Pcntr3Porr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::Pcntr3Porr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr3Porr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::Pcntr3Porr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::Pcntr3Porr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr3Porr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::Pcntr3Porr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr04(&self) -> super::vals::Pcntr3Porr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr3Porr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr04(&mut self, val: super::vals::Pcntr3Porr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr05(&self) -> super::vals::Pcntr3Porr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr3Porr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr05(&mut self, val: super::vals::Pcntr3Porr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::Pcntr3Porr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr3Porr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::Pcntr3Porr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::Pcntr3Porr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr3Porr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::Pcntr3Porr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::Pcntr3Porr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr3Porr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::Pcntr3Porr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::Pcntr3Porr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr3Porr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::Pcntr3Porr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::Pcntr3Porr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr3Porr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::Pcntr3Porr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::Pcntr3Porr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr3Porr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::Pcntr3Porr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::Pcntr3Porr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr3Porr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::Pcntr3Porr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::Pcntr3Porr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr3Porr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::Pcntr3Porr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::Pcntr3Porr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr3Porr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::Pcntr3Porr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::Pcntr3Porr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr3Porr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::Pcntr3Porr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr3 {
            #[inline(always)]
            fn default() -> Pcntr3 {
                Pcntr3(0)
            }
        }
        impl core::fmt::Debug for Pcntr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr3")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr04", &self.posr04())
                    .field("posr05", &self.posr05())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr04", &self.porr04())
                    .field("porr05", &self.porr05())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr3 {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr04: {:?}, posr05: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?}, porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr04: {:?}, porr05: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr04 () , self . posr05 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 () , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr04 () , self . porr05 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr(pub u16);
        impl Pdr {
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::PdrPdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PdrPdr00::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::PdrPdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::PdrPdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PdrPdr01::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::PdrPdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::PdrPdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PdrPdr02::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::PdrPdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::PdrPdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PdrPdr03::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::PdrPdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr04(&self) -> super::vals::PdrPdr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PdrPdr04::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr04(&mut self, val: super::vals::PdrPdr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr05(&self) -> super::vals::PdrPdr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PdrPdr05::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr05(&mut self, val: super::vals::PdrPdr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::PdrPdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PdrPdr06::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::PdrPdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::PdrPdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PdrPdr07::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::PdrPdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::PdrPdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PdrPdr08::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::PdrPdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::PdrPdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PdrPdr09::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::PdrPdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::PdrPdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PdrPdr10::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::PdrPdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::PdrPdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PdrPdr11::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::PdrPdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::PdrPdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PdrPdr12::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::PdrPdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::PdrPdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PdrPdr13::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::PdrPdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::PdrPdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PdrPdr14::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::PdrPdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::PdrPdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PdrPdr15::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::PdrPdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pdr {
            #[inline(always)]
            fn default() -> Pdr {
                Pdr(0)
            }
        }
        impl core::fmt::Debug for Pdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr04", &self.pdr04())
                    .field("pdr05", &self.pdr05())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pdr {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr04: {:?}, pdr05: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr04 () , self . pdr05 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 ())
            }
        }
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr(pub u16);
        impl Pidr {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::PidrPidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PidrPidr00::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::PidrPidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::PidrPidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PidrPidr01::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::PidrPidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::PidrPidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PidrPidr02::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::PidrPidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::PidrPidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PidrPidr03::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::PidrPidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr04(&self) -> super::vals::PidrPidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PidrPidr04::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr04(&mut self, val: super::vals::PidrPidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr05(&self) -> super::vals::PidrPidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PidrPidr05::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr05(&mut self, val: super::vals::PidrPidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::PidrPidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PidrPidr06::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::PidrPidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::PidrPidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PidrPidr07::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::PidrPidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::PidrPidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PidrPidr08::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::PidrPidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::PidrPidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PidrPidr09::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::PidrPidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::PidrPidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PidrPidr10::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::PidrPidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::PidrPidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PidrPidr11::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::PidrPidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::PidrPidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PidrPidr12::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::PidrPidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::PidrPidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PidrPidr13::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::PidrPidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::PidrPidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PidrPidr14::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::PidrPidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::PidrPidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PidrPidr15::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::PidrPidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pidr {
            #[inline(always)]
            fn default() -> Pidr {
                Pidr(0)
            }
        }
        impl core::fmt::Debug for Pidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr04", &self.pidr04())
                    .field("pidr05", &self.pidr05())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pidr {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr04: {:?}, pidr05: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr04 () , self . pidr05 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr(pub u16);
        impl Podr {
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::PodrPodr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PodrPodr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::PodrPodr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::PodrPodr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PodrPodr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::PodrPodr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::PodrPodr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PodrPodr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::PodrPodr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::PodrPodr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PodrPodr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::PodrPodr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr04(&self) -> super::vals::PodrPodr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PodrPodr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr04(&mut self, val: super::vals::PodrPodr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr05(&self) -> super::vals::PodrPodr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PodrPodr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr05(&mut self, val: super::vals::PodrPodr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::PodrPodr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PodrPodr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::PodrPodr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::PodrPodr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PodrPodr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::PodrPodr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::PodrPodr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PodrPodr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::PodrPodr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::PodrPodr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PodrPodr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::PodrPodr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::PodrPodr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PodrPodr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::PodrPodr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::PodrPodr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PodrPodr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::PodrPodr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::PodrPodr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PodrPodr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::PodrPodr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::PodrPodr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PodrPodr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::PodrPodr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::PodrPodr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PodrPodr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::PodrPodr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::PodrPodr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PodrPodr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::PodrPodr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Podr {
            #[inline(always)]
            fn default() -> Podr {
                Podr(0)
            }
        }
        impl core::fmt::Debug for Podr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr")
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr04", &self.podr04())
                    .field("podr05", &self.podr05())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Podr {{ podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr04: {:?}, podr05: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr04 () , self . podr05 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr(pub u16);
        impl Porr {
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::PorrPorr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PorrPorr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::PorrPorr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::PorrPorr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PorrPorr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::PorrPorr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::PorrPorr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PorrPorr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::PorrPorr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::PorrPorr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PorrPorr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::PorrPorr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr04(&self) -> super::vals::PorrPorr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PorrPorr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr04(&mut self, val: super::vals::PorrPorr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr05(&self) -> super::vals::PorrPorr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PorrPorr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr05(&mut self, val: super::vals::PorrPorr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::PorrPorr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PorrPorr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::PorrPorr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::PorrPorr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PorrPorr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::PorrPorr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::PorrPorr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PorrPorr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::PorrPorr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::PorrPorr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PorrPorr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::PorrPorr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::PorrPorr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PorrPorr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::PorrPorr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::PorrPorr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PorrPorr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::PorrPorr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::PorrPorr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PorrPorr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::PorrPorr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::PorrPorr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PorrPorr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::PorrPorr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::PorrPorr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PorrPorr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::PorrPorr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::PorrPorr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PorrPorr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::PorrPorr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Porr {
            #[inline(always)]
            fn default() -> Porr {
                Porr(0)
            }
        }
        impl core::fmt::Debug for Porr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr")
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr04", &self.porr04())
                    .field("porr05", &self.porr05())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Porr {{ porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr04: {:?}, porr05: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr04 () , self . porr05 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr(pub u16);
        impl Posr {
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::PosrPosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PosrPosr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::PosrPosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::PosrPosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PosrPosr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::PosrPosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::PosrPosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PosrPosr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::PosrPosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::PosrPosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PosrPosr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::PosrPosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr04(&self) -> super::vals::PosrPosr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PosrPosr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr04(&mut self, val: super::vals::PosrPosr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr05(&self) -> super::vals::PosrPosr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PosrPosr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr05(&mut self, val: super::vals::PosrPosr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::PosrPosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PosrPosr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::PosrPosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::PosrPosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PosrPosr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::PosrPosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::PosrPosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PosrPosr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::PosrPosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::PosrPosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PosrPosr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::PosrPosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::PosrPosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PosrPosr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::PosrPosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::PosrPosr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PosrPosr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::PosrPosr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::PosrPosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PosrPosr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::PosrPosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::PosrPosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PosrPosr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::PosrPosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::PosrPosr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PosrPosr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::PosrPosr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::PosrPosr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PosrPosr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::PosrPosr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Posr {
            #[inline(always)]
            fn default() -> Posr {
                Posr(0)
            }
        }
        impl core::fmt::Debug for Posr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr04", &self.posr04())
                    .field("posr05", &self.posr05())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Posr {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr04: {:?}, posr05: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr04 () , self . posr05 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr00 {
                Pcntr1Pdr00::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr00) -> u8 {
                Pcntr1Pdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr01 {
                Pcntr1Pdr01::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr01) -> u8 {
                Pcntr1Pdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr02 {
                Pcntr1Pdr02::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr02) -> u8 {
                Pcntr1Pdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr03 {
                Pcntr1Pdr03::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr03) -> u8 {
                Pcntr1Pdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr04 {
                Pcntr1Pdr04::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr04) -> u8 {
                Pcntr1Pdr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr05 {
                Pcntr1Pdr05::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr05) -> u8 {
                Pcntr1Pdr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr06 {
                Pcntr1Pdr06::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr06) -> u8 {
                Pcntr1Pdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr07 {
                Pcntr1Pdr07::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr07) -> u8 {
                Pcntr1Pdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr08 {
                Pcntr1Pdr08::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr08) -> u8 {
                Pcntr1Pdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr09 {
                Pcntr1Pdr09::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr09) -> u8 {
                Pcntr1Pdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr10 {
                Pcntr1Pdr10::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr10) -> u8 {
                Pcntr1Pdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr11 {
                Pcntr1Pdr11::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr11) -> u8 {
                Pcntr1Pdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr12 {
                Pcntr1Pdr12::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr12) -> u8 {
                Pcntr1Pdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr13 {
                Pcntr1Pdr13::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr13) -> u8 {
                Pcntr1Pdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr14 {
                Pcntr1Pdr14::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr14) -> u8 {
                Pcntr1Pdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr15 {
                Pcntr1Pdr15::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr15) -> u8 {
                Pcntr1Pdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr00 {
                Pcntr1Podr00::from_bits(val)
            }
        }
        impl From<Pcntr1Podr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr00) -> u8 {
                Pcntr1Podr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr01 {
                Pcntr1Podr01::from_bits(val)
            }
        }
        impl From<Pcntr1Podr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr01) -> u8 {
                Pcntr1Podr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr02 {
                Pcntr1Podr02::from_bits(val)
            }
        }
        impl From<Pcntr1Podr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr02) -> u8 {
                Pcntr1Podr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr03 {
                Pcntr1Podr03::from_bits(val)
            }
        }
        impl From<Pcntr1Podr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr03) -> u8 {
                Pcntr1Podr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr04 {
                Pcntr1Podr04::from_bits(val)
            }
        }
        impl From<Pcntr1Podr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr04) -> u8 {
                Pcntr1Podr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr05 {
                Pcntr1Podr05::from_bits(val)
            }
        }
        impl From<Pcntr1Podr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr05) -> u8 {
                Pcntr1Podr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr06 {
                Pcntr1Podr06::from_bits(val)
            }
        }
        impl From<Pcntr1Podr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr06) -> u8 {
                Pcntr1Podr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr07 {
                Pcntr1Podr07::from_bits(val)
            }
        }
        impl From<Pcntr1Podr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr07) -> u8 {
                Pcntr1Podr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr08 {
                Pcntr1Podr08::from_bits(val)
            }
        }
        impl From<Pcntr1Podr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr08) -> u8 {
                Pcntr1Podr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr09 {
                Pcntr1Podr09::from_bits(val)
            }
        }
        impl From<Pcntr1Podr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr09) -> u8 {
                Pcntr1Podr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr10 {
                Pcntr1Podr10::from_bits(val)
            }
        }
        impl From<Pcntr1Podr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr10) -> u8 {
                Pcntr1Podr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr11 {
                Pcntr1Podr11::from_bits(val)
            }
        }
        impl From<Pcntr1Podr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr11) -> u8 {
                Pcntr1Podr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr12 {
                Pcntr1Podr12::from_bits(val)
            }
        }
        impl From<Pcntr1Podr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr12) -> u8 {
                Pcntr1Podr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr13 {
                Pcntr1Podr13::from_bits(val)
            }
        }
        impl From<Pcntr1Podr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr13) -> u8 {
                Pcntr1Podr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr14 {
                Pcntr1Podr14::from_bits(val)
            }
        }
        impl From<Pcntr1Podr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr14) -> u8 {
                Pcntr1Podr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr15 {
                Pcntr1Podr15::from_bits(val)
            }
        }
        impl From<Pcntr1Podr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr15) -> u8 {
                Pcntr1Podr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr00 {
                Pcntr2Pidr00::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr00) -> u8 {
                Pcntr2Pidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr01 {
                Pcntr2Pidr01::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr01) -> u8 {
                Pcntr2Pidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr02 {
                Pcntr2Pidr02::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr02) -> u8 {
                Pcntr2Pidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr03 {
                Pcntr2Pidr03::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr03) -> u8 {
                Pcntr2Pidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr04 {
                Pcntr2Pidr04::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr04) -> u8 {
                Pcntr2Pidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr05 {
                Pcntr2Pidr05::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr05) -> u8 {
                Pcntr2Pidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr06 {
                Pcntr2Pidr06::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr06) -> u8 {
                Pcntr2Pidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr07 {
                Pcntr2Pidr07::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr07) -> u8 {
                Pcntr2Pidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr08 {
                Pcntr2Pidr08::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr08) -> u8 {
                Pcntr2Pidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr09 {
                Pcntr2Pidr09::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr09) -> u8 {
                Pcntr2Pidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr10 {
                Pcntr2Pidr10::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr10) -> u8 {
                Pcntr2Pidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr11 {
                Pcntr2Pidr11::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr11) -> u8 {
                Pcntr2Pidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr12 {
                Pcntr2Pidr12::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr12) -> u8 {
                Pcntr2Pidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr13 {
                Pcntr2Pidr13::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr13) -> u8 {
                Pcntr2Pidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr14 {
                Pcntr2Pidr14::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr14) -> u8 {
                Pcntr2Pidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr15 {
                Pcntr2Pidr15::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr15) -> u8 {
                Pcntr2Pidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr00 {
                Pcntr3Porr00::from_bits(val)
            }
        }
        impl From<Pcntr3Porr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr00) -> u8 {
                Pcntr3Porr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr01 {
                Pcntr3Porr01::from_bits(val)
            }
        }
        impl From<Pcntr3Porr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr01) -> u8 {
                Pcntr3Porr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr02 {
                Pcntr3Porr02::from_bits(val)
            }
        }
        impl From<Pcntr3Porr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr02) -> u8 {
                Pcntr3Porr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr03 {
                Pcntr3Porr03::from_bits(val)
            }
        }
        impl From<Pcntr3Porr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr03) -> u8 {
                Pcntr3Porr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr04 {
                Pcntr3Porr04::from_bits(val)
            }
        }
        impl From<Pcntr3Porr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr04) -> u8 {
                Pcntr3Porr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr05 {
                Pcntr3Porr05::from_bits(val)
            }
        }
        impl From<Pcntr3Porr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr05) -> u8 {
                Pcntr3Porr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr06 {
                Pcntr3Porr06::from_bits(val)
            }
        }
        impl From<Pcntr3Porr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr06) -> u8 {
                Pcntr3Porr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr07 {
                Pcntr3Porr07::from_bits(val)
            }
        }
        impl From<Pcntr3Porr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr07) -> u8 {
                Pcntr3Porr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr08 {
                Pcntr3Porr08::from_bits(val)
            }
        }
        impl From<Pcntr3Porr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr08) -> u8 {
                Pcntr3Porr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr09 {
                Pcntr3Porr09::from_bits(val)
            }
        }
        impl From<Pcntr3Porr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr09) -> u8 {
                Pcntr3Porr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr10 {
                Pcntr3Porr10::from_bits(val)
            }
        }
        impl From<Pcntr3Porr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr10) -> u8 {
                Pcntr3Porr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr11 {
                Pcntr3Porr11::from_bits(val)
            }
        }
        impl From<Pcntr3Porr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr11) -> u8 {
                Pcntr3Porr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr12 {
                Pcntr3Porr12::from_bits(val)
            }
        }
        impl From<Pcntr3Porr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr12) -> u8 {
                Pcntr3Porr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr13 {
                Pcntr3Porr13::from_bits(val)
            }
        }
        impl From<Pcntr3Porr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr13) -> u8 {
                Pcntr3Porr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr14 {
                Pcntr3Porr14::from_bits(val)
            }
        }
        impl From<Pcntr3Porr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr14) -> u8 {
                Pcntr3Porr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr15 {
                Pcntr3Porr15::from_bits(val)
            }
        }
        impl From<Pcntr3Porr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr15) -> u8 {
                Pcntr3Porr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr00 {
                Pcntr3Posr00::from_bits(val)
            }
        }
        impl From<Pcntr3Posr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr00) -> u8 {
                Pcntr3Posr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr01 {
                Pcntr3Posr01::from_bits(val)
            }
        }
        impl From<Pcntr3Posr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr01) -> u8 {
                Pcntr3Posr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr02 {
                Pcntr3Posr02::from_bits(val)
            }
        }
        impl From<Pcntr3Posr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr02) -> u8 {
                Pcntr3Posr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr03 {
                Pcntr3Posr03::from_bits(val)
            }
        }
        impl From<Pcntr3Posr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr03) -> u8 {
                Pcntr3Posr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr04 {
                Pcntr3Posr04::from_bits(val)
            }
        }
        impl From<Pcntr3Posr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr04) -> u8 {
                Pcntr3Posr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr05 {
                Pcntr3Posr05::from_bits(val)
            }
        }
        impl From<Pcntr3Posr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr05) -> u8 {
                Pcntr3Posr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr06 {
                Pcntr3Posr06::from_bits(val)
            }
        }
        impl From<Pcntr3Posr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr06) -> u8 {
                Pcntr3Posr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr07 {
                Pcntr3Posr07::from_bits(val)
            }
        }
        impl From<Pcntr3Posr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr07) -> u8 {
                Pcntr3Posr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr08 {
                Pcntr3Posr08::from_bits(val)
            }
        }
        impl From<Pcntr3Posr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr08) -> u8 {
                Pcntr3Posr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr09 {
                Pcntr3Posr09::from_bits(val)
            }
        }
        impl From<Pcntr3Posr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr09) -> u8 {
                Pcntr3Posr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr10 {
                Pcntr3Posr10::from_bits(val)
            }
        }
        impl From<Pcntr3Posr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr10) -> u8 {
                Pcntr3Posr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr11 {
                Pcntr3Posr11::from_bits(val)
            }
        }
        impl From<Pcntr3Posr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr11) -> u8 {
                Pcntr3Posr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr12 {
                Pcntr3Posr12::from_bits(val)
            }
        }
        impl From<Pcntr3Posr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr12) -> u8 {
                Pcntr3Posr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr13 {
                Pcntr3Posr13::from_bits(val)
            }
        }
        impl From<Pcntr3Posr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr13) -> u8 {
                Pcntr3Posr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr14 {
                Pcntr3Posr14::from_bits(val)
            }
        }
        impl From<Pcntr3Posr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr14) -> u8 {
                Pcntr3Posr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr15 {
                Pcntr3Posr15::from_bits(val)
            }
        }
        impl From<Pcntr3Posr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr15) -> u8 {
                Pcntr3Posr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr00 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr00 {
                PdrPdr00::from_bits(val)
            }
        }
        impl From<PdrPdr00> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr00) -> u8 {
                PdrPdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr01 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr01 {
                PdrPdr01::from_bits(val)
            }
        }
        impl From<PdrPdr01> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr01) -> u8 {
                PdrPdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr02 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr02 {
                PdrPdr02::from_bits(val)
            }
        }
        impl From<PdrPdr02> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr02) -> u8 {
                PdrPdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr03 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr03 {
                PdrPdr03::from_bits(val)
            }
        }
        impl From<PdrPdr03> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr03) -> u8 {
                PdrPdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr04 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr04 {
                PdrPdr04::from_bits(val)
            }
        }
        impl From<PdrPdr04> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr04) -> u8 {
                PdrPdr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr05 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr05 {
                PdrPdr05::from_bits(val)
            }
        }
        impl From<PdrPdr05> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr05) -> u8 {
                PdrPdr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr06 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr06 {
                PdrPdr06::from_bits(val)
            }
        }
        impl From<PdrPdr06> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr06) -> u8 {
                PdrPdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr07 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr07 {
                PdrPdr07::from_bits(val)
            }
        }
        impl From<PdrPdr07> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr07) -> u8 {
                PdrPdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr08 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr08 {
                PdrPdr08::from_bits(val)
            }
        }
        impl From<PdrPdr08> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr08) -> u8 {
                PdrPdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr09 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr09 {
                PdrPdr09::from_bits(val)
            }
        }
        impl From<PdrPdr09> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr09) -> u8 {
                PdrPdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr10 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr10 {
                PdrPdr10::from_bits(val)
            }
        }
        impl From<PdrPdr10> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr10) -> u8 {
                PdrPdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr11 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr11 {
                PdrPdr11::from_bits(val)
            }
        }
        impl From<PdrPdr11> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr11) -> u8 {
                PdrPdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr12 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr12 {
                PdrPdr12::from_bits(val)
            }
        }
        impl From<PdrPdr12> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr12) -> u8 {
                PdrPdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr13 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr13 {
                PdrPdr13::from_bits(val)
            }
        }
        impl From<PdrPdr13> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr13) -> u8 {
                PdrPdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr14 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr14 {
                PdrPdr14::from_bits(val)
            }
        }
        impl From<PdrPdr14> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr14) -> u8 {
                PdrPdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr15 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr15 {
                PdrPdr15::from_bits(val)
            }
        }
        impl From<PdrPdr15> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr15) -> u8 {
                PdrPdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr00 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr00 {
                PidrPidr00::from_bits(val)
            }
        }
        impl From<PidrPidr00> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr00) -> u8 {
                PidrPidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr01 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr01 {
                PidrPidr01::from_bits(val)
            }
        }
        impl From<PidrPidr01> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr01) -> u8 {
                PidrPidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr02 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr02 {
                PidrPidr02::from_bits(val)
            }
        }
        impl From<PidrPidr02> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr02) -> u8 {
                PidrPidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr03 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr03 {
                PidrPidr03::from_bits(val)
            }
        }
        impl From<PidrPidr03> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr03) -> u8 {
                PidrPidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr04 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr04 {
                PidrPidr04::from_bits(val)
            }
        }
        impl From<PidrPidr04> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr04) -> u8 {
                PidrPidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr05 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr05 {
                PidrPidr05::from_bits(val)
            }
        }
        impl From<PidrPidr05> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr05) -> u8 {
                PidrPidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr06 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr06 {
                PidrPidr06::from_bits(val)
            }
        }
        impl From<PidrPidr06> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr06) -> u8 {
                PidrPidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr07 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr07 {
                PidrPidr07::from_bits(val)
            }
        }
        impl From<PidrPidr07> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr07) -> u8 {
                PidrPidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr08 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr08 {
                PidrPidr08::from_bits(val)
            }
        }
        impl From<PidrPidr08> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr08) -> u8 {
                PidrPidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr09 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr09 {
                PidrPidr09::from_bits(val)
            }
        }
        impl From<PidrPidr09> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr09) -> u8 {
                PidrPidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr10 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr10 {
                PidrPidr10::from_bits(val)
            }
        }
        impl From<PidrPidr10> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr10) -> u8 {
                PidrPidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr11 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr11 {
                PidrPidr11::from_bits(val)
            }
        }
        impl From<PidrPidr11> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr11) -> u8 {
                PidrPidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr12 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr12 {
                PidrPidr12::from_bits(val)
            }
        }
        impl From<PidrPidr12> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr12) -> u8 {
                PidrPidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr13 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr13 {
                PidrPidr13::from_bits(val)
            }
        }
        impl From<PidrPidr13> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr13) -> u8 {
                PidrPidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr14 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr14 {
                PidrPidr14::from_bits(val)
            }
        }
        impl From<PidrPidr14> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr14) -> u8 {
                PidrPidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr15 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr15 {
                PidrPidr15::from_bits(val)
            }
        }
        impl From<PidrPidr15> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr15) -> u8 {
                PidrPidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr00 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr00 {
                PodrPodr00::from_bits(val)
            }
        }
        impl From<PodrPodr00> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr00) -> u8 {
                PodrPodr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr01 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr01 {
                PodrPodr01::from_bits(val)
            }
        }
        impl From<PodrPodr01> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr01) -> u8 {
                PodrPodr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr02 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr02 {
                PodrPodr02::from_bits(val)
            }
        }
        impl From<PodrPodr02> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr02) -> u8 {
                PodrPodr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr03 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr03 {
                PodrPodr03::from_bits(val)
            }
        }
        impl From<PodrPodr03> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr03) -> u8 {
                PodrPodr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr04 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr04 {
                PodrPodr04::from_bits(val)
            }
        }
        impl From<PodrPodr04> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr04) -> u8 {
                PodrPodr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr05 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr05 {
                PodrPodr05::from_bits(val)
            }
        }
        impl From<PodrPodr05> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr05) -> u8 {
                PodrPodr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr06 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr06 {
                PodrPodr06::from_bits(val)
            }
        }
        impl From<PodrPodr06> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr06) -> u8 {
                PodrPodr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr07 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr07 {
                PodrPodr07::from_bits(val)
            }
        }
        impl From<PodrPodr07> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr07) -> u8 {
                PodrPodr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr08 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr08 {
                PodrPodr08::from_bits(val)
            }
        }
        impl From<PodrPodr08> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr08) -> u8 {
                PodrPodr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr09 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr09 {
                PodrPodr09::from_bits(val)
            }
        }
        impl From<PodrPodr09> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr09) -> u8 {
                PodrPodr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr10 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr10 {
                PodrPodr10::from_bits(val)
            }
        }
        impl From<PodrPodr10> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr10) -> u8 {
                PodrPodr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr11 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr11 {
                PodrPodr11::from_bits(val)
            }
        }
        impl From<PodrPodr11> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr11) -> u8 {
                PodrPodr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr12 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr12 {
                PodrPodr12::from_bits(val)
            }
        }
        impl From<PodrPodr12> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr12) -> u8 {
                PodrPodr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr13 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr13 {
                PodrPodr13::from_bits(val)
            }
        }
        impl From<PodrPodr13> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr13) -> u8 {
                PodrPodr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr14 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr14 {
                PodrPodr14::from_bits(val)
            }
        }
        impl From<PodrPodr14> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr14) -> u8 {
                PodrPodr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr15 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr15 {
                PodrPodr15::from_bits(val)
            }
        }
        impl From<PodrPodr15> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr15) -> u8 {
                PodrPodr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr00 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr00 {
                PorrPorr00::from_bits(val)
            }
        }
        impl From<PorrPorr00> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr00) -> u8 {
                PorrPorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr01 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr01 {
                PorrPorr01::from_bits(val)
            }
        }
        impl From<PorrPorr01> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr01) -> u8 {
                PorrPorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr02 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr02 {
                PorrPorr02::from_bits(val)
            }
        }
        impl From<PorrPorr02> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr02) -> u8 {
                PorrPorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr03 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr03 {
                PorrPorr03::from_bits(val)
            }
        }
        impl From<PorrPorr03> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr03) -> u8 {
                PorrPorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr04 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr04 {
                PorrPorr04::from_bits(val)
            }
        }
        impl From<PorrPorr04> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr04) -> u8 {
                PorrPorr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr05 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr05 {
                PorrPorr05::from_bits(val)
            }
        }
        impl From<PorrPorr05> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr05) -> u8 {
                PorrPorr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr06 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr06 {
                PorrPorr06::from_bits(val)
            }
        }
        impl From<PorrPorr06> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr06) -> u8 {
                PorrPorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr07 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr07 {
                PorrPorr07::from_bits(val)
            }
        }
        impl From<PorrPorr07> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr07) -> u8 {
                PorrPorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr08 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr08 {
                PorrPorr08::from_bits(val)
            }
        }
        impl From<PorrPorr08> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr08) -> u8 {
                PorrPorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr09 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr09 {
                PorrPorr09::from_bits(val)
            }
        }
        impl From<PorrPorr09> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr09) -> u8 {
                PorrPorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr10 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr10 {
                PorrPorr10::from_bits(val)
            }
        }
        impl From<PorrPorr10> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr10) -> u8 {
                PorrPorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr11 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr11 {
                PorrPorr11::from_bits(val)
            }
        }
        impl From<PorrPorr11> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr11) -> u8 {
                PorrPorr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr12 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr12 {
                PorrPorr12::from_bits(val)
            }
        }
        impl From<PorrPorr12> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr12) -> u8 {
                PorrPorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr13 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr13 {
                PorrPorr13::from_bits(val)
            }
        }
        impl From<PorrPorr13> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr13) -> u8 {
                PorrPorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr14 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr14 {
                PorrPorr14::from_bits(val)
            }
        }
        impl From<PorrPorr14> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr14) -> u8 {
                PorrPorr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr15 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr15 {
                PorrPorr15::from_bits(val)
            }
        }
        impl From<PorrPorr15> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr15) -> u8 {
                PorrPorr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr00 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr00 {
                PosrPosr00::from_bits(val)
            }
        }
        impl From<PosrPosr00> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr00) -> u8 {
                PosrPosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr01 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr01 {
                PosrPosr01::from_bits(val)
            }
        }
        impl From<PosrPosr01> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr01) -> u8 {
                PosrPosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr02 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr02 {
                PosrPosr02::from_bits(val)
            }
        }
        impl From<PosrPosr02> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr02) -> u8 {
                PosrPosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr03 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr03 {
                PosrPosr03::from_bits(val)
            }
        }
        impl From<PosrPosr03> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr03) -> u8 {
                PosrPosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr04 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr04 {
                PosrPosr04::from_bits(val)
            }
        }
        impl From<PosrPosr04> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr04) -> u8 {
                PosrPosr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr05 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr05 {
                PosrPosr05::from_bits(val)
            }
        }
        impl From<PosrPosr05> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr05) -> u8 {
                PosrPosr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr06 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr06 {
                PosrPosr06::from_bits(val)
            }
        }
        impl From<PosrPosr06> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr06) -> u8 {
                PosrPosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr07 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr07 {
                PosrPosr07::from_bits(val)
            }
        }
        impl From<PosrPosr07> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr07) -> u8 {
                PosrPosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr08 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr08 {
                PosrPosr08::from_bits(val)
            }
        }
        impl From<PosrPosr08> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr08) -> u8 {
                PosrPosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr09 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr09 {
                PosrPosr09::from_bits(val)
            }
        }
        impl From<PosrPosr09> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr09) -> u8 {
                PosrPosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr10 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr10 {
                PosrPosr10::from_bits(val)
            }
        }
        impl From<PosrPosr10> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr10) -> u8 {
                PosrPosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr11 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr11 {
                PosrPosr11::from_bits(val)
            }
        }
        impl From<PosrPosr11> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr11) -> u8 {
                PosrPosr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr12 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr12 {
                PosrPosr12::from_bits(val)
            }
        }
        impl From<PosrPosr12> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr12) -> u8 {
                PosrPosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr13 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr13 {
                PosrPosr13::from_bits(val)
            }
        }
        impl From<PosrPosr13> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr13) -> u8 {
                PosrPosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr14 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr14 {
                PosrPosr14::from_bits(val)
            }
        }
        impl From<PosrPosr14> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr14) -> u8 {
                PosrPosr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr15 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr15 {
                PosrPosr15::from_bits(val)
            }
        }
        impl From<PosrPosr15> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr15) -> u8 {
                PosrPosr15::to_bits(val)
            }
        }
    }
}
pub mod port1 {
    #[doc = "Port 1 Control Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Port1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Port1 {}
    unsafe impl Sync for Port1 {}
    impl Port1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pcntr1(self) -> crate::common::Reg<regs::Pcntr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn podr(self) -> crate::common::Reg<regs::Podr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Port Control Register 1"]
        #[inline(always)]
        pub const fn pdr(self) -> crate::common::Reg<regs::Pdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn eidr(self) -> crate::common::Reg<regs::Eidr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pcntr2(self) -> crate::common::Reg<regs::Pcntr2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Port Control Register 2"]
        #[inline(always)]
        pub const fn pidr(self) -> crate::common::Reg<regs::Pidr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn pcntr3(self) -> crate::common::Reg<regs::Pcntr3, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn porr(self) -> crate::common::Reg<regs::Porr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Port Control Register 3"]
        #[inline(always)]
        pub const fn posr(self) -> crate::common::Reg<regs::Posr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "Port Control Register 4"]
        #[inline(always)]
        pub const fn eorr(self) -> crate::common::Reg<regs::Eorr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Port Control Register 4"]
        #[inline(always)]
        pub const fn pcntr4(self) -> crate::common::Reg<regs::Pcntr4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Port Control Register 4"]
        #[inline(always)]
        pub const fn eosr(self) -> crate::common::Reg<regs::Eosr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eidr(pub u16);
        impl Eidr {
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr00(&self) -> super::vals::EidrEidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EidrEidr00::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr00(&mut self, val: super::vals::EidrEidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr01(&self) -> super::vals::EidrEidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::EidrEidr01::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr01(&mut self, val: super::vals::EidrEidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr02(&self) -> super::vals::EidrEidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::EidrEidr02::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr02(&mut self, val: super::vals::EidrEidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr03(&self) -> super::vals::EidrEidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::EidrEidr03::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr03(&mut self, val: super::vals::EidrEidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr04(&self) -> super::vals::EidrEidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::EidrEidr04::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr04(&mut self, val: super::vals::EidrEidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr05(&self) -> super::vals::EidrEidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::EidrEidr05::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr05(&mut self, val: super::vals::EidrEidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr06(&self) -> super::vals::EidrEidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::EidrEidr06::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr06(&mut self, val: super::vals::EidrEidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr07(&self) -> super::vals::EidrEidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::EidrEidr07::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr07(&mut self, val: super::vals::EidrEidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr08(&self) -> super::vals::EidrEidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::EidrEidr08::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr08(&mut self, val: super::vals::EidrEidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr09(&self) -> super::vals::EidrEidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::EidrEidr09::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr09(&mut self, val: super::vals::EidrEidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr10(&self) -> super::vals::EidrEidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::EidrEidr10::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr10(&mut self, val: super::vals::EidrEidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr11(&self) -> super::vals::EidrEidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::EidrEidr11::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr11(&mut self, val: super::vals::EidrEidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr12(&self) -> super::vals::EidrEidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::EidrEidr12::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr12(&mut self, val: super::vals::EidrEidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr13(&self) -> super::vals::EidrEidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::EidrEidr13::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr13(&mut self, val: super::vals::EidrEidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr14(&self) -> super::vals::EidrEidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::EidrEidr14::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr14(&mut self, val: super::vals::EidrEidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr15(&self) -> super::vals::EidrEidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::EidrEidr15::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr15(&mut self, val: super::vals::EidrEidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Eidr {
            #[inline(always)]
            fn default() -> Eidr {
                Eidr(0)
            }
        }
        impl core::fmt::Debug for Eidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eidr")
                    .field("eidr00", &self.eidr00())
                    .field("eidr01", &self.eidr01())
                    .field("eidr02", &self.eidr02())
                    .field("eidr03", &self.eidr03())
                    .field("eidr04", &self.eidr04())
                    .field("eidr05", &self.eidr05())
                    .field("eidr06", &self.eidr06())
                    .field("eidr07", &self.eidr07())
                    .field("eidr08", &self.eidr08())
                    .field("eidr09", &self.eidr09())
                    .field("eidr10", &self.eidr10())
                    .field("eidr11", &self.eidr11())
                    .field("eidr12", &self.eidr12())
                    .field("eidr13", &self.eidr13())
                    .field("eidr14", &self.eidr14())
                    .field("eidr15", &self.eidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eidr {{ eidr00: {:?}, eidr01: {:?}, eidr02: {:?}, eidr03: {:?}, eidr04: {:?}, eidr05: {:?}, eidr06: {:?}, eidr07: {:?}, eidr08: {:?}, eidr09: {:?}, eidr10: {:?}, eidr11: {:?}, eidr12: {:?}, eidr13: {:?}, eidr14: {:?}, eidr15: {:?} }}" , self . eidr00 () , self . eidr01 () , self . eidr02 () , self . eidr03 () , self . eidr04 () , self . eidr05 () , self . eidr06 () , self . eidr07 () , self . eidr08 () , self . eidr09 () , self . eidr10 () , self . eidr11 () , self . eidr12 () , self . eidr13 () , self . eidr14 () , self . eidr15 ())
            }
        }
        #[doc = "Port Control Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eorr(pub u16);
        impl Eorr {
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr00(&self) -> super::vals::EorrEorr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EorrEorr00::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr00(&mut self, val: super::vals::EorrEorr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr01(&self) -> super::vals::EorrEorr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::EorrEorr01::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr01(&mut self, val: super::vals::EorrEorr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr02(&self) -> super::vals::EorrEorr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::EorrEorr02::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr02(&mut self, val: super::vals::EorrEorr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr03(&self) -> super::vals::EorrEorr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::EorrEorr03::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr03(&mut self, val: super::vals::EorrEorr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr04(&self) -> super::vals::EorrEorr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::EorrEorr04::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr04(&mut self, val: super::vals::EorrEorr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr05(&self) -> super::vals::EorrEorr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::EorrEorr05::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr05(&mut self, val: super::vals::EorrEorr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr06(&self) -> super::vals::EorrEorr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::EorrEorr06::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr06(&mut self, val: super::vals::EorrEorr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr07(&self) -> super::vals::EorrEorr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::EorrEorr07::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr07(&mut self, val: super::vals::EorrEorr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr08(&self) -> super::vals::EorrEorr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::EorrEorr08::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr08(&mut self, val: super::vals::EorrEorr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr09(&self) -> super::vals::EorrEorr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::EorrEorr09::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr09(&mut self, val: super::vals::EorrEorr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr10(&self) -> super::vals::EorrEorr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::EorrEorr10::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr10(&mut self, val: super::vals::EorrEorr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr11(&self) -> super::vals::EorrEorr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::EorrEorr11::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr11(&mut self, val: super::vals::EorrEorr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr12(&self) -> super::vals::EorrEorr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::EorrEorr12::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr12(&mut self, val: super::vals::EorrEorr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr13(&self) -> super::vals::EorrEorr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::EorrEorr13::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr13(&mut self, val: super::vals::EorrEorr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr14(&self) -> super::vals::EorrEorr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::EorrEorr14::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr14(&mut self, val: super::vals::EorrEorr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr15(&self) -> super::vals::EorrEorr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::EorrEorr15::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr15(&mut self, val: super::vals::EorrEorr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Eorr {
            #[inline(always)]
            fn default() -> Eorr {
                Eorr(0)
            }
        }
        impl core::fmt::Debug for Eorr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eorr")
                    .field("eorr00", &self.eorr00())
                    .field("eorr01", &self.eorr01())
                    .field("eorr02", &self.eorr02())
                    .field("eorr03", &self.eorr03())
                    .field("eorr04", &self.eorr04())
                    .field("eorr05", &self.eorr05())
                    .field("eorr06", &self.eorr06())
                    .field("eorr07", &self.eorr07())
                    .field("eorr08", &self.eorr08())
                    .field("eorr09", &self.eorr09())
                    .field("eorr10", &self.eorr10())
                    .field("eorr11", &self.eorr11())
                    .field("eorr12", &self.eorr12())
                    .field("eorr13", &self.eorr13())
                    .field("eorr14", &self.eorr14())
                    .field("eorr15", &self.eorr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eorr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eorr {{ eorr00: {:?}, eorr01: {:?}, eorr02: {:?}, eorr03: {:?}, eorr04: {:?}, eorr05: {:?}, eorr06: {:?}, eorr07: {:?}, eorr08: {:?}, eorr09: {:?}, eorr10: {:?}, eorr11: {:?}, eorr12: {:?}, eorr13: {:?}, eorr14: {:?}, eorr15: {:?} }}" , self . eorr00 () , self . eorr01 () , self . eorr02 () , self . eorr03 () , self . eorr04 () , self . eorr05 () , self . eorr06 () , self . eorr07 () , self . eorr08 () , self . eorr09 () , self . eorr10 () , self . eorr11 () , self . eorr12 () , self . eorr13 () , self . eorr14 () , self . eorr15 ())
            }
        }
        #[doc = "Port Control Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eosr(pub u16);
        impl Eosr {
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr00(&self) -> super::vals::EosrEosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EosrEosr00::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr00(&mut self, val: super::vals::EosrEosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr01(&self) -> super::vals::EosrEosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::EosrEosr01::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr01(&mut self, val: super::vals::EosrEosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr02(&self) -> super::vals::EosrEosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::EosrEosr02::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr02(&mut self, val: super::vals::EosrEosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr03(&self) -> super::vals::EosrEosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::EosrEosr03::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr03(&mut self, val: super::vals::EosrEosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr04(&self) -> super::vals::EosrEosr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::EosrEosr04::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr04(&mut self, val: super::vals::EosrEosr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr05(&self) -> super::vals::EosrEosr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::EosrEosr05::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr05(&mut self, val: super::vals::EosrEosr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr06(&self) -> super::vals::EosrEosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::EosrEosr06::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr06(&mut self, val: super::vals::EosrEosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr07(&self) -> super::vals::EosrEosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::EosrEosr07::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr07(&mut self, val: super::vals::EosrEosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr08(&self) -> super::vals::EosrEosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::EosrEosr08::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr08(&mut self, val: super::vals::EosrEosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr09(&self) -> super::vals::EosrEosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::EosrEosr09::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr09(&mut self, val: super::vals::EosrEosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr10(&self) -> super::vals::EosrEosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::EosrEosr10::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr10(&mut self, val: super::vals::EosrEosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr11(&self) -> super::vals::EosrEosr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::EosrEosr11::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr11(&mut self, val: super::vals::EosrEosr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr12(&self) -> super::vals::EosrEosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::EosrEosr12::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr12(&mut self, val: super::vals::EosrEosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr13(&self) -> super::vals::EosrEosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::EosrEosr13::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr13(&mut self, val: super::vals::EosrEosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr14(&self) -> super::vals::EosrEosr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::EosrEosr14::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr14(&mut self, val: super::vals::EosrEosr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr15(&self) -> super::vals::EosrEosr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::EosrEosr15::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr15(&mut self, val: super::vals::EosrEosr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Eosr {
            #[inline(always)]
            fn default() -> Eosr {
                Eosr(0)
            }
        }
        impl core::fmt::Debug for Eosr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eosr")
                    .field("eosr00", &self.eosr00())
                    .field("eosr01", &self.eosr01())
                    .field("eosr02", &self.eosr02())
                    .field("eosr03", &self.eosr03())
                    .field("eosr04", &self.eosr04())
                    .field("eosr05", &self.eosr05())
                    .field("eosr06", &self.eosr06())
                    .field("eosr07", &self.eosr07())
                    .field("eosr08", &self.eosr08())
                    .field("eosr09", &self.eosr09())
                    .field("eosr10", &self.eosr10())
                    .field("eosr11", &self.eosr11())
                    .field("eosr12", &self.eosr12())
                    .field("eosr13", &self.eosr13())
                    .field("eosr14", &self.eosr14())
                    .field("eosr15", &self.eosr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eosr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Eosr {{ eosr00: {:?}, eosr01: {:?}, eosr02: {:?}, eosr03: {:?}, eosr04: {:?}, eosr05: {:?}, eosr06: {:?}, eosr07: {:?}, eosr08: {:?}, eosr09: {:?}, eosr10: {:?}, eosr11: {:?}, eosr12: {:?}, eosr13: {:?}, eosr14: {:?}, eosr15: {:?} }}" , self . eosr00 () , self . eosr01 () , self . eosr02 () , self . eosr03 () , self . eosr04 () , self . eosr05 () , self . eosr06 () , self . eosr07 () , self . eosr08 () , self . eosr09 () , self . eosr10 () , self . eosr11 () , self . eosr12 () , self . eosr13 () , self . eosr14 () , self . eosr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr1(pub u32);
        impl Pcntr1 {
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::Pcntr1Pdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr1Pdr00::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::Pcntr1Pdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::Pcntr1Pdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr1Pdr01::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::Pcntr1Pdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::Pcntr1Pdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr1Pdr02::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::Pcntr1Pdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::Pcntr1Pdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr1Pdr03::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::Pcntr1Pdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr04(&self) -> super::vals::Pcntr1Pdr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr1Pdr04::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr04(&mut self, val: super::vals::Pcntr1Pdr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr05(&self) -> super::vals::Pcntr1Pdr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr1Pdr05::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr05(&mut self, val: super::vals::Pcntr1Pdr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::Pcntr1Pdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr1Pdr06::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::Pcntr1Pdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::Pcntr1Pdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr1Pdr07::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::Pcntr1Pdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::Pcntr1Pdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr1Pdr08::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::Pcntr1Pdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::Pcntr1Pdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr1Pdr09::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::Pcntr1Pdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::Pcntr1Pdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr1Pdr10::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::Pcntr1Pdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::Pcntr1Pdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr1Pdr11::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::Pcntr1Pdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::Pcntr1Pdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr1Pdr12::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::Pcntr1Pdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::Pcntr1Pdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr1Pdr13::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::Pcntr1Pdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::Pcntr1Pdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr1Pdr14::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::Pcntr1Pdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::Pcntr1Pdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr1Pdr15::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::Pcntr1Pdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::Pcntr1Podr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr1Podr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::Pcntr1Podr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::Pcntr1Podr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr1Podr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::Pcntr1Podr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::Pcntr1Podr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr1Podr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::Pcntr1Podr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::Pcntr1Podr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr1Podr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::Pcntr1Podr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr04(&self) -> super::vals::Pcntr1Podr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr1Podr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr04(&mut self, val: super::vals::Pcntr1Podr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr05(&self) -> super::vals::Pcntr1Podr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr1Podr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr05(&mut self, val: super::vals::Pcntr1Podr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::Pcntr1Podr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr1Podr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::Pcntr1Podr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::Pcntr1Podr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr1Podr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::Pcntr1Podr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::Pcntr1Podr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr1Podr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::Pcntr1Podr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::Pcntr1Podr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr1Podr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::Pcntr1Podr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::Pcntr1Podr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr1Podr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::Pcntr1Podr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::Pcntr1Podr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr1Podr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::Pcntr1Podr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::Pcntr1Podr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr1Podr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::Pcntr1Podr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::Pcntr1Podr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr1Podr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::Pcntr1Podr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::Pcntr1Podr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr1Podr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::Pcntr1Podr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::Pcntr1Podr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr1Podr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::Pcntr1Podr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr1 {
            #[inline(always)]
            fn default() -> Pcntr1 {
                Pcntr1(0)
            }
        }
        impl core::fmt::Debug for Pcntr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr1")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr04", &self.pdr04())
                    .field("pdr05", &self.pdr05())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr04", &self.podr04())
                    .field("podr05", &self.podr05())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr1 {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr04: {:?}, pdr05: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?}, podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr04: {:?}, podr05: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr04 () , self . pdr05 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 () , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr04 () , self . podr05 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr2(pub u32);
        impl Pcntr2 {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::Pcntr2Pidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr2Pidr00::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::Pcntr2Pidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::Pcntr2Pidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr2Pidr01::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::Pcntr2Pidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::Pcntr2Pidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr2Pidr02::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::Pcntr2Pidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::Pcntr2Pidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr2Pidr03::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::Pcntr2Pidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr04(&self) -> super::vals::Pcntr2Pidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr2Pidr04::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr04(&mut self, val: super::vals::Pcntr2Pidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr05(&self) -> super::vals::Pcntr2Pidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr2Pidr05::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr05(&mut self, val: super::vals::Pcntr2Pidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::Pcntr2Pidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr2Pidr06::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::Pcntr2Pidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::Pcntr2Pidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr2Pidr07::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::Pcntr2Pidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::Pcntr2Pidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr2Pidr08::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::Pcntr2Pidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::Pcntr2Pidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr2Pidr09::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::Pcntr2Pidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::Pcntr2Pidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr2Pidr10::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::Pcntr2Pidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::Pcntr2Pidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr2Pidr11::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::Pcntr2Pidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::Pcntr2Pidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr2Pidr12::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::Pcntr2Pidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::Pcntr2Pidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr2Pidr13::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::Pcntr2Pidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::Pcntr2Pidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr2Pidr14::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::Pcntr2Pidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::Pcntr2Pidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr2Pidr15::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::Pcntr2Pidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr00(&self) -> super::vals::Pcntr2Eidr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr2Eidr00::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr00(&mut self, val: super::vals::Pcntr2Eidr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr01(&self) -> super::vals::Pcntr2Eidr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr2Eidr01::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr01(&mut self, val: super::vals::Pcntr2Eidr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr02(&self) -> super::vals::Pcntr2Eidr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr2Eidr02::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr02(&mut self, val: super::vals::Pcntr2Eidr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr03(&self) -> super::vals::Pcntr2Eidr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr2Eidr03::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr03(&mut self, val: super::vals::Pcntr2Eidr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr04(&self) -> super::vals::Pcntr2Eidr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr2Eidr04::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr04(&mut self, val: super::vals::Pcntr2Eidr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr05(&self) -> super::vals::Pcntr2Eidr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr2Eidr05::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr05(&mut self, val: super::vals::Pcntr2Eidr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr06(&self) -> super::vals::Pcntr2Eidr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr2Eidr06::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr06(&mut self, val: super::vals::Pcntr2Eidr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr07(&self) -> super::vals::Pcntr2Eidr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr2Eidr07::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr07(&mut self, val: super::vals::Pcntr2Eidr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr08(&self) -> super::vals::Pcntr2Eidr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr2Eidr08::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr08(&mut self, val: super::vals::Pcntr2Eidr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr09(&self) -> super::vals::Pcntr2Eidr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr2Eidr09::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr09(&mut self, val: super::vals::Pcntr2Eidr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr10(&self) -> super::vals::Pcntr2Eidr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr2Eidr10::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr10(&mut self, val: super::vals::Pcntr2Eidr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr11(&self) -> super::vals::Pcntr2Eidr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr2Eidr11::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr11(&mut self, val: super::vals::Pcntr2Eidr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr12(&self) -> super::vals::Pcntr2Eidr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr2Eidr12::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr12(&mut self, val: super::vals::Pcntr2Eidr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr13(&self) -> super::vals::Pcntr2Eidr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr2Eidr13::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr13(&mut self, val: super::vals::Pcntr2Eidr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr14(&self) -> super::vals::Pcntr2Eidr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr2Eidr14::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr14(&mut self, val: super::vals::Pcntr2Eidr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub const fn eidr15(&self) -> super::vals::Pcntr2Eidr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr2Eidr15::from_bits(val as u8)
            }
            #[doc = "Port Event Input Data"]
            #[inline(always)]
            pub fn set_eidr15(&mut self, val: super::vals::Pcntr2Eidr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr2 {
            #[inline(always)]
            fn default() -> Pcntr2 {
                Pcntr2(0)
            }
        }
        impl core::fmt::Debug for Pcntr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr2")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr04", &self.pidr04())
                    .field("pidr05", &self.pidr05())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .field("eidr00", &self.eidr00())
                    .field("eidr01", &self.eidr01())
                    .field("eidr02", &self.eidr02())
                    .field("eidr03", &self.eidr03())
                    .field("eidr04", &self.eidr04())
                    .field("eidr05", &self.eidr05())
                    .field("eidr06", &self.eidr06())
                    .field("eidr07", &self.eidr07())
                    .field("eidr08", &self.eidr08())
                    .field("eidr09", &self.eidr09())
                    .field("eidr10", &self.eidr10())
                    .field("eidr11", &self.eidr11())
                    .field("eidr12", &self.eidr12())
                    .field("eidr13", &self.eidr13())
                    .field("eidr14", &self.eidr14())
                    .field("eidr15", &self.eidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr2 {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr04: {:?}, pidr05: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?}, eidr00: {:?}, eidr01: {:?}, eidr02: {:?}, eidr03: {:?}, eidr04: {:?}, eidr05: {:?}, eidr06: {:?}, eidr07: {:?}, eidr08: {:?}, eidr09: {:?}, eidr10: {:?}, eidr11: {:?}, eidr12: {:?}, eidr13: {:?}, eidr14: {:?}, eidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr04 () , self . pidr05 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 () , self . eidr00 () , self . eidr01 () , self . eidr02 () , self . eidr03 () , self . eidr04 () , self . eidr05 () , self . eidr06 () , self . eidr07 () , self . eidr08 () , self . eidr09 () , self . eidr10 () , self . eidr11 () , self . eidr12 () , self . eidr13 () , self . eidr14 () , self . eidr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr3(pub u32);
        impl Pcntr3 {
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::Pcntr3Posr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr3Posr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::Pcntr3Posr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::Pcntr3Posr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr3Posr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::Pcntr3Posr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::Pcntr3Posr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr3Posr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::Pcntr3Posr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::Pcntr3Posr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr3Posr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::Pcntr3Posr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr04(&self) -> super::vals::Pcntr3Posr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr3Posr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr04(&mut self, val: super::vals::Pcntr3Posr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr05(&self) -> super::vals::Pcntr3Posr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr3Posr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr05(&mut self, val: super::vals::Pcntr3Posr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::Pcntr3Posr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr3Posr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::Pcntr3Posr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::Pcntr3Posr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr3Posr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::Pcntr3Posr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::Pcntr3Posr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr3Posr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::Pcntr3Posr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::Pcntr3Posr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr3Posr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::Pcntr3Posr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::Pcntr3Posr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr3Posr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::Pcntr3Posr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::Pcntr3Posr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr3Posr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::Pcntr3Posr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::Pcntr3Posr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr3Posr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::Pcntr3Posr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::Pcntr3Posr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr3Posr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::Pcntr3Posr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::Pcntr3Posr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr3Posr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::Pcntr3Posr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::Pcntr3Posr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr3Posr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::Pcntr3Posr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::Pcntr3Porr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr3Porr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::Pcntr3Porr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::Pcntr3Porr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr3Porr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::Pcntr3Porr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::Pcntr3Porr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr3Porr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::Pcntr3Porr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::Pcntr3Porr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr3Porr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::Pcntr3Porr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr04(&self) -> super::vals::Pcntr3Porr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr3Porr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr04(&mut self, val: super::vals::Pcntr3Porr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr05(&self) -> super::vals::Pcntr3Porr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr3Porr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr05(&mut self, val: super::vals::Pcntr3Porr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::Pcntr3Porr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr3Porr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::Pcntr3Porr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::Pcntr3Porr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr3Porr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::Pcntr3Porr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::Pcntr3Porr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr3Porr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::Pcntr3Porr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::Pcntr3Porr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr3Porr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::Pcntr3Porr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::Pcntr3Porr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr3Porr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::Pcntr3Porr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::Pcntr3Porr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr3Porr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::Pcntr3Porr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::Pcntr3Porr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr3Porr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::Pcntr3Porr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::Pcntr3Porr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr3Porr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::Pcntr3Porr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::Pcntr3Porr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr3Porr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::Pcntr3Porr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::Pcntr3Porr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr3Porr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::Pcntr3Porr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr3 {
            #[inline(always)]
            fn default() -> Pcntr3 {
                Pcntr3(0)
            }
        }
        impl core::fmt::Debug for Pcntr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr3")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr04", &self.posr04())
                    .field("posr05", &self.posr05())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr04", &self.porr04())
                    .field("porr05", &self.porr05())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr3 {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr04: {:?}, posr05: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?}, porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr04: {:?}, porr05: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr04 () , self . posr05 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 () , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr04 () , self . porr05 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port Control Register 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcntr4(pub u32);
        impl Pcntr4 {
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr00(&self) -> super::vals::Pcntr4Eosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pcntr4Eosr00::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr00(&mut self, val: super::vals::Pcntr4Eosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr01(&self) -> super::vals::Pcntr4Eosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Pcntr4Eosr01::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr01(&mut self, val: super::vals::Pcntr4Eosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr02(&self) -> super::vals::Pcntr4Eosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Pcntr4Eosr02::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr02(&mut self, val: super::vals::Pcntr4Eosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr03(&self) -> super::vals::Pcntr4Eosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pcntr4Eosr03::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr03(&mut self, val: super::vals::Pcntr4Eosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr04(&self) -> super::vals::Pcntr4Eosr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Pcntr4Eosr04::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr04(&mut self, val: super::vals::Pcntr4Eosr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr05(&self) -> super::vals::Pcntr4Eosr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pcntr4Eosr05::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr05(&mut self, val: super::vals::Pcntr4Eosr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr06(&self) -> super::vals::Pcntr4Eosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Pcntr4Eosr06::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr06(&mut self, val: super::vals::Pcntr4Eosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr07(&self) -> super::vals::Pcntr4Eosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Pcntr4Eosr07::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr07(&mut self, val: super::vals::Pcntr4Eosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr08(&self) -> super::vals::Pcntr4Eosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Pcntr4Eosr08::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr08(&mut self, val: super::vals::Pcntr4Eosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr09(&self) -> super::vals::Pcntr4Eosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Pcntr4Eosr09::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr09(&mut self, val: super::vals::Pcntr4Eosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr10(&self) -> super::vals::Pcntr4Eosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcntr4Eosr10::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr10(&mut self, val: super::vals::Pcntr4Eosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr11(&self) -> super::vals::Pcntr4Eosr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Pcntr4Eosr11::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr11(&mut self, val: super::vals::Pcntr4Eosr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr12(&self) -> super::vals::Pcntr4Eosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Pcntr4Eosr12::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr12(&mut self, val: super::vals::Pcntr4Eosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr13(&self) -> super::vals::Pcntr4Eosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Pcntr4Eosr13::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr13(&mut self, val: super::vals::Pcntr4Eosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr14(&self) -> super::vals::Pcntr4Eosr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Pcntr4Eosr14::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr14(&mut self, val: super::vals::Pcntr4Eosr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub const fn eosr15(&self) -> super::vals::Pcntr4Eosr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Pcntr4Eosr15::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Set"]
            #[inline(always)]
            pub fn set_eosr15(&mut self, val: super::vals::Pcntr4Eosr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr00(&self) -> super::vals::Pcntr4Eorr00 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pcntr4Eorr00::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr00(&mut self, val: super::vals::Pcntr4Eorr00) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr01(&self) -> super::vals::Pcntr4Eorr01 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Pcntr4Eorr01::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr01(&mut self, val: super::vals::Pcntr4Eorr01) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr02(&self) -> super::vals::Pcntr4Eorr02 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Pcntr4Eorr02::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr02(&mut self, val: super::vals::Pcntr4Eorr02) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr03(&self) -> super::vals::Pcntr4Eorr03 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Pcntr4Eorr03::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr03(&mut self, val: super::vals::Pcntr4Eorr03) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr04(&self) -> super::vals::Pcntr4Eorr04 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Pcntr4Eorr04::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr04(&mut self, val: super::vals::Pcntr4Eorr04) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr05(&self) -> super::vals::Pcntr4Eorr05 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Pcntr4Eorr05::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr05(&mut self, val: super::vals::Pcntr4Eorr05) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr06(&self) -> super::vals::Pcntr4Eorr06 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Pcntr4Eorr06::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr06(&mut self, val: super::vals::Pcntr4Eorr06) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr07(&self) -> super::vals::Pcntr4Eorr07 {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Pcntr4Eorr07::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr07(&mut self, val: super::vals::Pcntr4Eorr07) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr08(&self) -> super::vals::Pcntr4Eorr08 {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Pcntr4Eorr08::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr08(&mut self, val: super::vals::Pcntr4Eorr08) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr09(&self) -> super::vals::Pcntr4Eorr09 {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Pcntr4Eorr09::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr09(&mut self, val: super::vals::Pcntr4Eorr09) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr10(&self) -> super::vals::Pcntr4Eorr10 {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Pcntr4Eorr10::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr10(&mut self, val: super::vals::Pcntr4Eorr10) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr11(&self) -> super::vals::Pcntr4Eorr11 {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Pcntr4Eorr11::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr11(&mut self, val: super::vals::Pcntr4Eorr11) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr12(&self) -> super::vals::Pcntr4Eorr12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Pcntr4Eorr12::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr12(&mut self, val: super::vals::Pcntr4Eorr12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr13(&self) -> super::vals::Pcntr4Eorr13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Pcntr4Eorr13::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr13(&mut self, val: super::vals::Pcntr4Eorr13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr14(&self) -> super::vals::Pcntr4Eorr14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Pcntr4Eorr14::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr14(&mut self, val: super::vals::Pcntr4Eorr14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub const fn eorr15(&self) -> super::vals::Pcntr4Eorr15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Pcntr4Eorr15::from_bits(val as u8)
            }
            #[doc = "Pmn Event Output Reset"]
            #[inline(always)]
            pub fn set_eorr15(&mut self, val: super::vals::Pcntr4Eorr15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Pcntr4 {
            #[inline(always)]
            fn default() -> Pcntr4 {
                Pcntr4(0)
            }
        }
        impl core::fmt::Debug for Pcntr4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcntr4")
                    .field("eosr00", &self.eosr00())
                    .field("eosr01", &self.eosr01())
                    .field("eosr02", &self.eosr02())
                    .field("eosr03", &self.eosr03())
                    .field("eosr04", &self.eosr04())
                    .field("eosr05", &self.eosr05())
                    .field("eosr06", &self.eosr06())
                    .field("eosr07", &self.eosr07())
                    .field("eosr08", &self.eosr08())
                    .field("eosr09", &self.eosr09())
                    .field("eosr10", &self.eosr10())
                    .field("eosr11", &self.eosr11())
                    .field("eosr12", &self.eosr12())
                    .field("eosr13", &self.eosr13())
                    .field("eosr14", &self.eosr14())
                    .field("eosr15", &self.eosr15())
                    .field("eorr00", &self.eorr00())
                    .field("eorr01", &self.eorr01())
                    .field("eorr02", &self.eorr02())
                    .field("eorr03", &self.eorr03())
                    .field("eorr04", &self.eorr04())
                    .field("eorr05", &self.eorr05())
                    .field("eorr06", &self.eorr06())
                    .field("eorr07", &self.eorr07())
                    .field("eorr08", &self.eorr08())
                    .field("eorr09", &self.eorr09())
                    .field("eorr10", &self.eorr10())
                    .field("eorr11", &self.eorr11())
                    .field("eorr12", &self.eorr12())
                    .field("eorr13", &self.eorr13())
                    .field("eorr14", &self.eorr14())
                    .field("eorr15", &self.eorr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcntr4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcntr4 {{ eosr00: {:?}, eosr01: {:?}, eosr02: {:?}, eosr03: {:?}, eosr04: {:?}, eosr05: {:?}, eosr06: {:?}, eosr07: {:?}, eosr08: {:?}, eosr09: {:?}, eosr10: {:?}, eosr11: {:?}, eosr12: {:?}, eosr13: {:?}, eosr14: {:?}, eosr15: {:?}, eorr00: {:?}, eorr01: {:?}, eorr02: {:?}, eorr03: {:?}, eorr04: {:?}, eorr05: {:?}, eorr06: {:?}, eorr07: {:?}, eorr08: {:?}, eorr09: {:?}, eorr10: {:?}, eorr11: {:?}, eorr12: {:?}, eorr13: {:?}, eorr14: {:?}, eorr15: {:?} }}" , self . eosr00 () , self . eosr01 () , self . eosr02 () , self . eosr03 () , self . eosr04 () , self . eosr05 () , self . eosr06 () , self . eosr07 () , self . eosr08 () , self . eosr09 () , self . eosr10 () , self . eosr11 () , self . eosr12 () , self . eosr13 () , self . eosr14 () , self . eosr15 () , self . eorr00 () , self . eorr01 () , self . eorr02 () , self . eorr03 () , self . eorr04 () , self . eorr05 () , self . eorr06 () , self . eorr07 () , self . eorr08 () , self . eorr09 () , self . eorr10 () , self . eorr11 () , self . eorr12 () , self . eorr13 () , self . eorr14 () , self . eorr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdr(pub u16);
        impl Pdr {
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr00(&self) -> super::vals::PdrPdr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PdrPdr00::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr00(&mut self, val: super::vals::PdrPdr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr01(&self) -> super::vals::PdrPdr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PdrPdr01::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr01(&mut self, val: super::vals::PdrPdr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr02(&self) -> super::vals::PdrPdr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PdrPdr02::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr02(&mut self, val: super::vals::PdrPdr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr03(&self) -> super::vals::PdrPdr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PdrPdr03::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr03(&mut self, val: super::vals::PdrPdr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr04(&self) -> super::vals::PdrPdr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PdrPdr04::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr04(&mut self, val: super::vals::PdrPdr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr05(&self) -> super::vals::PdrPdr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PdrPdr05::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr05(&mut self, val: super::vals::PdrPdr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr06(&self) -> super::vals::PdrPdr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PdrPdr06::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr06(&mut self, val: super::vals::PdrPdr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr07(&self) -> super::vals::PdrPdr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PdrPdr07::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr07(&mut self, val: super::vals::PdrPdr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr08(&self) -> super::vals::PdrPdr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PdrPdr08::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr08(&mut self, val: super::vals::PdrPdr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr09(&self) -> super::vals::PdrPdr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PdrPdr09::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr09(&mut self, val: super::vals::PdrPdr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr10(&self) -> super::vals::PdrPdr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PdrPdr10::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr10(&mut self, val: super::vals::PdrPdr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr11(&self) -> super::vals::PdrPdr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PdrPdr11::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr11(&mut self, val: super::vals::PdrPdr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr12(&self) -> super::vals::PdrPdr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PdrPdr12::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr12(&mut self, val: super::vals::PdrPdr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr13(&self) -> super::vals::PdrPdr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PdrPdr13::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr13(&mut self, val: super::vals::PdrPdr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr14(&self) -> super::vals::PdrPdr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PdrPdr14::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr14(&mut self, val: super::vals::PdrPdr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub const fn pdr15(&self) -> super::vals::PdrPdr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PdrPdr15::from_bits(val as u8)
            }
            #[doc = "Pmn Direction"]
            #[inline(always)]
            pub fn set_pdr15(&mut self, val: super::vals::PdrPdr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pdr {
            #[inline(always)]
            fn default() -> Pdr {
                Pdr(0)
            }
        }
        impl core::fmt::Debug for Pdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdr")
                    .field("pdr00", &self.pdr00())
                    .field("pdr01", &self.pdr01())
                    .field("pdr02", &self.pdr02())
                    .field("pdr03", &self.pdr03())
                    .field("pdr04", &self.pdr04())
                    .field("pdr05", &self.pdr05())
                    .field("pdr06", &self.pdr06())
                    .field("pdr07", &self.pdr07())
                    .field("pdr08", &self.pdr08())
                    .field("pdr09", &self.pdr09())
                    .field("pdr10", &self.pdr10())
                    .field("pdr11", &self.pdr11())
                    .field("pdr12", &self.pdr12())
                    .field("pdr13", &self.pdr13())
                    .field("pdr14", &self.pdr14())
                    .field("pdr15", &self.pdr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pdr {{ pdr00: {:?}, pdr01: {:?}, pdr02: {:?}, pdr03: {:?}, pdr04: {:?}, pdr05: {:?}, pdr06: {:?}, pdr07: {:?}, pdr08: {:?}, pdr09: {:?}, pdr10: {:?}, pdr11: {:?}, pdr12: {:?}, pdr13: {:?}, pdr14: {:?}, pdr15: {:?} }}" , self . pdr00 () , self . pdr01 () , self . pdr02 () , self . pdr03 () , self . pdr04 () , self . pdr05 () , self . pdr06 () , self . pdr07 () , self . pdr08 () , self . pdr09 () , self . pdr10 () , self . pdr11 () , self . pdr12 () , self . pdr13 () , self . pdr14 () , self . pdr15 ())
            }
        }
        #[doc = "Port Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pidr(pub u16);
        impl Pidr {
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr00(&self) -> super::vals::PidrPidr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PidrPidr00::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr00(&mut self, val: super::vals::PidrPidr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr01(&self) -> super::vals::PidrPidr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PidrPidr01::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr01(&mut self, val: super::vals::PidrPidr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr02(&self) -> super::vals::PidrPidr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PidrPidr02::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr02(&mut self, val: super::vals::PidrPidr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr03(&self) -> super::vals::PidrPidr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PidrPidr03::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr03(&mut self, val: super::vals::PidrPidr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr04(&self) -> super::vals::PidrPidr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PidrPidr04::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr04(&mut self, val: super::vals::PidrPidr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr05(&self) -> super::vals::PidrPidr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PidrPidr05::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr05(&mut self, val: super::vals::PidrPidr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr06(&self) -> super::vals::PidrPidr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PidrPidr06::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr06(&mut self, val: super::vals::PidrPidr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr07(&self) -> super::vals::PidrPidr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PidrPidr07::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr07(&mut self, val: super::vals::PidrPidr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr08(&self) -> super::vals::PidrPidr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PidrPidr08::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr08(&mut self, val: super::vals::PidrPidr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr09(&self) -> super::vals::PidrPidr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PidrPidr09::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr09(&mut self, val: super::vals::PidrPidr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr10(&self) -> super::vals::PidrPidr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PidrPidr10::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr10(&mut self, val: super::vals::PidrPidr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr11(&self) -> super::vals::PidrPidr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PidrPidr11::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr11(&mut self, val: super::vals::PidrPidr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr12(&self) -> super::vals::PidrPidr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PidrPidr12::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr12(&mut self, val: super::vals::PidrPidr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr13(&self) -> super::vals::PidrPidr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PidrPidr13::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr13(&mut self, val: super::vals::PidrPidr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr14(&self) -> super::vals::PidrPidr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PidrPidr14::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr14(&mut self, val: super::vals::PidrPidr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub const fn pidr15(&self) -> super::vals::PidrPidr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PidrPidr15::from_bits(val as u8)
            }
            #[doc = "Pmn State"]
            #[inline(always)]
            pub fn set_pidr15(&mut self, val: super::vals::PidrPidr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Pidr {
            #[inline(always)]
            fn default() -> Pidr {
                Pidr(0)
            }
        }
        impl core::fmt::Debug for Pidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pidr")
                    .field("pidr00", &self.pidr00())
                    .field("pidr01", &self.pidr01())
                    .field("pidr02", &self.pidr02())
                    .field("pidr03", &self.pidr03())
                    .field("pidr04", &self.pidr04())
                    .field("pidr05", &self.pidr05())
                    .field("pidr06", &self.pidr06())
                    .field("pidr07", &self.pidr07())
                    .field("pidr08", &self.pidr08())
                    .field("pidr09", &self.pidr09())
                    .field("pidr10", &self.pidr10())
                    .field("pidr11", &self.pidr11())
                    .field("pidr12", &self.pidr12())
                    .field("pidr13", &self.pidr13())
                    .field("pidr14", &self.pidr14())
                    .field("pidr15", &self.pidr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pidr {{ pidr00: {:?}, pidr01: {:?}, pidr02: {:?}, pidr03: {:?}, pidr04: {:?}, pidr05: {:?}, pidr06: {:?}, pidr07: {:?}, pidr08: {:?}, pidr09: {:?}, pidr10: {:?}, pidr11: {:?}, pidr12: {:?}, pidr13: {:?}, pidr14: {:?}, pidr15: {:?} }}" , self . pidr00 () , self . pidr01 () , self . pidr02 () , self . pidr03 () , self . pidr04 () , self . pidr05 () , self . pidr06 () , self . pidr07 () , self . pidr08 () , self . pidr09 () , self . pidr10 () , self . pidr11 () , self . pidr12 () , self . pidr13 () , self . pidr14 () , self . pidr15 ())
            }
        }
        #[doc = "Port Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Podr(pub u16);
        impl Podr {
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr00(&self) -> super::vals::PodrPodr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PodrPodr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr00(&mut self, val: super::vals::PodrPodr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr01(&self) -> super::vals::PodrPodr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PodrPodr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr01(&mut self, val: super::vals::PodrPodr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr02(&self) -> super::vals::PodrPodr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PodrPodr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr02(&mut self, val: super::vals::PodrPodr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr03(&self) -> super::vals::PodrPodr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PodrPodr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr03(&mut self, val: super::vals::PodrPodr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr04(&self) -> super::vals::PodrPodr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PodrPodr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr04(&mut self, val: super::vals::PodrPodr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr05(&self) -> super::vals::PodrPodr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PodrPodr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr05(&mut self, val: super::vals::PodrPodr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr06(&self) -> super::vals::PodrPodr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PodrPodr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr06(&mut self, val: super::vals::PodrPodr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr07(&self) -> super::vals::PodrPodr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PodrPodr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr07(&mut self, val: super::vals::PodrPodr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr08(&self) -> super::vals::PodrPodr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PodrPodr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr08(&mut self, val: super::vals::PodrPodr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr09(&self) -> super::vals::PodrPodr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PodrPodr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr09(&mut self, val: super::vals::PodrPodr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr10(&self) -> super::vals::PodrPodr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PodrPodr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr10(&mut self, val: super::vals::PodrPodr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr11(&self) -> super::vals::PodrPodr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PodrPodr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr11(&mut self, val: super::vals::PodrPodr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr12(&self) -> super::vals::PodrPodr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PodrPodr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr12(&mut self, val: super::vals::PodrPodr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr13(&self) -> super::vals::PodrPodr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PodrPodr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr13(&mut self, val: super::vals::PodrPodr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr14(&self) -> super::vals::PodrPodr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PodrPodr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr14(&mut self, val: super::vals::PodrPodr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub const fn podr15(&self) -> super::vals::PodrPodr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PodrPodr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Data"]
            #[inline(always)]
            pub fn set_podr15(&mut self, val: super::vals::PodrPodr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Podr {
            #[inline(always)]
            fn default() -> Podr {
                Podr(0)
            }
        }
        impl core::fmt::Debug for Podr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Podr")
                    .field("podr00", &self.podr00())
                    .field("podr01", &self.podr01())
                    .field("podr02", &self.podr02())
                    .field("podr03", &self.podr03())
                    .field("podr04", &self.podr04())
                    .field("podr05", &self.podr05())
                    .field("podr06", &self.podr06())
                    .field("podr07", &self.podr07())
                    .field("podr08", &self.podr08())
                    .field("podr09", &self.podr09())
                    .field("podr10", &self.podr10())
                    .field("podr11", &self.podr11())
                    .field("podr12", &self.podr12())
                    .field("podr13", &self.podr13())
                    .field("podr14", &self.podr14())
                    .field("podr15", &self.podr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Podr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Podr {{ podr00: {:?}, podr01: {:?}, podr02: {:?}, podr03: {:?}, podr04: {:?}, podr05: {:?}, podr06: {:?}, podr07: {:?}, podr08: {:?}, podr09: {:?}, podr10: {:?}, podr11: {:?}, podr12: {:?}, podr13: {:?}, podr14: {:?}, podr15: {:?} }}" , self . podr00 () , self . podr01 () , self . podr02 () , self . podr03 () , self . podr04 () , self . podr05 () , self . podr06 () , self . podr07 () , self . podr08 () , self . podr09 () , self . podr10 () , self . podr11 () , self . podr12 () , self . podr13 () , self . podr14 () , self . podr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Porr(pub u16);
        impl Porr {
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr00(&self) -> super::vals::PorrPorr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PorrPorr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr00(&mut self, val: super::vals::PorrPorr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr01(&self) -> super::vals::PorrPorr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PorrPorr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr01(&mut self, val: super::vals::PorrPorr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr02(&self) -> super::vals::PorrPorr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PorrPorr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr02(&mut self, val: super::vals::PorrPorr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr03(&self) -> super::vals::PorrPorr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PorrPorr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr03(&mut self, val: super::vals::PorrPorr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr04(&self) -> super::vals::PorrPorr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PorrPorr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr04(&mut self, val: super::vals::PorrPorr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr05(&self) -> super::vals::PorrPorr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PorrPorr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr05(&mut self, val: super::vals::PorrPorr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr06(&self) -> super::vals::PorrPorr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PorrPorr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr06(&mut self, val: super::vals::PorrPorr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr07(&self) -> super::vals::PorrPorr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PorrPorr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr07(&mut self, val: super::vals::PorrPorr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr08(&self) -> super::vals::PorrPorr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PorrPorr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr08(&mut self, val: super::vals::PorrPorr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr09(&self) -> super::vals::PorrPorr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PorrPorr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr09(&mut self, val: super::vals::PorrPorr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr10(&self) -> super::vals::PorrPorr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PorrPorr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr10(&mut self, val: super::vals::PorrPorr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr11(&self) -> super::vals::PorrPorr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PorrPorr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr11(&mut self, val: super::vals::PorrPorr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr12(&self) -> super::vals::PorrPorr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PorrPorr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr12(&mut self, val: super::vals::PorrPorr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr13(&self) -> super::vals::PorrPorr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PorrPorr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr13(&mut self, val: super::vals::PorrPorr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr14(&self) -> super::vals::PorrPorr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PorrPorr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr14(&mut self, val: super::vals::PorrPorr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub const fn porr15(&self) -> super::vals::PorrPorr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PorrPorr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Reset"]
            #[inline(always)]
            pub fn set_porr15(&mut self, val: super::vals::PorrPorr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Porr {
            #[inline(always)]
            fn default() -> Porr {
                Porr(0)
            }
        }
        impl core::fmt::Debug for Porr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Porr")
                    .field("porr00", &self.porr00())
                    .field("porr01", &self.porr01())
                    .field("porr02", &self.porr02())
                    .field("porr03", &self.porr03())
                    .field("porr04", &self.porr04())
                    .field("porr05", &self.porr05())
                    .field("porr06", &self.porr06())
                    .field("porr07", &self.porr07())
                    .field("porr08", &self.porr08())
                    .field("porr09", &self.porr09())
                    .field("porr10", &self.porr10())
                    .field("porr11", &self.porr11())
                    .field("porr12", &self.porr12())
                    .field("porr13", &self.porr13())
                    .field("porr14", &self.porr14())
                    .field("porr15", &self.porr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Porr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Porr {{ porr00: {:?}, porr01: {:?}, porr02: {:?}, porr03: {:?}, porr04: {:?}, porr05: {:?}, porr06: {:?}, porr07: {:?}, porr08: {:?}, porr09: {:?}, porr10: {:?}, porr11: {:?}, porr12: {:?}, porr13: {:?}, porr14: {:?}, porr15: {:?} }}" , self . porr00 () , self . porr01 () , self . porr02 () , self . porr03 () , self . porr04 () , self . porr05 () , self . porr06 () , self . porr07 () , self . porr08 () , self . porr09 () , self . porr10 () , self . porr11 () , self . porr12 () , self . porr13 () , self . porr14 () , self . porr15 ())
            }
        }
        #[doc = "Port Control Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Posr(pub u16);
        impl Posr {
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr00(&self) -> super::vals::PosrPosr00 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PosrPosr00::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr00(&mut self, val: super::vals::PosrPosr00) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr01(&self) -> super::vals::PosrPosr01 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PosrPosr01::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr01(&mut self, val: super::vals::PosrPosr01) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr02(&self) -> super::vals::PosrPosr02 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PosrPosr02::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr02(&mut self, val: super::vals::PosrPosr02) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr03(&self) -> super::vals::PosrPosr03 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PosrPosr03::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr03(&mut self, val: super::vals::PosrPosr03) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr04(&self) -> super::vals::PosrPosr04 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::PosrPosr04::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr04(&mut self, val: super::vals::PosrPosr04) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u16) & 0x01) << 4usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr05(&self) -> super::vals::PosrPosr05 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::PosrPosr05::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr05(&mut self, val: super::vals::PosrPosr05) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u16) & 0x01) << 5usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr06(&self) -> super::vals::PosrPosr06 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::PosrPosr06::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr06(&mut self, val: super::vals::PosrPosr06) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u16) & 0x01) << 6usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr07(&self) -> super::vals::PosrPosr07 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::PosrPosr07::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr07(&mut self, val: super::vals::PosrPosr07) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u16) & 0x01) << 7usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr08(&self) -> super::vals::PosrPosr08 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PosrPosr08::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr08(&mut self, val: super::vals::PosrPosr08) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr09(&self) -> super::vals::PosrPosr09 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PosrPosr09::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr09(&mut self, val: super::vals::PosrPosr09) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u16) & 0x01) << 9usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr10(&self) -> super::vals::PosrPosr10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::PosrPosr10::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr10(&mut self, val: super::vals::PosrPosr10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr11(&self) -> super::vals::PosrPosr11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::PosrPosr11::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr11(&mut self, val: super::vals::PosrPosr11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr12(&self) -> super::vals::PosrPosr12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::PosrPosr12::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr12(&mut self, val: super::vals::PosrPosr12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr13(&self) -> super::vals::PosrPosr13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::PosrPosr13::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr13(&mut self, val: super::vals::PosrPosr13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr14(&self) -> super::vals::PosrPosr14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::PosrPosr14::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr14(&mut self, val: super::vals::PosrPosr14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub const fn posr15(&self) -> super::vals::PosrPosr15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::PosrPosr15::from_bits(val as u8)
            }
            #[doc = "Pmn Output Set"]
            #[inline(always)]
            pub fn set_posr15(&mut self, val: super::vals::PosrPosr15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Posr {
            #[inline(always)]
            fn default() -> Posr {
                Posr(0)
            }
        }
        impl core::fmt::Debug for Posr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Posr")
                    .field("posr00", &self.posr00())
                    .field("posr01", &self.posr01())
                    .field("posr02", &self.posr02())
                    .field("posr03", &self.posr03())
                    .field("posr04", &self.posr04())
                    .field("posr05", &self.posr05())
                    .field("posr06", &self.posr06())
                    .field("posr07", &self.posr07())
                    .field("posr08", &self.posr08())
                    .field("posr09", &self.posr09())
                    .field("posr10", &self.posr10())
                    .field("posr11", &self.posr11())
                    .field("posr12", &self.posr12())
                    .field("posr13", &self.posr13())
                    .field("posr14", &self.posr14())
                    .field("posr15", &self.posr15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Posr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Posr {{ posr00: {:?}, posr01: {:?}, posr02: {:?}, posr03: {:?}, posr04: {:?}, posr05: {:?}, posr06: {:?}, posr07: {:?}, posr08: {:?}, posr09: {:?}, posr10: {:?}, posr11: {:?}, posr12: {:?}, posr13: {:?}, posr14: {:?}, posr15: {:?} }}" , self . posr00 () , self . posr01 () , self . posr02 () , self . posr03 () , self . posr04 () , self . posr05 () , self . posr06 () , self . posr07 () , self . posr08 () , self . posr09 () , self . posr10 () , self . posr11 () , self . posr12 () , self . posr13 () , self . posr14 () , self . posr15 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr00 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr00 {
                EidrEidr00::from_bits(val)
            }
        }
        impl From<EidrEidr00> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr00) -> u8 {
                EidrEidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr01 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr01 {
                EidrEidr01::from_bits(val)
            }
        }
        impl From<EidrEidr01> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr01) -> u8 {
                EidrEidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr02 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr02 {
                EidrEidr02::from_bits(val)
            }
        }
        impl From<EidrEidr02> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr02) -> u8 {
                EidrEidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr03 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr03 {
                EidrEidr03::from_bits(val)
            }
        }
        impl From<EidrEidr03> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr03) -> u8 {
                EidrEidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr04 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr04 {
                EidrEidr04::from_bits(val)
            }
        }
        impl From<EidrEidr04> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr04) -> u8 {
                EidrEidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr05 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr05 {
                EidrEidr05::from_bits(val)
            }
        }
        impl From<EidrEidr05> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr05) -> u8 {
                EidrEidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr06 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr06 {
                EidrEidr06::from_bits(val)
            }
        }
        impl From<EidrEidr06> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr06) -> u8 {
                EidrEidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr07 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr07 {
                EidrEidr07::from_bits(val)
            }
        }
        impl From<EidrEidr07> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr07) -> u8 {
                EidrEidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr08 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr08 {
                EidrEidr08::from_bits(val)
            }
        }
        impl From<EidrEidr08> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr08) -> u8 {
                EidrEidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr09 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr09 {
                EidrEidr09::from_bits(val)
            }
        }
        impl From<EidrEidr09> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr09) -> u8 {
                EidrEidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr10 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr10 {
                EidrEidr10::from_bits(val)
            }
        }
        impl From<EidrEidr10> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr10) -> u8 {
                EidrEidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr11 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr11 {
                EidrEidr11::from_bits(val)
            }
        }
        impl From<EidrEidr11> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr11) -> u8 {
                EidrEidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr12 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr12 {
                EidrEidr12::from_bits(val)
            }
        }
        impl From<EidrEidr12> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr12) -> u8 {
                EidrEidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr13 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr13 {
                EidrEidr13::from_bits(val)
            }
        }
        impl From<EidrEidr13> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr13) -> u8 {
                EidrEidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr14 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr14 {
                EidrEidr14::from_bits(val)
            }
        }
        impl From<EidrEidr14> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr14) -> u8 {
                EidrEidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EidrEidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EidrEidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EidrEidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EidrEidr15 {
            #[inline(always)]
            fn from(val: u8) -> EidrEidr15 {
                EidrEidr15::from_bits(val)
            }
        }
        impl From<EidrEidr15> for u8 {
            #[inline(always)]
            fn from(val: EidrEidr15) -> u8 {
                EidrEidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr00 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr00 {
                EorrEorr00::from_bits(val)
            }
        }
        impl From<EorrEorr00> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr00) -> u8 {
                EorrEorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr01 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr01 {
                EorrEorr01::from_bits(val)
            }
        }
        impl From<EorrEorr01> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr01) -> u8 {
                EorrEorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr02 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr02 {
                EorrEorr02::from_bits(val)
            }
        }
        impl From<EorrEorr02> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr02) -> u8 {
                EorrEorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr03 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr03 {
                EorrEorr03::from_bits(val)
            }
        }
        impl From<EorrEorr03> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr03) -> u8 {
                EorrEorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr04 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr04 {
                EorrEorr04::from_bits(val)
            }
        }
        impl From<EorrEorr04> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr04) -> u8 {
                EorrEorr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr05 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr05 {
                EorrEorr05::from_bits(val)
            }
        }
        impl From<EorrEorr05> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr05) -> u8 {
                EorrEorr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr06 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr06 {
                EorrEorr06::from_bits(val)
            }
        }
        impl From<EorrEorr06> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr06) -> u8 {
                EorrEorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr07 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr07 {
                EorrEorr07::from_bits(val)
            }
        }
        impl From<EorrEorr07> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr07) -> u8 {
                EorrEorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr08 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr08 {
                EorrEorr08::from_bits(val)
            }
        }
        impl From<EorrEorr08> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr08) -> u8 {
                EorrEorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr09 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr09 {
                EorrEorr09::from_bits(val)
            }
        }
        impl From<EorrEorr09> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr09) -> u8 {
                EorrEorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr10 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr10 {
                EorrEorr10::from_bits(val)
            }
        }
        impl From<EorrEorr10> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr10) -> u8 {
                EorrEorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr11 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr11 {
                EorrEorr11::from_bits(val)
            }
        }
        impl From<EorrEorr11> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr11) -> u8 {
                EorrEorr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr12 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr12 {
                EorrEorr12::from_bits(val)
            }
        }
        impl From<EorrEorr12> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr12) -> u8 {
                EorrEorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr13 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr13 {
                EorrEorr13::from_bits(val)
            }
        }
        impl From<EorrEorr13> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr13) -> u8 {
                EorrEorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr14 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr14 {
                EorrEorr14::from_bits(val)
            }
        }
        impl From<EorrEorr14> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr14) -> u8 {
                EorrEorr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EorrEorr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EorrEorr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EorrEorr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EorrEorr15 {
            #[inline(always)]
            fn from(val: u8) -> EorrEorr15 {
                EorrEorr15::from_bits(val)
            }
        }
        impl From<EorrEorr15> for u8 {
            #[inline(always)]
            fn from(val: EorrEorr15) -> u8 {
                EorrEorr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr00 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr00 {
                EosrEosr00::from_bits(val)
            }
        }
        impl From<EosrEosr00> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr00) -> u8 {
                EosrEosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr01 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr01 {
                EosrEosr01::from_bits(val)
            }
        }
        impl From<EosrEosr01> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr01) -> u8 {
                EosrEosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr02 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr02 {
                EosrEosr02::from_bits(val)
            }
        }
        impl From<EosrEosr02> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr02) -> u8 {
                EosrEosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr03 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr03 {
                EosrEosr03::from_bits(val)
            }
        }
        impl From<EosrEosr03> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr03) -> u8 {
                EosrEosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr04 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr04 {
                EosrEosr04::from_bits(val)
            }
        }
        impl From<EosrEosr04> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr04) -> u8 {
                EosrEosr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr05 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr05 {
                EosrEosr05::from_bits(val)
            }
        }
        impl From<EosrEosr05> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr05) -> u8 {
                EosrEosr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr06 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr06 {
                EosrEosr06::from_bits(val)
            }
        }
        impl From<EosrEosr06> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr06) -> u8 {
                EosrEosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr07 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr07 {
                EosrEosr07::from_bits(val)
            }
        }
        impl From<EosrEosr07> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr07) -> u8 {
                EosrEosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr08 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr08 {
                EosrEosr08::from_bits(val)
            }
        }
        impl From<EosrEosr08> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr08) -> u8 {
                EosrEosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr09 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr09 {
                EosrEosr09::from_bits(val)
            }
        }
        impl From<EosrEosr09> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr09) -> u8 {
                EosrEosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr10 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr10 {
                EosrEosr10::from_bits(val)
            }
        }
        impl From<EosrEosr10> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr10) -> u8 {
                EosrEosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr11 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr11 {
                EosrEosr11::from_bits(val)
            }
        }
        impl From<EosrEosr11> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr11) -> u8 {
                EosrEosr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr12 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr12 {
                EosrEosr12::from_bits(val)
            }
        }
        impl From<EosrEosr12> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr12) -> u8 {
                EosrEosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr13 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr13 {
                EosrEosr13::from_bits(val)
            }
        }
        impl From<EosrEosr13> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr13) -> u8 {
                EosrEosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr14 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr14 {
                EosrEosr14::from_bits(val)
            }
        }
        impl From<EosrEosr14> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr14) -> u8 {
                EosrEosr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EosrEosr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl EosrEosr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EosrEosr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EosrEosr15 {
            #[inline(always)]
            fn from(val: u8) -> EosrEosr15 {
                EosrEosr15::from_bits(val)
            }
        }
        impl From<EosrEosr15> for u8 {
            #[inline(always)]
            fn from(val: EosrEosr15) -> u8 {
                EosrEosr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr00 {
                Pcntr1Pdr00::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr00) -> u8 {
                Pcntr1Pdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr01 {
                Pcntr1Pdr01::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr01) -> u8 {
                Pcntr1Pdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr02 {
                Pcntr1Pdr02::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr02) -> u8 {
                Pcntr1Pdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr03 {
                Pcntr1Pdr03::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr03) -> u8 {
                Pcntr1Pdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr04 {
                Pcntr1Pdr04::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr04) -> u8 {
                Pcntr1Pdr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr05 {
                Pcntr1Pdr05::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr05) -> u8 {
                Pcntr1Pdr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr06 {
                Pcntr1Pdr06::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr06) -> u8 {
                Pcntr1Pdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr07 {
                Pcntr1Pdr07::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr07) -> u8 {
                Pcntr1Pdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr08 {
                Pcntr1Pdr08::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr08) -> u8 {
                Pcntr1Pdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr09 {
                Pcntr1Pdr09::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr09) -> u8 {
                Pcntr1Pdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr10 {
                Pcntr1Pdr10::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr10) -> u8 {
                Pcntr1Pdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr11 {
                Pcntr1Pdr11::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr11) -> u8 {
                Pcntr1Pdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr12 {
                Pcntr1Pdr12::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr12) -> u8 {
                Pcntr1Pdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr13 {
                Pcntr1Pdr13::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr13) -> u8 {
                Pcntr1Pdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr14 {
                Pcntr1Pdr14::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr14) -> u8 {
                Pcntr1Pdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Pdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Pdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Pdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Pdr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Pdr15 {
                Pcntr1Pdr15::from_bits(val)
            }
        }
        impl From<Pcntr1Pdr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Pdr15) -> u8 {
                Pcntr1Pdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr00 {
                Pcntr1Podr00::from_bits(val)
            }
        }
        impl From<Pcntr1Podr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr00) -> u8 {
                Pcntr1Podr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr01 {
                Pcntr1Podr01::from_bits(val)
            }
        }
        impl From<Pcntr1Podr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr01) -> u8 {
                Pcntr1Podr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr02 {
                Pcntr1Podr02::from_bits(val)
            }
        }
        impl From<Pcntr1Podr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr02) -> u8 {
                Pcntr1Podr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr03 {
                Pcntr1Podr03::from_bits(val)
            }
        }
        impl From<Pcntr1Podr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr03) -> u8 {
                Pcntr1Podr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr04 {
                Pcntr1Podr04::from_bits(val)
            }
        }
        impl From<Pcntr1Podr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr04) -> u8 {
                Pcntr1Podr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr05 {
                Pcntr1Podr05::from_bits(val)
            }
        }
        impl From<Pcntr1Podr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr05) -> u8 {
                Pcntr1Podr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr06 {
                Pcntr1Podr06::from_bits(val)
            }
        }
        impl From<Pcntr1Podr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr06) -> u8 {
                Pcntr1Podr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr07 {
                Pcntr1Podr07::from_bits(val)
            }
        }
        impl From<Pcntr1Podr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr07) -> u8 {
                Pcntr1Podr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr08 {
                Pcntr1Podr08::from_bits(val)
            }
        }
        impl From<Pcntr1Podr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr08) -> u8 {
                Pcntr1Podr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr09 {
                Pcntr1Podr09::from_bits(val)
            }
        }
        impl From<Pcntr1Podr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr09) -> u8 {
                Pcntr1Podr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr10 {
                Pcntr1Podr10::from_bits(val)
            }
        }
        impl From<Pcntr1Podr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr10) -> u8 {
                Pcntr1Podr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr11 {
                Pcntr1Podr11::from_bits(val)
            }
        }
        impl From<Pcntr1Podr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr11) -> u8 {
                Pcntr1Podr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr12 {
                Pcntr1Podr12::from_bits(val)
            }
        }
        impl From<Pcntr1Podr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr12) -> u8 {
                Pcntr1Podr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr13 {
                Pcntr1Podr13::from_bits(val)
            }
        }
        impl From<Pcntr1Podr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr13) -> u8 {
                Pcntr1Podr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr14 {
                Pcntr1Podr14::from_bits(val)
            }
        }
        impl From<Pcntr1Podr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr14) -> u8 {
                Pcntr1Podr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr1Podr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr1Podr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr1Podr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr1Podr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr1Podr15 {
                Pcntr1Podr15::from_bits(val)
            }
        }
        impl From<Pcntr1Podr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr1Podr15) -> u8 {
                Pcntr1Podr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr00 {
                Pcntr2Eidr00::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr00) -> u8 {
                Pcntr2Eidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr01 {
                Pcntr2Eidr01::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr01) -> u8 {
                Pcntr2Eidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr02 {
                Pcntr2Eidr02::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr02) -> u8 {
                Pcntr2Eidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr03 {
                Pcntr2Eidr03::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr03) -> u8 {
                Pcntr2Eidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr04 {
                Pcntr2Eidr04::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr04) -> u8 {
                Pcntr2Eidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr05 {
                Pcntr2Eidr05::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr05) -> u8 {
                Pcntr2Eidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr06 {
                Pcntr2Eidr06::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr06) -> u8 {
                Pcntr2Eidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr07 {
                Pcntr2Eidr07::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr07) -> u8 {
                Pcntr2Eidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr08 {
                Pcntr2Eidr08::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr08) -> u8 {
                Pcntr2Eidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr09 {
                Pcntr2Eidr09::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr09) -> u8 {
                Pcntr2Eidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr10 {
                Pcntr2Eidr10::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr10) -> u8 {
                Pcntr2Eidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr11 {
                Pcntr2Eidr11::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr11) -> u8 {
                Pcntr2Eidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr12 {
                Pcntr2Eidr12::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr12) -> u8 {
                Pcntr2Eidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr13 {
                Pcntr2Eidr13::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr13) -> u8 {
                Pcntr2Eidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr14 {
                Pcntr2Eidr14::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr14) -> u8 {
                Pcntr2Eidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Eidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Eidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Eidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Eidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Eidr15 {
                Pcntr2Eidr15::from_bits(val)
            }
        }
        impl From<Pcntr2Eidr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Eidr15) -> u8 {
                Pcntr2Eidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr00 {
                Pcntr2Pidr00::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr00) -> u8 {
                Pcntr2Pidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr01 {
                Pcntr2Pidr01::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr01) -> u8 {
                Pcntr2Pidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr02 {
                Pcntr2Pidr02::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr02) -> u8 {
                Pcntr2Pidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr03 {
                Pcntr2Pidr03::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr03) -> u8 {
                Pcntr2Pidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr04 {
                Pcntr2Pidr04::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr04) -> u8 {
                Pcntr2Pidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr05 {
                Pcntr2Pidr05::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr05) -> u8 {
                Pcntr2Pidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr06 {
                Pcntr2Pidr06::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr06) -> u8 {
                Pcntr2Pidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr07 {
                Pcntr2Pidr07::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr07) -> u8 {
                Pcntr2Pidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr08 {
                Pcntr2Pidr08::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr08) -> u8 {
                Pcntr2Pidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr09 {
                Pcntr2Pidr09::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr09) -> u8 {
                Pcntr2Pidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr10 {
                Pcntr2Pidr10::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr10) -> u8 {
                Pcntr2Pidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr11 {
                Pcntr2Pidr11::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr11) -> u8 {
                Pcntr2Pidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr12 {
                Pcntr2Pidr12::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr12) -> u8 {
                Pcntr2Pidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr13 {
                Pcntr2Pidr13::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr13) -> u8 {
                Pcntr2Pidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr14 {
                Pcntr2Pidr14::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr14) -> u8 {
                Pcntr2Pidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr2Pidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr2Pidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr2Pidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr2Pidr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr2Pidr15 {
                Pcntr2Pidr15::from_bits(val)
            }
        }
        impl From<Pcntr2Pidr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr2Pidr15) -> u8 {
                Pcntr2Pidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr00 {
                Pcntr3Porr00::from_bits(val)
            }
        }
        impl From<Pcntr3Porr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr00) -> u8 {
                Pcntr3Porr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr01 {
                Pcntr3Porr01::from_bits(val)
            }
        }
        impl From<Pcntr3Porr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr01) -> u8 {
                Pcntr3Porr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr02 {
                Pcntr3Porr02::from_bits(val)
            }
        }
        impl From<Pcntr3Porr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr02) -> u8 {
                Pcntr3Porr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr03 {
                Pcntr3Porr03::from_bits(val)
            }
        }
        impl From<Pcntr3Porr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr03) -> u8 {
                Pcntr3Porr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr04 {
                Pcntr3Porr04::from_bits(val)
            }
        }
        impl From<Pcntr3Porr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr04) -> u8 {
                Pcntr3Porr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr05 {
                Pcntr3Porr05::from_bits(val)
            }
        }
        impl From<Pcntr3Porr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr05) -> u8 {
                Pcntr3Porr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr06 {
                Pcntr3Porr06::from_bits(val)
            }
        }
        impl From<Pcntr3Porr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr06) -> u8 {
                Pcntr3Porr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr07 {
                Pcntr3Porr07::from_bits(val)
            }
        }
        impl From<Pcntr3Porr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr07) -> u8 {
                Pcntr3Porr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr08 {
                Pcntr3Porr08::from_bits(val)
            }
        }
        impl From<Pcntr3Porr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr08) -> u8 {
                Pcntr3Porr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr09 {
                Pcntr3Porr09::from_bits(val)
            }
        }
        impl From<Pcntr3Porr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr09) -> u8 {
                Pcntr3Porr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr10 {
                Pcntr3Porr10::from_bits(val)
            }
        }
        impl From<Pcntr3Porr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr10) -> u8 {
                Pcntr3Porr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr11 {
                Pcntr3Porr11::from_bits(val)
            }
        }
        impl From<Pcntr3Porr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr11) -> u8 {
                Pcntr3Porr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr12 {
                Pcntr3Porr12::from_bits(val)
            }
        }
        impl From<Pcntr3Porr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr12) -> u8 {
                Pcntr3Porr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr13 {
                Pcntr3Porr13::from_bits(val)
            }
        }
        impl From<Pcntr3Porr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr13) -> u8 {
                Pcntr3Porr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr14 {
                Pcntr3Porr14::from_bits(val)
            }
        }
        impl From<Pcntr3Porr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr14) -> u8 {
                Pcntr3Porr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Porr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Porr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Porr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Porr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Porr15 {
                Pcntr3Porr15::from_bits(val)
            }
        }
        impl From<Pcntr3Porr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Porr15) -> u8 {
                Pcntr3Porr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr00 {
                Pcntr3Posr00::from_bits(val)
            }
        }
        impl From<Pcntr3Posr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr00) -> u8 {
                Pcntr3Posr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr01 {
                Pcntr3Posr01::from_bits(val)
            }
        }
        impl From<Pcntr3Posr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr01) -> u8 {
                Pcntr3Posr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr02 {
                Pcntr3Posr02::from_bits(val)
            }
        }
        impl From<Pcntr3Posr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr02) -> u8 {
                Pcntr3Posr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr03 {
                Pcntr3Posr03::from_bits(val)
            }
        }
        impl From<Pcntr3Posr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr03) -> u8 {
                Pcntr3Posr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr04 {
                Pcntr3Posr04::from_bits(val)
            }
        }
        impl From<Pcntr3Posr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr04) -> u8 {
                Pcntr3Posr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr05 {
                Pcntr3Posr05::from_bits(val)
            }
        }
        impl From<Pcntr3Posr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr05) -> u8 {
                Pcntr3Posr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr06 {
                Pcntr3Posr06::from_bits(val)
            }
        }
        impl From<Pcntr3Posr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr06) -> u8 {
                Pcntr3Posr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr07 {
                Pcntr3Posr07::from_bits(val)
            }
        }
        impl From<Pcntr3Posr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr07) -> u8 {
                Pcntr3Posr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr08 {
                Pcntr3Posr08::from_bits(val)
            }
        }
        impl From<Pcntr3Posr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr08) -> u8 {
                Pcntr3Posr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr09 {
                Pcntr3Posr09::from_bits(val)
            }
        }
        impl From<Pcntr3Posr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr09) -> u8 {
                Pcntr3Posr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr10 {
                Pcntr3Posr10::from_bits(val)
            }
        }
        impl From<Pcntr3Posr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr10) -> u8 {
                Pcntr3Posr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr11 {
                Pcntr3Posr11::from_bits(val)
            }
        }
        impl From<Pcntr3Posr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr11) -> u8 {
                Pcntr3Posr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr12 {
                Pcntr3Posr12::from_bits(val)
            }
        }
        impl From<Pcntr3Posr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr12) -> u8 {
                Pcntr3Posr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr13 {
                Pcntr3Posr13::from_bits(val)
            }
        }
        impl From<Pcntr3Posr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr13) -> u8 {
                Pcntr3Posr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr14 {
                Pcntr3Posr14::from_bits(val)
            }
        }
        impl From<Pcntr3Posr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr14) -> u8 {
                Pcntr3Posr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr3Posr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr3Posr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr3Posr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr3Posr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr3Posr15 {
                Pcntr3Posr15::from_bits(val)
            }
        }
        impl From<Pcntr3Posr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr3Posr15) -> u8 {
                Pcntr3Posr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr00 {
                Pcntr4Eorr00::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr00) -> u8 {
                Pcntr4Eorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr01 {
                Pcntr4Eorr01::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr01) -> u8 {
                Pcntr4Eorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr02 {
                Pcntr4Eorr02::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr02) -> u8 {
                Pcntr4Eorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr03 {
                Pcntr4Eorr03::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr03) -> u8 {
                Pcntr4Eorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr04 {
                Pcntr4Eorr04::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr04) -> u8 {
                Pcntr4Eorr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr05 {
                Pcntr4Eorr05::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr05) -> u8 {
                Pcntr4Eorr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr06 {
                Pcntr4Eorr06::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr06) -> u8 {
                Pcntr4Eorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr07 {
                Pcntr4Eorr07::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr07) -> u8 {
                Pcntr4Eorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr08 {
                Pcntr4Eorr08::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr08) -> u8 {
                Pcntr4Eorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr09 {
                Pcntr4Eorr09::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr09) -> u8 {
                Pcntr4Eorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr10 {
                Pcntr4Eorr10::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr10) -> u8 {
                Pcntr4Eorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr11 {
                Pcntr4Eorr11::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr11) -> u8 {
                Pcntr4Eorr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr12 {
                Pcntr4Eorr12::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr12) -> u8 {
                Pcntr4Eorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr13 {
                Pcntr4Eorr13::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr13) -> u8 {
                Pcntr4Eorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr14 {
                Pcntr4Eorr14::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr14) -> u8 {
                Pcntr4Eorr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eorr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eorr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eorr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eorr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eorr15 {
                Pcntr4Eorr15::from_bits(val)
            }
        }
        impl From<Pcntr4Eorr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eorr15) -> u8 {
                Pcntr4Eorr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr00 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr00 {
                Pcntr4Eosr00::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr00> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr00) -> u8 {
                Pcntr4Eosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr01 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr01 {
                Pcntr4Eosr01::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr01> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr01) -> u8 {
                Pcntr4Eosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr02 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr02 {
                Pcntr4Eosr02::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr02> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr02) -> u8 {
                Pcntr4Eosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr03 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr03 {
                Pcntr4Eosr03::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr03> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr03) -> u8 {
                Pcntr4Eosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr04 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr04 {
                Pcntr4Eosr04::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr04> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr04) -> u8 {
                Pcntr4Eosr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr05 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr05 {
                Pcntr4Eosr05::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr05> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr05) -> u8 {
                Pcntr4Eosr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr06 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr06 {
                Pcntr4Eosr06::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr06> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr06) -> u8 {
                Pcntr4Eosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr07 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr07 {
                Pcntr4Eosr07::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr07> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr07) -> u8 {
                Pcntr4Eosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr08 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr08 {
                Pcntr4Eosr08::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr08> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr08) -> u8 {
                Pcntr4Eosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr09 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr09 {
                Pcntr4Eosr09::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr09> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr09) -> u8 {
                Pcntr4Eosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr10 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr10 {
                Pcntr4Eosr10::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr10> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr10) -> u8 {
                Pcntr4Eosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr11 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr11 {
                Pcntr4Eosr11::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr11> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr11) -> u8 {
                Pcntr4Eosr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr12 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr12 {
                Pcntr4Eosr12::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr12> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr12) -> u8 {
                Pcntr4Eosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr13 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr13 {
                Pcntr4Eosr13::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr13> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr13) -> u8 {
                Pcntr4Eosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr14 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr14 {
                Pcntr4Eosr14::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr14> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr14) -> u8 {
                Pcntr4Eosr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcntr4Eosr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pcntr4Eosr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcntr4Eosr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcntr4Eosr15 {
            #[inline(always)]
            fn from(val: u8) -> Pcntr4Eosr15 {
                Pcntr4Eosr15::from_bits(val)
            }
        }
        impl From<Pcntr4Eosr15> for u8 {
            #[inline(always)]
            fn from(val: Pcntr4Eosr15) -> u8 {
                Pcntr4Eosr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr00 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr00 {
                PdrPdr00::from_bits(val)
            }
        }
        impl From<PdrPdr00> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr00) -> u8 {
                PdrPdr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr01 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr01 {
                PdrPdr01::from_bits(val)
            }
        }
        impl From<PdrPdr01> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr01) -> u8 {
                PdrPdr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr02 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr02 {
                PdrPdr02::from_bits(val)
            }
        }
        impl From<PdrPdr02> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr02) -> u8 {
                PdrPdr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr03 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr03 {
                PdrPdr03::from_bits(val)
            }
        }
        impl From<PdrPdr03> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr03) -> u8 {
                PdrPdr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr04 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr04 {
                PdrPdr04::from_bits(val)
            }
        }
        impl From<PdrPdr04> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr04) -> u8 {
                PdrPdr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr05 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr05 {
                PdrPdr05::from_bits(val)
            }
        }
        impl From<PdrPdr05> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr05) -> u8 {
                PdrPdr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr06 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr06 {
                PdrPdr06::from_bits(val)
            }
        }
        impl From<PdrPdr06> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr06) -> u8 {
                PdrPdr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr07 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr07 {
                PdrPdr07::from_bits(val)
            }
        }
        impl From<PdrPdr07> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr07) -> u8 {
                PdrPdr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr08 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr08 {
                PdrPdr08::from_bits(val)
            }
        }
        impl From<PdrPdr08> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr08) -> u8 {
                PdrPdr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr09 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr09 {
                PdrPdr09::from_bits(val)
            }
        }
        impl From<PdrPdr09> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr09) -> u8 {
                PdrPdr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr10 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr10 {
                PdrPdr10::from_bits(val)
            }
        }
        impl From<PdrPdr10> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr10) -> u8 {
                PdrPdr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr11 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr11 {
                PdrPdr11::from_bits(val)
            }
        }
        impl From<PdrPdr11> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr11) -> u8 {
                PdrPdr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr12 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr12 {
                PdrPdr12::from_bits(val)
            }
        }
        impl From<PdrPdr12> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr12) -> u8 {
                PdrPdr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr13 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr13 {
                PdrPdr13::from_bits(val)
            }
        }
        impl From<PdrPdr13> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr13) -> u8 {
                PdrPdr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr14 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr14 {
                PdrPdr14::from_bits(val)
            }
        }
        impl From<PdrPdr14> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr14) -> u8 {
                PdrPdr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PdrPdr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PdrPdr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PdrPdr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PdrPdr15 {
            #[inline(always)]
            fn from(val: u8) -> PdrPdr15 {
                PdrPdr15::from_bits(val)
            }
        }
        impl From<PdrPdr15> for u8 {
            #[inline(always)]
            fn from(val: PdrPdr15) -> u8 {
                PdrPdr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr00 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr00 {
                PidrPidr00::from_bits(val)
            }
        }
        impl From<PidrPidr00> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr00) -> u8 {
                PidrPidr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr01 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr01 {
                PidrPidr01::from_bits(val)
            }
        }
        impl From<PidrPidr01> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr01) -> u8 {
                PidrPidr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr02 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr02 {
                PidrPidr02::from_bits(val)
            }
        }
        impl From<PidrPidr02> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr02) -> u8 {
                PidrPidr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr03 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr03 {
                PidrPidr03::from_bits(val)
            }
        }
        impl From<PidrPidr03> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr03) -> u8 {
                PidrPidr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr04 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr04 {
                PidrPidr04::from_bits(val)
            }
        }
        impl From<PidrPidr04> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr04) -> u8 {
                PidrPidr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr05 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr05 {
                PidrPidr05::from_bits(val)
            }
        }
        impl From<PidrPidr05> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr05) -> u8 {
                PidrPidr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr06 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr06 {
                PidrPidr06::from_bits(val)
            }
        }
        impl From<PidrPidr06> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr06) -> u8 {
                PidrPidr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr07 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr07 {
                PidrPidr07::from_bits(val)
            }
        }
        impl From<PidrPidr07> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr07) -> u8 {
                PidrPidr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr08 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr08 {
                PidrPidr08::from_bits(val)
            }
        }
        impl From<PidrPidr08> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr08) -> u8 {
                PidrPidr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr09 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr09 {
                PidrPidr09::from_bits(val)
            }
        }
        impl From<PidrPidr09> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr09) -> u8 {
                PidrPidr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr10 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr10 {
                PidrPidr10::from_bits(val)
            }
        }
        impl From<PidrPidr10> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr10) -> u8 {
                PidrPidr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr11 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr11 {
                PidrPidr11::from_bits(val)
            }
        }
        impl From<PidrPidr11> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr11) -> u8 {
                PidrPidr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr12 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr12 {
                PidrPidr12::from_bits(val)
            }
        }
        impl From<PidrPidr12> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr12) -> u8 {
                PidrPidr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr13 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr13 {
                PidrPidr13::from_bits(val)
            }
        }
        impl From<PidrPidr13> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr13) -> u8 {
                PidrPidr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr14 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr14 {
                PidrPidr14::from_bits(val)
            }
        }
        impl From<PidrPidr14> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr14) -> u8 {
                PidrPidr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PidrPidr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PidrPidr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PidrPidr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PidrPidr15 {
            #[inline(always)]
            fn from(val: u8) -> PidrPidr15 {
                PidrPidr15::from_bits(val)
            }
        }
        impl From<PidrPidr15> for u8 {
            #[inline(always)]
            fn from(val: PidrPidr15) -> u8 {
                PidrPidr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr00 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr00 {
                PodrPodr00::from_bits(val)
            }
        }
        impl From<PodrPodr00> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr00) -> u8 {
                PodrPodr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr01 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr01 {
                PodrPodr01::from_bits(val)
            }
        }
        impl From<PodrPodr01> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr01) -> u8 {
                PodrPodr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr02 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr02 {
                PodrPodr02::from_bits(val)
            }
        }
        impl From<PodrPodr02> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr02) -> u8 {
                PodrPodr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr03 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr03 {
                PodrPodr03::from_bits(val)
            }
        }
        impl From<PodrPodr03> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr03) -> u8 {
                PodrPodr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr04 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr04 {
                PodrPodr04::from_bits(val)
            }
        }
        impl From<PodrPodr04> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr04) -> u8 {
                PodrPodr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr05 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr05 {
                PodrPodr05::from_bits(val)
            }
        }
        impl From<PodrPodr05> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr05) -> u8 {
                PodrPodr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr06 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr06 {
                PodrPodr06::from_bits(val)
            }
        }
        impl From<PodrPodr06> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr06) -> u8 {
                PodrPodr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr07 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr07 {
                PodrPodr07::from_bits(val)
            }
        }
        impl From<PodrPodr07> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr07) -> u8 {
                PodrPodr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr08 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr08 {
                PodrPodr08::from_bits(val)
            }
        }
        impl From<PodrPodr08> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr08) -> u8 {
                PodrPodr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr09 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr09 {
                PodrPodr09::from_bits(val)
            }
        }
        impl From<PodrPodr09> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr09) -> u8 {
                PodrPodr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr10 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr10 {
                PodrPodr10::from_bits(val)
            }
        }
        impl From<PodrPodr10> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr10) -> u8 {
                PodrPodr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr11 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr11 {
                PodrPodr11::from_bits(val)
            }
        }
        impl From<PodrPodr11> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr11) -> u8 {
                PodrPodr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr12 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr12 {
                PodrPodr12::from_bits(val)
            }
        }
        impl From<PodrPodr12> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr12) -> u8 {
                PodrPodr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr13 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr13 {
                PodrPodr13::from_bits(val)
            }
        }
        impl From<PodrPodr13> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr13) -> u8 {
                PodrPodr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr14 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr14 {
                PodrPodr14::from_bits(val)
            }
        }
        impl From<PodrPodr14> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr14) -> u8 {
                PodrPodr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PodrPodr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PodrPodr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PodrPodr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PodrPodr15 {
            #[inline(always)]
            fn from(val: u8) -> PodrPodr15 {
                PodrPodr15::from_bits(val)
            }
        }
        impl From<PodrPodr15> for u8 {
            #[inline(always)]
            fn from(val: PodrPodr15) -> u8 {
                PodrPodr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr00 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr00 {
                PorrPorr00::from_bits(val)
            }
        }
        impl From<PorrPorr00> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr00) -> u8 {
                PorrPorr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr01 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr01 {
                PorrPorr01::from_bits(val)
            }
        }
        impl From<PorrPorr01> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr01) -> u8 {
                PorrPorr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr02 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr02 {
                PorrPorr02::from_bits(val)
            }
        }
        impl From<PorrPorr02> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr02) -> u8 {
                PorrPorr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr03 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr03 {
                PorrPorr03::from_bits(val)
            }
        }
        impl From<PorrPorr03> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr03) -> u8 {
                PorrPorr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr04 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr04 {
                PorrPorr04::from_bits(val)
            }
        }
        impl From<PorrPorr04> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr04) -> u8 {
                PorrPorr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr05 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr05 {
                PorrPorr05::from_bits(val)
            }
        }
        impl From<PorrPorr05> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr05) -> u8 {
                PorrPorr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr06 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr06 {
                PorrPorr06::from_bits(val)
            }
        }
        impl From<PorrPorr06> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr06) -> u8 {
                PorrPorr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr07 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr07 {
                PorrPorr07::from_bits(val)
            }
        }
        impl From<PorrPorr07> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr07) -> u8 {
                PorrPorr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr08 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr08 {
                PorrPorr08::from_bits(val)
            }
        }
        impl From<PorrPorr08> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr08) -> u8 {
                PorrPorr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr09 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr09 {
                PorrPorr09::from_bits(val)
            }
        }
        impl From<PorrPorr09> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr09) -> u8 {
                PorrPorr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr10 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr10 {
                PorrPorr10::from_bits(val)
            }
        }
        impl From<PorrPorr10> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr10) -> u8 {
                PorrPorr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr11 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr11 {
                PorrPorr11::from_bits(val)
            }
        }
        impl From<PorrPorr11> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr11) -> u8 {
                PorrPorr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr12 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr12 {
                PorrPorr12::from_bits(val)
            }
        }
        impl From<PorrPorr12> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr12) -> u8 {
                PorrPorr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr13 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr13 {
                PorrPorr13::from_bits(val)
            }
        }
        impl From<PorrPorr13> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr13) -> u8 {
                PorrPorr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr14 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr14 {
                PorrPorr14::from_bits(val)
            }
        }
        impl From<PorrPorr14> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr14) -> u8 {
                PorrPorr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PorrPorr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PorrPorr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PorrPorr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PorrPorr15 {
            #[inline(always)]
            fn from(val: u8) -> PorrPorr15 {
                PorrPorr15::from_bits(val)
            }
        }
        impl From<PorrPorr15> for u8 {
            #[inline(always)]
            fn from(val: PorrPorr15) -> u8 {
                PorrPorr15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr00 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr00 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr00 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr00 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr00 {
                PosrPosr00::from_bits(val)
            }
        }
        impl From<PosrPosr00> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr00) -> u8 {
                PosrPosr00::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr01 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr01 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr01 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr01 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr01 {
                PosrPosr01::from_bits(val)
            }
        }
        impl From<PosrPosr01> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr01) -> u8 {
                PosrPosr01::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr02 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr02 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr02 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr02 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr02 {
                PosrPosr02::from_bits(val)
            }
        }
        impl From<PosrPosr02> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr02) -> u8 {
                PosrPosr02::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr03 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr03 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr03 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr03 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr03 {
                PosrPosr03::from_bits(val)
            }
        }
        impl From<PosrPosr03> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr03) -> u8 {
                PosrPosr03::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr04 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr04 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr04 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr04 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr04 {
                PosrPosr04::from_bits(val)
            }
        }
        impl From<PosrPosr04> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr04) -> u8 {
                PosrPosr04::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr05 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr05 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr05 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr05 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr05 {
                PosrPosr05::from_bits(val)
            }
        }
        impl From<PosrPosr05> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr05) -> u8 {
                PosrPosr05::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr06 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr06 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr06 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr06 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr06 {
                PosrPosr06::from_bits(val)
            }
        }
        impl From<PosrPosr06> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr06) -> u8 {
                PosrPosr06::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr07 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr07 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr07 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr07 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr07 {
                PosrPosr07::from_bits(val)
            }
        }
        impl From<PosrPosr07> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr07) -> u8 {
                PosrPosr07::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr08 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr08 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr08 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr08 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr08 {
                PosrPosr08::from_bits(val)
            }
        }
        impl From<PosrPosr08> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr08) -> u8 {
                PosrPosr08::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr09 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr09 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr09 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr09 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr09 {
                PosrPosr09::from_bits(val)
            }
        }
        impl From<PosrPosr09> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr09) -> u8 {
                PosrPosr09::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr10 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr10 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr10 {
                PosrPosr10::from_bits(val)
            }
        }
        impl From<PosrPosr10> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr10) -> u8 {
                PosrPosr10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr11 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr11 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr11 {
                PosrPosr11::from_bits(val)
            }
        }
        impl From<PosrPosr11> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr11) -> u8 {
                PosrPosr11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr12 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr12 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr12 {
                PosrPosr12::from_bits(val)
            }
        }
        impl From<PosrPosr12> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr12) -> u8 {
                PosrPosr12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr13 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr13 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr13 {
                PosrPosr13::from_bits(val)
            }
        }
        impl From<PosrPosr13> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr13) -> u8 {
                PosrPosr13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr14 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr14 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr14 {
                PosrPosr14::from_bits(val)
            }
        }
        impl From<PosrPosr14> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr14) -> u8 {
                PosrPosr14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PosrPosr15 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PosrPosr15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PosrPosr15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PosrPosr15 {
            #[inline(always)]
            fn from(val: u8) -> PosrPosr15 {
                PosrPosr15::from_bits(val)
            }
        }
        impl From<PosrPosr15> for u8 {
            #[inline(always)]
            fn from(val: PosrPosr15) -> u8 {
                PosrPosr15::to_bits(val)
            }
        }
    }
}
pub mod rmpu {
    #[doc = "Renesas Memory Protection Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rmpu {
        ptr: *mut u8,
    }
    unsafe impl Send for Rmpu {}
    unsafe impl Sync for Rmpu {}
    impl Rmpu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Bus Master MPU Control Register"]
        #[inline(always)]
        pub const fn mmpuctla(self) -> crate::common::Reg<regs::Mmpuctla, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Group A Protection of Register"]
        #[inline(always)]
        pub const fn mmpupta(self) -> crate::common::Reg<regs::Mmpupta, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0102usize) as _) }
        }
        #[doc = "Group A Region %s access control register"]
        #[inline(always)]
        pub const fn mmpuaca(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Mmpuaca, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize + n * 16usize) as _) }
        }
        #[doc = "Group A Region %s Start Address Register"]
        #[inline(always)]
        pub const fn mmpusa(self, n: usize) -> crate::common::Reg<regs::Mmpusa, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize + n * 16usize) as _) }
        }
        #[doc = "Group A Region %s End Address Register"]
        #[inline(always)]
        pub const fn mmpuea(self, n: usize) -> crate::common::Reg<regs::Mmpuea, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize + n * 16usize) as _) }
        }
        #[doc = "Slave MPU Control Register"]
        #[inline(always)]
        pub const fn smpuctl(self) -> crate::common::Reg<regs::Smpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c00usize) as _) }
        }
        #[doc = "Access Control Register for Memory Bus 1"]
        #[inline(always)]
        pub const fn smpumbiu(self) -> crate::common::Reg<regs::Smpumbiu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c10usize) as _) }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 9"]
        #[inline(always)]
        pub const fn smpufbiu(self) -> crate::common::Reg<regs::Smpufbiu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c14usize) as _) }
        }
        #[doc = "Access Control Register for Memory Bus 4"]
        #[inline(always)]
        pub const fn smpusram0(self) -> crate::common::Reg<regs::Smpusram0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c18usize) as _) }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 1"]
        #[inline(always)]
        pub const fn smpup0biu(self) -> crate::common::Reg<regs::Smpup0biu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c20usize) as _) }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 3"]
        #[inline(always)]
        pub const fn smpup2biu(self) -> crate::common::Reg<regs::Smpup2biu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c24usize) as _) }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 7"]
        #[inline(always)]
        pub const fn smpup6biu(self) -> crate::common::Reg<regs::Smpup6biu, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0c28usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[inline(always)]
        pub const fn mspmpuoad(self) -> crate::common::Reg<regs::Mspmpuoad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d00usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[inline(always)]
        pub const fn mspmpuctl(self) -> crate::common::Reg<regs::Mspmpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d04usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[inline(always)]
        pub const fn mspmpupt(self) -> crate::common::Reg<regs::Mspmpupt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d06usize) as _) }
        }
        #[doc = "Main Stack Pointer (MSP) Monitor Start Address Register"]
        #[inline(always)]
        pub const fn mspmpusa(self) -> crate::common::Reg<regs::Mspmpusa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d08usize) as _) }
        }
        #[doc = "Main Stack Pointer (MSP) Monitor End Address Register"]
        #[inline(always)]
        pub const fn mspmpuea(self) -> crate::common::Reg<regs::Mspmpuea, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d0cusize) as _) }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[inline(always)]
        pub const fn pspmpuoad(self) -> crate::common::Reg<regs::Pspmpuoad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d10usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[inline(always)]
        pub const fn pspmpuctl(self) -> crate::common::Reg<regs::Pspmpuctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d14usize) as _) }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[inline(always)]
        pub const fn pspmpupt(self) -> crate::common::Reg<regs::Pspmpupt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d16usize) as _) }
        }
        #[doc = "Process Stack Pointer (PSP) Monitor Start Address Register"]
        #[inline(always)]
        pub const fn pspmpusa(self) -> crate::common::Reg<regs::Pspmpusa, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d18usize) as _) }
        }
        #[doc = "Process Stack Pointer (PSP) Monitor End Address Register"]
        #[inline(always)]
        pub const fn pspmpuea(self) -> crate::common::Reg<regs::Pspmpuea, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Group A Region %s access control register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuaca(pub u16);
        impl Mmpuaca {
            #[doc = "Region Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MmpuacaEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MmpuacaEnable::from_bits(val as u8)
            }
            #[doc = "Region Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MmpuacaEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Read Protection"]
            #[inline(always)]
            pub const fn rp(&self) -> super::vals::Rp {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rp::from_bits(val as u8)
            }
            #[doc = "Read Protection"]
            #[inline(always)]
            pub fn set_rp(&mut self, val: super::vals::Rp) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Write Protection"]
            #[inline(always)]
            pub const fn wp(&self) -> super::vals::Wp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Wp::from_bits(val as u8)
            }
            #[doc = "Write Protection"]
            #[inline(always)]
            pub fn set_wp(&mut self, val: super::vals::Wp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
        }
        impl Default for Mmpuaca {
            #[inline(always)]
            fn default() -> Mmpuaca {
                Mmpuaca(0)
            }
        }
        impl core::fmt::Debug for Mmpuaca {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuaca")
                    .field("enable", &self.enable())
                    .field("rp", &self.rp())
                    .field("wp", &self.wp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuaca {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpuaca {{ enable: {:?}, rp: {:?}, wp: {:?} }}",
                    self.enable(),
                    self.rp(),
                    self.wp()
                )
            }
        }
        #[doc = "Bus Master MPU Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuctla(pub u16);
        impl Mmpuctla {
            #[doc = "Master Group Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MmpuctlaEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MmpuctlaEnable::from_bits(val as u8)
            }
            #[doc = "Master Group Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MmpuctlaEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::MmpuctlaOad {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::MmpuctlaOad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::MmpuctlaOad) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mmpuctla {
            #[inline(always)]
            fn default() -> Mmpuctla {
                Mmpuctla(0)
            }
        }
        impl core::fmt::Debug for Mmpuctla {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuctla")
                    .field("enable", &self.enable())
                    .field("oad", &self.oad())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuctla {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpuctla {{ enable: {:?}, oad: {:?}, key: {=u8:?} }}",
                    self.enable(),
                    self.oad(),
                    self.key()
                )
            }
        }
        #[doc = "Group A Region %s End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpuea(pub u32);
        impl Mmpuea {
            #[doc = "Region End Address"]
            #[inline(always)]
            pub const fn mmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region End Address"]
            #[inline(always)]
            pub fn set_mmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mmpuea {
            #[inline(always)]
            fn default() -> Mmpuea {
                Mmpuea(0)
            }
        }
        impl core::fmt::Debug for Mmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpuea")
                    .field("mmpuea", &self.mmpuea())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mmpuea {{ mmpuea: {=u32:?} }}", self.mmpuea())
            }
        }
        #[doc = "Group A Protection of Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpupta(pub u16);
        impl Mmpupta {
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::MmpuptaProtect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MmpuptaProtect::from_bits(val as u8)
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::MmpuptaProtect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mmpupta {
            #[inline(always)]
            fn default() -> Mmpupta {
                Mmpupta(0)
            }
        }
        impl core::fmt::Debug for Mmpupta {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpupta")
                    .field("protect", &self.protect())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpupta {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mmpupta {{ protect: {:?}, key: {=u8:?} }}",
                    self.protect(),
                    self.key()
                )
            }
        }
        #[doc = "Group A Region %s Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mmpusa(pub u32);
        impl Mmpusa {
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub const fn mmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub fn set_mmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mmpusa {
            #[inline(always)]
            fn default() -> Mmpusa {
                Mmpusa(0)
            }
        }
        impl core::fmt::Debug for Mmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mmpusa")
                    .field("mmpusa", &self.mmpusa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mmpusa {{ mmpusa: {=u32:?} }}", self.mmpusa())
            }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuctl(pub u16);
        impl Mspmpuctl {
            #[doc = "Stack Pointer Monitor Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::MspmpuctlEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuctlEnable::from_bits(val as u8)
            }
            #[doc = "Stack Pointer Monitor Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::MspmpuctlEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Stack Pointer Monitor Error Flag"]
            #[inline(always)]
            pub const fn error(&self) -> super::vals::MspmpuctlError {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::MspmpuctlError::from_bits(val as u8)
            }
            #[doc = "Stack Pointer Monitor Error Flag"]
            #[inline(always)]
            pub fn set_error(&mut self, val: super::vals::MspmpuctlError) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
        }
        impl Default for Mspmpuctl {
            #[inline(always)]
            fn default() -> Mspmpuctl {
                Mspmpuctl(0)
            }
        }
        impl core::fmt::Debug for Mspmpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuctl")
                    .field("enable", &self.enable())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mspmpuctl {{ enable: {:?}, error: {:?} }}",
                    self.enable(),
                    self.error()
                )
            }
        }
        #[doc = "Main Stack Pointer (MSP) Monitor End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuea(pub u32);
        impl Mspmpuea {
            #[doc = "Region End Address"]
            #[inline(always)]
            pub const fn mspmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region End Address"]
            #[inline(always)]
            pub fn set_mspmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mspmpuea {
            #[inline(always)]
            fn default() -> Mspmpuea {
                Mspmpuea(0)
            }
        }
        impl core::fmt::Debug for Mspmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuea")
                    .field("mspmpuea", &self.mspmpuea())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mspmpuea {{ mspmpuea: {=u32:?} }}", self.mspmpuea())
            }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpuoad(pub u16);
        impl Mspmpuoad {
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::MspmpuoadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuoadOad::from_bits(val as u8)
            }
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::MspmpuoadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mspmpuoad {
            #[inline(always)]
            fn default() -> Mspmpuoad {
                Mspmpuoad(0)
            }
        }
        impl core::fmt::Debug for Mspmpuoad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpuoad")
                    .field("oad", &self.oad())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpuoad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mspmpuoad {{ oad: {:?}, key: {=u8:?} }}",
                    self.oad(),
                    self.key()
                )
            }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpupt(pub u16);
        impl Mspmpupt {
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::MspmpuptProtect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MspmpuptProtect::from_bits(val as u8)
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::MspmpuptProtect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Mspmpupt {
            #[inline(always)]
            fn default() -> Mspmpupt {
                Mspmpupt(0)
            }
        }
        impl core::fmt::Debug for Mspmpupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpupt")
                    .field("protect", &self.protect())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mspmpupt {{ protect: {:?}, key: {=u8:?} }}",
                    self.protect(),
                    self.key()
                )
            }
        }
        #[doc = "Main Stack Pointer (MSP) Monitor Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mspmpusa(pub u32);
        impl Mspmpusa {
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub const fn mspmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub fn set_mspmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mspmpusa {
            #[inline(always)]
            fn default() -> Mspmpusa {
                Mspmpusa(0)
            }
        }
        impl core::fmt::Debug for Mspmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mspmpusa")
                    .field("mspmpusa", &self.mspmpusa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mspmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mspmpusa {{ mspmpusa: {=u32:?} }}", self.mspmpusa())
            }
        }
        #[doc = "Stack Pointer Monitor Access Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuctl(pub u16);
        impl Pspmpuctl {
            #[doc = "Stack Pointer Monitor Enable"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::PspmpuctlEnable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuctlEnable::from_bits(val as u8)
            }
            #[doc = "Stack Pointer Monitor Enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::PspmpuctlEnable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Stack Pointer Monitor Error Flag"]
            #[inline(always)]
            pub const fn error(&self) -> super::vals::PspmpuctlError {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::PspmpuctlError::from_bits(val as u8)
            }
            #[doc = "Stack Pointer Monitor Error Flag"]
            #[inline(always)]
            pub fn set_error(&mut self, val: super::vals::PspmpuctlError) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
        }
        impl Default for Pspmpuctl {
            #[inline(always)]
            fn default() -> Pspmpuctl {
                Pspmpuctl(0)
            }
        }
        impl core::fmt::Debug for Pspmpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuctl")
                    .field("enable", &self.enable())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pspmpuctl {{ enable: {:?}, error: {:?} }}",
                    self.enable(),
                    self.error()
                )
            }
        }
        #[doc = "Process Stack Pointer (PSP) Monitor End Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuea(pub u32);
        impl Pspmpuea {
            #[doc = "Region End Address"]
            #[inline(always)]
            pub const fn pspmpuea(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region End Address"]
            #[inline(always)]
            pub fn set_pspmpuea(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Pspmpuea {
            #[inline(always)]
            fn default() -> Pspmpuea {
                Pspmpuea(0)
            }
        }
        impl core::fmt::Debug for Pspmpuea {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuea")
                    .field("pspmpuea", &self.pspmpuea())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuea {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pspmpuea {{ pspmpuea: {=u32:?} }}", self.pspmpuea())
            }
        }
        #[doc = "Stack Pointer Monitor Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpuoad(pub u16);
        impl Pspmpuoad {
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::PspmpuoadOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuoadOad::from_bits(val as u8)
            }
            #[doc = "Operation after Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::PspmpuoadOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Pspmpuoad {
            #[inline(always)]
            fn default() -> Pspmpuoad {
                Pspmpuoad(0)
            }
        }
        impl core::fmt::Debug for Pspmpuoad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpuoad")
                    .field("oad", &self.oad())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpuoad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pspmpuoad {{ oad: {:?}, key: {=u8:?} }}",
                    self.oad(),
                    self.key()
                )
            }
        }
        #[doc = "Stack Pointer Monitor Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpupt(pub u16);
        impl Pspmpupt {
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::PspmpuptProtect {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PspmpuptProtect::from_bits(val as u8)
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::PspmpuptProtect) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Pspmpupt {
            #[inline(always)]
            fn default() -> Pspmpupt {
                Pspmpupt(0)
            }
        }
        impl core::fmt::Debug for Pspmpupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpupt")
                    .field("protect", &self.protect())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pspmpupt {{ protect: {:?}, key: {=u8:?} }}",
                    self.protect(),
                    self.key()
                )
            }
        }
        #[doc = "Process Stack Pointer (PSP) Monitor Start Address Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pspmpusa(pub u32);
        impl Pspmpusa {
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub const fn pspmpusa(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                val as u32
            }
            #[doc = "Region Start Address"]
            #[inline(always)]
            pub fn set_pspmpusa(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Pspmpusa {
            #[inline(always)]
            fn default() -> Pspmpusa {
                Pspmpusa(0)
            }
        }
        impl core::fmt::Debug for Pspmpusa {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pspmpusa")
                    .field("pspmpusa", &self.pspmpusa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pspmpusa {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pspmpusa {{ pspmpusa: {=u32:?} }}", self.pspmpusa())
            }
        }
        #[doc = "Slave MPU Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpuctl(pub u16);
        impl Smpuctl {
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::SmpuctlOad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SmpuctlOad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::SmpuctlOad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub const fn protect(&self) -> super::vals::SmpuctlProtect {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::SmpuctlProtect::from_bits(val as u8)
            }
            #[doc = "Protection of Register"]
            #[inline(always)]
            pub fn set_protect(&mut self, val: super::vals::SmpuctlProtect) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub const fn key(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Key Code"]
            #[inline(always)]
            pub fn set_key(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Smpuctl {
            #[inline(always)]
            fn default() -> Smpuctl {
                Smpuctl(0)
            }
        }
        impl core::fmt::Debug for Smpuctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpuctl")
                    .field("oad", &self.oad())
                    .field("protect", &self.protect())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpuctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpuctl {{ oad: {:?}, protect: {:?}, key: {=u8:?} }}",
                    self.oad(),
                    self.protect(),
                    self.key()
                )
            }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 9"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpufbiu(pub u16);
        impl Smpufbiu {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::SmpufbiuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SmpufbiuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::SmpufbiuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::SmpufbiuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::SmpufbiuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::SmpufbiuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::SmpufbiuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SmpufbiuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::SmpufbiuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::SmpufbiuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SmpufbiuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::SmpufbiuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpufbiu {
            #[inline(always)]
            fn default() -> Smpufbiu {
                Smpufbiu(0)
            }
        }
        impl core::fmt::Debug for Smpufbiu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpufbiu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpufbiu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpufbiu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Memory Bus 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpumbiu(pub u16);
        impl Smpumbiu {
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::SmpumbiuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SmpumbiuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::SmpumbiuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::SmpumbiuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SmpumbiuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::SmpumbiuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpumbiu {
            #[inline(always)]
            fn default() -> Smpumbiu {
                Smpumbiu(0)
            }
        }
        impl core::fmt::Debug for Smpumbiu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpumbiu")
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpumbiu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpumbiu {{ rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpup0biu(pub u16);
        impl Smpup0biu {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpup0biuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpup0biuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpup0biuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpup0biuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpup0biuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpup0biuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpup0biuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpup0biuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpup0biuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpup0biuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpup0biuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpup0biuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpup0biu {
            #[inline(always)]
            fn default() -> Smpup0biu {
                Smpup0biu(0)
            }
        }
        impl core::fmt::Debug for Smpup0biu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpup0biu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpup0biu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpup0biu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpup2biu(pub u16);
        impl Smpup2biu {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpup2biuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpup2biuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpup2biuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpup2biuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpup2biuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpup2biuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpup2biuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpup2biuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpup2biuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpup2biuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpup2biuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpup2biuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpup2biu {
            #[inline(always)]
            fn default() -> Smpup2biu {
                Smpup2biu(0)
            }
        }
        impl core::fmt::Debug for Smpup2biu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpup2biu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpup2biu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpup2biu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Internal Peripheral Bus 7"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpup6biu(pub u16);
        impl Smpup6biu {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpup6biuRpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpup6biuRpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpup6biuRpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpup6biuWpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpup6biuWpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpup6biuWpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpup6biuRpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpup6biuRpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpup6biuRpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpup6biuWpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpup6biuWpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpup6biuWpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpup6biu {
            #[inline(always)]
            fn default() -> Smpup6biu {
                Smpup6biu(0)
            }
        }
        impl core::fmt::Debug for Smpup6biu {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpup6biu")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpup6biu {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpup6biu {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
        #[doc = "Access Control Register for Memory Bus 4"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smpusram0(pub u16);
        impl Smpusram0 {
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub const fn rpcpu(&self) -> super::vals::Smpusram0Rpcpu {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smpusram0Rpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Read Protection"]
            #[inline(always)]
            pub fn set_rpcpu(&mut self, val: super::vals::Smpusram0Rpcpu) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub const fn wpcpu(&self) -> super::vals::Smpusram0Wpcpu {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Smpusram0Wpcpu::from_bits(val as u8)
            }
            #[doc = "CPU Write Protection"]
            #[inline(always)]
            pub fn set_wpcpu(&mut self, val: super::vals::Smpusram0Wpcpu) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub const fn rpgrpa(&self) -> super::vals::Smpusram0Rpgrpa {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Smpusram0Rpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Read Protection"]
            #[inline(always)]
            pub fn set_rpgrpa(&mut self, val: super::vals::Smpusram0Rpgrpa) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub const fn wpgrpa(&self) -> super::vals::Smpusram0Wpgrpa {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Smpusram0Wpgrpa::from_bits(val as u8)
            }
            #[doc = "Master MPU Group A Write Protection"]
            #[inline(always)]
            pub fn set_wpgrpa(&mut self, val: super::vals::Smpusram0Wpgrpa) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
        }
        impl Default for Smpusram0 {
            #[inline(always)]
            fn default() -> Smpusram0 {
                Smpusram0(0)
            }
        }
        impl core::fmt::Debug for Smpusram0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smpusram0")
                    .field("rpcpu", &self.rpcpu())
                    .field("wpcpu", &self.wpcpu())
                    .field("rpgrpa", &self.rpgrpa())
                    .field("wpgrpa", &self.wpgrpa())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smpusram0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Smpusram0 {{ rpcpu: {:?}, wpcpu: {:?}, rpgrpa: {:?}, wpgrpa: {:?} }}",
                    self.rpcpu(),
                    self.wpcpu(),
                    self.rpgrpa(),
                    self.wpgrpa()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuacaEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuacaEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuacaEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuacaEnable {
            #[inline(always)]
            fn from(val: u8) -> MmpuacaEnable {
                MmpuacaEnable::from_bits(val)
            }
        }
        impl From<MmpuacaEnable> for u8 {
            #[inline(always)]
            fn from(val: MmpuacaEnable) -> u8 {
                MmpuacaEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuctlaEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuctlaEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuctlaEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuctlaEnable {
            #[inline(always)]
            fn from(val: u8) -> MmpuctlaEnable {
                MmpuctlaEnable::from_bits(val)
            }
        }
        impl From<MmpuctlaEnable> for u8 {
            #[inline(always)]
            fn from(val: MmpuctlaEnable) -> u8 {
                MmpuctlaEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuctlaOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuctlaOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuctlaOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuctlaOad {
            #[inline(always)]
            fn from(val: u8) -> MmpuctlaOad {
                MmpuctlaOad::from_bits(val)
            }
        }
        impl From<MmpuctlaOad> for u8 {
            #[inline(always)]
            fn from(val: MmpuctlaOad) -> u8 {
                MmpuctlaOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MmpuptaProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MmpuptaProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MmpuptaProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MmpuptaProtect {
            #[inline(always)]
            fn from(val: u8) -> MmpuptaProtect {
                MmpuptaProtect::from_bits(val)
            }
        }
        impl From<MmpuptaProtect> for u8 {
            #[inline(always)]
            fn from(val: MmpuptaProtect) -> u8 {
                MmpuptaProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuctlEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuctlEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuctlEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuctlEnable {
            #[inline(always)]
            fn from(val: u8) -> MspmpuctlEnable {
                MspmpuctlEnable::from_bits(val)
            }
        }
        impl From<MspmpuctlEnable> for u8 {
            #[inline(always)]
            fn from(val: MspmpuctlEnable) -> u8 {
                MspmpuctlEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuctlError {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuctlError {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuctlError {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuctlError {
            #[inline(always)]
            fn from(val: u8) -> MspmpuctlError {
                MspmpuctlError::from_bits(val)
            }
        }
        impl From<MspmpuctlError> for u8 {
            #[inline(always)]
            fn from(val: MspmpuctlError) -> u8 {
                MspmpuctlError::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuoadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuoadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuoadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuoadOad {
            #[inline(always)]
            fn from(val: u8) -> MspmpuoadOad {
                MspmpuoadOad::from_bits(val)
            }
        }
        impl From<MspmpuoadOad> for u8 {
            #[inline(always)]
            fn from(val: MspmpuoadOad) -> u8 {
                MspmpuoadOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MspmpuptProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl MspmpuptProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MspmpuptProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MspmpuptProtect {
            #[inline(always)]
            fn from(val: u8) -> MspmpuptProtect {
                MspmpuptProtect::from_bits(val)
            }
        }
        impl From<MspmpuptProtect> for u8 {
            #[inline(always)]
            fn from(val: MspmpuptProtect) -> u8 {
                MspmpuptProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuctlEnable {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuctlEnable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuctlEnable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuctlEnable {
            #[inline(always)]
            fn from(val: u8) -> PspmpuctlEnable {
                PspmpuctlEnable::from_bits(val)
            }
        }
        impl From<PspmpuctlEnable> for u8 {
            #[inline(always)]
            fn from(val: PspmpuctlEnable) -> u8 {
                PspmpuctlEnable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuctlError {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuctlError {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuctlError {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuctlError {
            #[inline(always)]
            fn from(val: u8) -> PspmpuctlError {
                PspmpuctlError::from_bits(val)
            }
        }
        impl From<PspmpuctlError> for u8 {
            #[inline(always)]
            fn from(val: PspmpuctlError) -> u8 {
                PspmpuctlError::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuoadOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuoadOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuoadOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuoadOad {
            #[inline(always)]
            fn from(val: u8) -> PspmpuoadOad {
                PspmpuoadOad::from_bits(val)
            }
        }
        impl From<PspmpuoadOad> for u8 {
            #[inline(always)]
            fn from(val: PspmpuoadOad) -> u8 {
                PspmpuoadOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PspmpuptProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl PspmpuptProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PspmpuptProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PspmpuptProtect {
            #[inline(always)]
            fn from(val: u8) -> PspmpuptProtect {
                PspmpuptProtect::from_bits(val)
            }
        }
        impl From<PspmpuptProtect> for u8 {
            #[inline(always)]
            fn from(val: PspmpuptProtect) -> u8 {
                PspmpuptProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rp {
            #[inline(always)]
            fn from(val: u8) -> Rp {
                Rp::from_bits(val)
            }
        }
        impl From<Rp> for u8 {
            #[inline(always)]
            fn from(val: Rp) -> u8 {
                Rp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpuctlOad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpuctlOad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpuctlOad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpuctlOad {
            #[inline(always)]
            fn from(val: u8) -> SmpuctlOad {
                SmpuctlOad::from_bits(val)
            }
        }
        impl From<SmpuctlOad> for u8 {
            #[inline(always)]
            fn from(val: SmpuctlOad) -> u8 {
                SmpuctlOad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpuctlProtect {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpuctlProtect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpuctlProtect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpuctlProtect {
            #[inline(always)]
            fn from(val: u8) -> SmpuctlProtect {
                SmpuctlProtect::from_bits(val)
            }
        }
        impl From<SmpuctlProtect> for u8 {
            #[inline(always)]
            fn from(val: SmpuctlProtect) -> u8 {
                SmpuctlProtect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuRpcpu {
                SmpufbiuRpcpu::from_bits(val)
            }
        }
        impl From<SmpufbiuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuRpcpu) -> u8 {
                SmpufbiuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuRpgrpa {
                SmpufbiuRpgrpa::from_bits(val)
            }
        }
        impl From<SmpufbiuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuRpgrpa) -> u8 {
                SmpufbiuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuWpcpu {
                SmpufbiuWpcpu::from_bits(val)
            }
        }
        impl From<SmpufbiuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuWpcpu) -> u8 {
                SmpufbiuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpufbiuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpufbiuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpufbiuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpufbiuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpufbiuWpgrpa {
                SmpufbiuWpgrpa::from_bits(val)
            }
        }
        impl From<SmpufbiuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpufbiuWpgrpa) -> u8 {
                SmpufbiuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpumbiuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpumbiuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpumbiuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpumbiuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpumbiuRpgrpa {
                SmpumbiuRpgrpa::from_bits(val)
            }
        }
        impl From<SmpumbiuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpumbiuRpgrpa) -> u8 {
                SmpumbiuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmpumbiuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmpumbiuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmpumbiuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmpumbiuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> SmpumbiuWpgrpa {
                SmpumbiuWpgrpa::from_bits(val)
            }
        }
        impl From<SmpumbiuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: SmpumbiuWpgrpa) -> u8 {
                SmpumbiuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup0biuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup0biuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup0biuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup0biuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup0biuRpcpu {
                Smpup0biuRpcpu::from_bits(val)
            }
        }
        impl From<Smpup0biuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup0biuRpcpu) -> u8 {
                Smpup0biuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup0biuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup0biuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup0biuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup0biuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup0biuRpgrpa {
                Smpup0biuRpgrpa::from_bits(val)
            }
        }
        impl From<Smpup0biuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup0biuRpgrpa) -> u8 {
                Smpup0biuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup0biuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup0biuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup0biuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup0biuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup0biuWpcpu {
                Smpup0biuWpcpu::from_bits(val)
            }
        }
        impl From<Smpup0biuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup0biuWpcpu) -> u8 {
                Smpup0biuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup0biuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup0biuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup0biuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup0biuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup0biuWpgrpa {
                Smpup0biuWpgrpa::from_bits(val)
            }
        }
        impl From<Smpup0biuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup0biuWpgrpa) -> u8 {
                Smpup0biuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup2biuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup2biuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup2biuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup2biuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup2biuRpcpu {
                Smpup2biuRpcpu::from_bits(val)
            }
        }
        impl From<Smpup2biuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup2biuRpcpu) -> u8 {
                Smpup2biuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup2biuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup2biuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup2biuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup2biuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup2biuRpgrpa {
                Smpup2biuRpgrpa::from_bits(val)
            }
        }
        impl From<Smpup2biuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup2biuRpgrpa) -> u8 {
                Smpup2biuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup2biuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup2biuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup2biuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup2biuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup2biuWpcpu {
                Smpup2biuWpcpu::from_bits(val)
            }
        }
        impl From<Smpup2biuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup2biuWpcpu) -> u8 {
                Smpup2biuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup2biuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup2biuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup2biuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup2biuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup2biuWpgrpa {
                Smpup2biuWpgrpa::from_bits(val)
            }
        }
        impl From<Smpup2biuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup2biuWpgrpa) -> u8 {
                Smpup2biuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup6biuRpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup6biuRpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup6biuRpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup6biuRpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup6biuRpcpu {
                Smpup6biuRpcpu::from_bits(val)
            }
        }
        impl From<Smpup6biuRpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup6biuRpcpu) -> u8 {
                Smpup6biuRpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup6biuRpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup6biuRpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup6biuRpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup6biuRpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup6biuRpgrpa {
                Smpup6biuRpgrpa::from_bits(val)
            }
        }
        impl From<Smpup6biuRpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup6biuRpgrpa) -> u8 {
                Smpup6biuRpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup6biuWpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup6biuWpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup6biuWpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup6biuWpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpup6biuWpcpu {
                Smpup6biuWpcpu::from_bits(val)
            }
        }
        impl From<Smpup6biuWpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpup6biuWpcpu) -> u8 {
                Smpup6biuWpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpup6biuWpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpup6biuWpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpup6biuWpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpup6biuWpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpup6biuWpgrpa {
                Smpup6biuWpgrpa::from_bits(val)
            }
        }
        impl From<Smpup6biuWpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpup6biuWpgrpa) -> u8 {
                Smpup6biuWpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Rpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Rpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Rpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Rpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Rpcpu {
                Smpusram0Rpcpu::from_bits(val)
            }
        }
        impl From<Smpusram0Rpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Rpcpu) -> u8 {
                Smpusram0Rpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Rpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Rpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Rpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Rpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Rpgrpa {
                Smpusram0Rpgrpa::from_bits(val)
            }
        }
        impl From<Smpusram0Rpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Rpgrpa) -> u8 {
                Smpusram0Rpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Wpcpu {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Wpcpu {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Wpcpu {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Wpcpu {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Wpcpu {
                Smpusram0Wpcpu::from_bits(val)
            }
        }
        impl From<Smpusram0Wpcpu> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Wpcpu) -> u8 {
                Smpusram0Wpcpu::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smpusram0Wpgrpa {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smpusram0Wpgrpa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smpusram0Wpgrpa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smpusram0Wpgrpa {
            #[inline(always)]
            fn from(val: u8) -> Smpusram0Wpgrpa {
                Smpusram0Wpgrpa::from_bits(val)
            }
        }
        impl From<Smpusram0Wpgrpa> for u8 {
            #[inline(always)]
            fn from(val: Smpusram0Wpgrpa) -> u8 {
                Smpusram0Wpgrpa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wp {
            #[inline(always)]
            fn from(val: u8) -> Wp {
                Wp::from_bits(val)
            }
        }
        impl From<Wp> for u8 {
            #[inline(always)]
            fn from(val: Wp) -> u8 {
                Wp::to_bits(val)
            }
        }
    }
}
pub mod sci9 {
    #[doc = "Serial Communication Interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sci9 {
        ptr: *mut u8,
    }
    unsafe impl Send for Sci9 {}
    unsafe impl Sync for Sci9 {}
    impl Sci9 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Serial Mode Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn smr(self) -> crate::common::Reg<regs::Smr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn smr_smci(self) -> crate::common::Reg<regs::SmrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Bit Rate Register"]
        #[inline(always)]
        pub const fn brr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "Serial Control Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn scr(self) -> crate::common::Reg<regs::Scr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn scr_smci(self) -> crate::common::Reg<regs::ScrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "Transmit Data Register"]
        #[inline(always)]
        pub const fn tdr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "Serial Status Register for Non,Smart Card Interface (SCMR.SMIF = 0)"]
        #[inline(always)]
        pub const fn ssr(self) -> crate::common::Reg<regs::Ssr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[inline(always)]
        pub const fn ssr_smci(self) -> crate::common::Reg<regs::SsrSmci, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Receive Data Register"]
        #[inline(always)]
        pub const fn rdr(self) -> crate::common::Reg<u8, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05usize) as _) }
        }
        #[doc = "Smart Card Mode Register"]
        #[inline(always)]
        pub const fn scmr(self) -> crate::common::Reg<regs::Scmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "Serial Extended Mode Register"]
        #[inline(always)]
        pub const fn semr(self) -> crate::common::Reg<regs::Semr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x07usize) as _) }
        }
        #[doc = "Noise Filter Setting Register"]
        #[inline(always)]
        pub const fn snfr(self) -> crate::common::Reg<regs::Snfr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "IIC Mode Register 1"]
        #[inline(always)]
        pub const fn simr1(self) -> crate::common::Reg<regs::Simr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x09usize) as _) }
        }
        #[doc = "IIC Mode Register 2"]
        #[inline(always)]
        pub const fn simr2(self) -> crate::common::Reg<regs::Simr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "IIC Mode Register 3"]
        #[inline(always)]
        pub const fn simr3(self) -> crate::common::Reg<regs::Simr3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "IIC Status Register"]
        #[inline(always)]
        pub const fn sisr(self) -> crate::common::Reg<regs::Sisr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Mode Register"]
        #[inline(always)]
        pub const fn spmr(self) -> crate::common::Reg<regs::Spmr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "Transmit Data Register"]
        #[inline(always)]
        pub const fn tdrhl(self) -> crate::common::Reg<regs::Tdrhl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "Receive Data Register"]
        #[inline(always)]
        pub const fn rdrhl(self) -> crate::common::Reg<regs::Rdrhl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Modulation Duty Register"]
        #[inline(always)]
        pub const fn mddr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12usize) as _) }
        }
        #[doc = "Data Compare Match Control Register"]
        #[inline(always)]
        pub const fn dccr(self) -> crate::common::Reg<regs::Dccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13usize) as _) }
        }
        #[doc = "Compare Match Data Register"]
        #[inline(always)]
        pub const fn cdr(self) -> crate::common::Reg<regs::Cdr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1ausize) as _) }
        }
        #[doc = "Serial Port Register"]
        #[inline(always)]
        pub const fn sptr(self) -> crate::common::Reg<regs::Sptr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Compare Match Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cdr(pub u16);
        impl Cdr {
            #[doc = "Compare Match Data"]
            #[inline(always)]
            pub const fn cmpd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Compare Match Data"]
            #[inline(always)]
            pub fn set_cmpd(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Cdr {
            #[inline(always)]
            fn default() -> Cdr {
                Cdr(0)
            }
        }
        impl core::fmt::Debug for Cdr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cdr").field("cmpd", &self.cmpd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cdr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cdr {{ cmpd: {=u16:?} }}", self.cmpd())
            }
        }
        #[doc = "Data Compare Match Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dccr(pub u8);
        impl Dccr {
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub const fn dcmf(&self) -> super::vals::Dcmf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dcmf::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Flag"]
            #[inline(always)]
            pub fn set_dcmf(&mut self, val: super::vals::Dcmf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub const fn dper(&self) -> super::vals::Dper {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Dper::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Parity Error Flag"]
            #[inline(always)]
            pub fn set_dper(&mut self, val: super::vals::Dper) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub const fn dfer(&self) -> super::vals::Dfer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Dfer::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Framing Error Flag"]
            #[inline(always)]
            pub fn set_dfer(&mut self, val: super::vals::Dfer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "ID Frame Select"]
            #[inline(always)]
            pub const fn idsel(&self) -> super::vals::Idsel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Idsel::from_bits(val as u8)
            }
            #[doc = "ID Frame Select"]
            #[inline(always)]
            pub fn set_idsel(&mut self, val: super::vals::Idsel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Data Compare Match Enable"]
            #[inline(always)]
            pub const fn dcme(&self) -> super::vals::Dcme {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dcme::from_bits(val as u8)
            }
            #[doc = "Data Compare Match Enable"]
            #[inline(always)]
            pub fn set_dcme(&mut self, val: super::vals::Dcme) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Dccr {
            #[inline(always)]
            fn default() -> Dccr {
                Dccr(0)
            }
        }
        impl core::fmt::Debug for Dccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dccr")
                    .field("dcmf", &self.dcmf())
                    .field("dper", &self.dper())
                    .field("dfer", &self.dfer())
                    .field("idsel", &self.idsel())
                    .field("dcme", &self.dcme())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dccr {{ dcmf: {:?}, dper: {:?}, dfer: {:?}, idsel: {:?}, dcme: {:?} }}",
                    self.dcmf(),
                    self.dper(),
                    self.dfer(),
                    self.idsel(),
                    self.dcme()
                )
            }
        }
        #[doc = "Receive Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rdrhl(pub u16);
        impl Rdrhl {
            #[doc = "Serial Receive Data"]
            #[inline(always)]
            pub const fn rdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial Receive Data"]
            #[inline(always)]
            pub fn set_rdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Rdrhl {
            #[inline(always)]
            fn default() -> Rdrhl {
                Rdrhl(0)
            }
        }
        impl core::fmt::Debug for Rdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rdrhl").field("rdat", &self.rdat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rdrhl {{ rdat: {=u16:?} }}", self.rdat())
            }
        }
        #[doc = "Smart Card Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scmr(pub u8);
        impl Scmr {
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub const fn smif(&self) -> super::vals::Smif {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Smif::from_bits(val as u8)
            }
            #[doc = "Smart Card Interface Mode Select"]
            #[inline(always)]
            pub fn set_smif(&mut self, val: super::vals::Smif) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Transmitted/Received Data Invert"]
            #[inline(always)]
            pub const fn sinv(&self) -> super::vals::Sinv {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Sinv::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data Invert"]
            #[inline(always)]
            pub fn set_sinv(&mut self, val: super::vals::Sinv) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Transmitted/Received Data Transfer Direction"]
            #[inline(always)]
            pub const fn sdir(&self) -> super::vals::Sdir {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sdir::from_bits(val as u8)
            }
            #[doc = "Transmitted/Received Data Transfer Direction"]
            #[inline(always)]
            pub fn set_sdir(&mut self, val: super::vals::Sdir) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Character Length 1"]
            #[inline(always)]
            pub const fn chr1(&self) -> super::vals::Chr1 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Chr1::from_bits(val as u8)
            }
            #[doc = "Character Length 1"]
            #[inline(always)]
            pub fn set_chr1(&mut self, val: super::vals::Chr1) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Base Clock Pulse 2"]
            #[inline(always)]
            pub const fn bcp2(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Base Clock Pulse 2"]
            #[inline(always)]
            pub fn set_bcp2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scmr {
            #[inline(always)]
            fn default() -> Scmr {
                Scmr(0)
            }
        }
        impl core::fmt::Debug for Scmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scmr")
                    .field("smif", &self.smif())
                    .field("sinv", &self.sinv())
                    .field("sdir", &self.sdir())
                    .field("chr1", &self.chr1())
                    .field("bcp2", &self.bcp2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scmr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Scmr {{ smif: {:?}, sinv: {:?}, sdir: {:?}, chr1: {:?}, bcp2: {=bool:?} }}",
                    self.smif(),
                    self.sinv(),
                    self.sdir(),
                    self.chr1(),
                    self.bcp2()
                )
            }
        }
        #[doc = "Serial Control Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Scr(pub u8);
        impl Scr {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> super::vals::Teie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Teie::from_bits(val as u8)
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: super::vals::Teie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub const fn mpie(&self) -> super::vals::Mpie {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mpie::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: super::vals::Mpie) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Scr {
            #[inline(always)]
            fn default() -> Scr {
                Scr(0)
            }
        }
        impl core::fmt::Debug for Scr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Scr")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Scr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Scr {{ cke: {:?}, teie: {:?}, mpie: {:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Control Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ScrSmci(pub u8);
        impl ScrSmci {
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub const fn cke(&self) -> super::vals::ScrSmciCke {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ScrSmciCke::from_bits(val as u8)
            }
            #[doc = "Clock Enable"]
            #[inline(always)]
            pub fn set_cke(&mut self, val: super::vals::ScrSmciCke) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub const fn teie(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit End Interrupt Enable"]
            #[inline(always)]
            pub fn set_teie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u8) & 0x01) << 2usize);
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub const fn mpie(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor Interrupt Enable"]
            #[inline(always)]
            pub fn set_mpie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u8) & 0x01) << 3usize);
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub const fn re(&self) -> super::vals::ScrSmciRe {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ScrSmciRe::from_bits(val as u8)
            }
            #[doc = "Receive Enable"]
            #[inline(always)]
            pub fn set_re(&mut self, val: super::vals::ScrSmciRe) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub const fn te(&self) -> super::vals::ScrSmciTe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::ScrSmciTe::from_bits(val as u8)
            }
            #[doc = "Transmit Enable"]
            #[inline(always)]
            pub fn set_te(&mut self, val: super::vals::ScrSmciTe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::ScrSmciRie {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::ScrSmciRie::from_bits(val as u8)
            }
            #[doc = "Receive Interrupt Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::ScrSmciRie) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub const fn tie(&self) -> super::vals::ScrSmciTie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::ScrSmciTie::from_bits(val as u8)
            }
            #[doc = "Transmit Interrupt Enable"]
            #[inline(always)]
            pub fn set_tie(&mut self, val: super::vals::ScrSmciTie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for ScrSmci {
            #[inline(always)]
            fn default() -> ScrSmci {
                ScrSmci(0)
            }
        }
        impl core::fmt::Debug for ScrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ScrSmci")
                    .field("cke", &self.cke())
                    .field("teie", &self.teie())
                    .field("mpie", &self.mpie())
                    .field("re", &self.re())
                    .field("te", &self.te())
                    .field("rie", &self.rie())
                    .field("tie", &self.tie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ScrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ScrSmci {{ cke: {:?}, teie: {=bool:?}, mpie: {=bool:?}, re: {:?}, te: {:?}, rie: {:?}, tie: {:?} }}" , self . cke () , self . teie () , self . mpie () , self . re () , self . te () , self . rie () , self . tie ())
            }
        }
        #[doc = "Serial Extended Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semr(pub u8);
        impl Semr {
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub const fn brme(&self) -> super::vals::Brme {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Brme::from_bits(val as u8)
            }
            #[doc = "Bit Rate Modulation Enable"]
            #[inline(always)]
            pub fn set_brme(&mut self, val: super::vals::Brme) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select 1"]
            #[inline(always)]
            pub const fn abcse(&self) -> super::vals::Abcse {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Abcse::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Extended Base Clock Select 1"]
            #[inline(always)]
            pub fn set_abcse(&mut self, val: super::vals::Abcse) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Asynchronous Mode Base Clock Select"]
            #[inline(always)]
            pub const fn abcs(&self) -> super::vals::Abcs {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Abcs::from_bits(val as u8)
            }
            #[doc = "Asynchronous Mode Base Clock Select"]
            #[inline(always)]
            pub fn set_abcs(&mut self, val: super::vals::Abcs) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Digital Noise Filter Function Enable"]
            #[inline(always)]
            pub const fn nfen(&self) -> super::vals::Nfen {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nfen::from_bits(val as u8)
            }
            #[doc = "Digital Noise Filter Function Enable"]
            #[inline(always)]
            pub fn set_nfen(&mut self, val: super::vals::Nfen) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select"]
            #[inline(always)]
            pub const fn bgdm(&self) -> super::vals::Bgdm {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Bgdm::from_bits(val as u8)
            }
            #[doc = "Baud Rate Generator Double,Speed Mode Select"]
            #[inline(always)]
            pub fn set_bgdm(&mut self, val: super::vals::Bgdm) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select"]
            #[inline(always)]
            pub const fn rxdesel(&self) -> super::vals::Rxdesel {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rxdesel::from_bits(val as u8)
            }
            #[doc = "Asynchronous Start Bit Edge Detection Select"]
            #[inline(always)]
            pub fn set_rxdesel(&mut self, val: super::vals::Rxdesel) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Semr {
            #[inline(always)]
            fn default() -> Semr {
                Semr(0)
            }
        }
        impl core::fmt::Debug for Semr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semr")
                    .field("brme", &self.brme())
                    .field("abcse", &self.abcse())
                    .field("abcs", &self.abcs())
                    .field("nfen", &self.nfen())
                    .field("bgdm", &self.bgdm())
                    .field("rxdesel", &self.rxdesel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Semr {{ brme: {:?}, abcse: {:?}, abcs: {:?}, nfen: {:?}, bgdm: {:?}, rxdesel: {:?} }}" , self . brme () , self . abcse () , self . abcs () , self . nfen () , self . bgdm () , self . rxdesel ())
            }
        }
        #[doc = "IIC Mode Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr1(pub u8);
        impl Simr1 {
            #[doc = "Simple IIC Mode Select"]
            #[inline(always)]
            pub const fn iicm(&self) -> super::vals::Iicm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicm::from_bits(val as u8)
            }
            #[doc = "Simple IIC Mode Select"]
            #[inline(always)]
            pub fn set_iicm(&mut self, val: super::vals::Iicm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SDAn Delay Output Select"]
            #[inline(always)]
            pub const fn iicdl(&self) -> super::vals::Iicdl {
                let val = (self.0 >> 3usize) & 0x1f;
                super::vals::Iicdl::from_bits(val as u8)
            }
            #[doc = "SDAn Delay Output Select"]
            #[inline(always)]
            pub fn set_iicdl(&mut self, val: super::vals::Iicdl) {
                self.0 = (self.0 & !(0x1f << 3usize)) | (((val.to_bits() as u8) & 0x1f) << 3usize);
            }
        }
        impl Default for Simr1 {
            #[inline(always)]
            fn default() -> Simr1 {
                Simr1(0)
            }
        }
        impl core::fmt::Debug for Simr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr1")
                    .field("iicm", &self.iicm())
                    .field("iicdl", &self.iicdl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Simr1 {{ iicm: {:?}, iicdl: {:?} }}",
                    self.iicm(),
                    self.iicdl()
                )
            }
        }
        #[doc = "IIC Mode Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr2(pub u8);
        impl Simr2 {
            #[doc = "IIC Interrupt Mode Select"]
            #[inline(always)]
            pub const fn iicintm(&self) -> super::vals::Iicintm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicintm::from_bits(val as u8)
            }
            #[doc = "IIC Interrupt Mode Select"]
            #[inline(always)]
            pub fn set_iicintm(&mut self, val: super::vals::Iicintm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub const fn iiccsc(&self) -> super::vals::Iiccsc {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iiccsc::from_bits(val as u8)
            }
            #[doc = "Clock Synchronization"]
            #[inline(always)]
            pub fn set_iiccsc(&mut self, val: super::vals::Iiccsc) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub const fn iicackt(&self) -> super::vals::Iicackt {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Iicackt::from_bits(val as u8)
            }
            #[doc = "ACK Transmission Data"]
            #[inline(always)]
            pub fn set_iicackt(&mut self, val: super::vals::Iicackt) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Simr2 {
            #[inline(always)]
            fn default() -> Simr2 {
                Simr2(0)
            }
        }
        impl core::fmt::Debug for Simr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr2")
                    .field("iicintm", &self.iicintm())
                    .field("iiccsc", &self.iiccsc())
                    .field("iicackt", &self.iicackt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Simr2 {{ iicintm: {:?}, iiccsc: {:?}, iicackt: {:?} }}",
                    self.iicintm(),
                    self.iiccsc(),
                    self.iicackt()
                )
            }
        }
        #[doc = "IIC Mode Register 3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Simr3(pub u8);
        impl Simr3 {
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub const fn iicstareq(&self) -> super::vals::Iicstareq {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicstareq::from_bits(val as u8)
            }
            #[doc = "Start Condition Generation"]
            #[inline(always)]
            pub fn set_iicstareq(&mut self, val: super::vals::Iicstareq) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub const fn iicrstareq(&self) -> super::vals::Iicrstareq {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Iicrstareq::from_bits(val as u8)
            }
            #[doc = "Restart Condition Generation"]
            #[inline(always)]
            pub fn set_iicrstareq(&mut self, val: super::vals::Iicrstareq) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub const fn iicstpreq(&self) -> super::vals::Iicstpreq {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Iicstpreq::from_bits(val as u8)
            }
            #[doc = "Stop Condition Generation"]
            #[inline(always)]
            pub fn set_iicstpreq(&mut self, val: super::vals::Iicstpreq) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag"]
            #[inline(always)]
            pub const fn iicstif(&self) -> super::vals::Iicstif {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Iicstif::from_bits(val as u8)
            }
            #[doc = "Issuing of Start, Restart, or Stop Condition Completed Flag"]
            #[inline(always)]
            pub fn set_iicstif(&mut self, val: super::vals::Iicstif) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SDAn Output Select"]
            #[inline(always)]
            pub const fn iicsdas(&self) -> super::vals::Iicsdas {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Iicsdas::from_bits(val as u8)
            }
            #[doc = "SDAn Output Select"]
            #[inline(always)]
            pub fn set_iicsdas(&mut self, val: super::vals::Iicsdas) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u8) & 0x03) << 4usize);
            }
            #[doc = "SCLn Output Select"]
            #[inline(always)]
            pub const fn iicscls(&self) -> super::vals::Iicscls {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Iicscls::from_bits(val as u8)
            }
            #[doc = "SCLn Output Select"]
            #[inline(always)]
            pub fn set_iicscls(&mut self, val: super::vals::Iicscls) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u8) & 0x03) << 6usize);
            }
        }
        impl Default for Simr3 {
            #[inline(always)]
            fn default() -> Simr3 {
                Simr3(0)
            }
        }
        impl core::fmt::Debug for Simr3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Simr3")
                    .field("iicstareq", &self.iicstareq())
                    .field("iicrstareq", &self.iicrstareq())
                    .field("iicstpreq", &self.iicstpreq())
                    .field("iicstif", &self.iicstif())
                    .field("iicsdas", &self.iicsdas())
                    .field("iicscls", &self.iicscls())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Simr3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Simr3 {{ iicstareq: {:?}, iicrstareq: {:?}, iicstpreq: {:?}, iicstif: {:?}, iicsdas: {:?}, iicscls: {:?} }}" , self . iicstareq () , self . iicrstareq () , self . iicstpreq () , self . iicstif () , self . iicsdas () , self . iicscls ())
            }
        }
        #[doc = "IIC Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sisr(pub u8);
        impl Sisr {
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub const fn iicackr(&self) -> super::vals::Iicackr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iicackr::from_bits(val as u8)
            }
            #[doc = "ACK Reception Data Flag"]
            #[inline(always)]
            pub fn set_iicackr(&mut self, val: super::vals::Iicackr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sisr {
            #[inline(always)]
            fn default() -> Sisr {
                Sisr(0)
            }
        }
        impl core::fmt::Debug for Sisr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sisr")
                    .field("iicackr", &self.iicackr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sisr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sisr {{ iicackr: {:?} }}", self.iicackr())
            }
        }
        #[doc = "Serial Mode Register for Non,Smart Card Interface Mode (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Smr(pub u8);
        impl Smr {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Multi,Processor Mode"]
            #[inline(always)]
            pub const fn mp(&self) -> super::vals::Mp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mp::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Mode"]
            #[inline(always)]
            pub fn set_mp(&mut self, val: super::vals::Mp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Stop Bit Length"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop Bit Length"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn pe(&self) -> super::vals::Pe {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pe::from_bits(val as u8)
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: super::vals::Pe) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Character Length"]
            #[inline(always)]
            pub const fn chr(&self) -> super::vals::Chr {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Chr::from_bits(val as u8)
            }
            #[doc = "Character Length"]
            #[inline(always)]
            pub fn set_chr(&mut self, val: super::vals::Chr) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Communication Mode"]
            #[inline(always)]
            pub const fn cm(&self) -> super::vals::Cm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Cm::from_bits(val as u8)
            }
            #[doc = "Communication Mode"]
            #[inline(always)]
            pub fn set_cm(&mut self, val: super::vals::Cm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Smr {
            #[inline(always)]
            fn default() -> Smr {
                Smr(0)
            }
        }
        impl core::fmt::Debug for Smr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Smr")
                    .field("cks", &self.cks())
                    .field("mp", &self.mp())
                    .field("stop", &self.stop())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("chr", &self.chr())
                    .field("cm", &self.cm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Smr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Smr {{ cks: {:?}, mp: {:?}, stop: {:?}, pm: {:?}, pe: {:?}, chr: {:?}, cm: {:?} }}" , self . cks () , self . mp () , self . stop () , self . pm () , self . pe () , self . chr () , self . cm ())
            }
        }
        #[doc = "Serial Mode Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SmrSmci(pub u8);
        impl SmrSmci {
            #[doc = "Clock Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::SmrSmciCks {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::SmrSmciCks::from_bits(val as u8)
            }
            #[doc = "Clock Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::SmrSmciCks) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub const fn bcp(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Base Clock Pulse"]
            #[inline(always)]
            pub fn set_bcp(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u8) & 0x03) << 2usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn pm(&self) -> super::vals::SmrSmciPm {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SmrSmciPm::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_pm(&mut self, val: super::vals::SmrSmciPm) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn pe(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_pe(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u8) & 0x01) << 5usize);
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub const fn blk(&self) -> super::vals::Blk {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Blk::from_bits(val as u8)
            }
            #[doc = "Block Transfer Mode"]
            #[inline(always)]
            pub fn set_blk(&mut self, val: super::vals::Blk) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub const fn gm(&self) -> super::vals::Gm {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Gm::from_bits(val as u8)
            }
            #[doc = "GSM Mode"]
            #[inline(always)]
            pub fn set_gm(&mut self, val: super::vals::Gm) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SmrSmci {
            #[inline(always)]
            fn default() -> SmrSmci {
                SmrSmci(0)
            }
        }
        impl core::fmt::Debug for SmrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SmrSmci")
                    .field("cks", &self.cks())
                    .field("bcp", &self.bcp())
                    .field("pm", &self.pm())
                    .field("pe", &self.pe())
                    .field("blk", &self.blk())
                    .field("gm", &self.gm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SmrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SmrSmci {{ cks: {:?}, bcp: {=u8:?}, pm: {:?}, pe: {=bool:?}, blk: {:?}, gm: {:?} }}" , self . cks () , self . bcp () , self . pm () , self . pe () , self . blk () , self . gm ())
            }
        }
        #[doc = "Noise Filter Setting Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snfr(pub u8);
        impl Snfr {
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub const fn nfcs(&self) -> super::vals::Nfcs {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Nfcs::from_bits(val as u8)
            }
            #[doc = "Noise Filter Clock Select"]
            #[inline(always)]
            pub fn set_nfcs(&mut self, val: super::vals::Nfcs) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Snfr {
            #[inline(always)]
            fn default() -> Snfr {
                Snfr(0)
            }
        }
        impl core::fmt::Debug for Snfr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snfr").field("nfcs", &self.nfcs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snfr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Snfr {{ nfcs: {:?} }}", self.nfcs())
            }
        }
        #[doc = "SPI Mode Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spmr(pub u8);
        impl Spmr {
            #[doc = "SSn Pin Function Enable"]
            #[inline(always)]
            pub const fn sse(&self) -> super::vals::Sse {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sse::from_bits(val as u8)
            }
            #[doc = "SSn Pin Function Enable"]
            #[inline(always)]
            pub fn set_sse(&mut self, val: super::vals::Sse) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub const fn ctse(&self) -> super::vals::Ctse {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ctse::from_bits(val as u8)
            }
            #[doc = "CTS Enable"]
            #[inline(always)]
            pub fn set_ctse(&mut self, val: super::vals::Ctse) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub const fn mss(&self) -> super::vals::Mss {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Mss::from_bits(val as u8)
            }
            #[doc = "Master Slave Select"]
            #[inline(always)]
            pub fn set_mss(&mut self, val: super::vals::Mss) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub const fn mff(&self) -> super::vals::Mff {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mff::from_bits(val as u8)
            }
            #[doc = "Mode Fault Flag"]
            #[inline(always)]
            pub fn set_mff(&mut self, val: super::vals::Mff) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub const fn ckpol(&self) -> super::vals::Ckpol {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ckpol::from_bits(val as u8)
            }
            #[doc = "Clock Polarity Select"]
            #[inline(always)]
            pub fn set_ckpol(&mut self, val: super::vals::Ckpol) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub const fn ckph(&self) -> super::vals::Ckph {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ckph::from_bits(val as u8)
            }
            #[doc = "Clock Phase Select"]
            #[inline(always)]
            pub fn set_ckph(&mut self, val: super::vals::Ckph) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spmr {
            #[inline(always)]
            fn default() -> Spmr {
                Spmr(0)
            }
        }
        impl core::fmt::Debug for Spmr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spmr")
                    .field("sse", &self.sse())
                    .field("ctse", &self.ctse())
                    .field("mss", &self.mss())
                    .field("mff", &self.mff())
                    .field("ckpol", &self.ckpol())
                    .field("ckph", &self.ckph())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spmr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spmr {{ sse: {:?}, ctse: {:?}, mss: {:?}, mff: {:?}, ckpol: {:?}, ckph: {:?} }}" , self . sse () , self . ctse () , self . mss () , self . mff () , self . ckpol () , self . ckph ())
            }
        }
        #[doc = "Serial Port Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sptr(pub u8);
        impl Sptr {
            #[doc = "Serial Input Data Monitor"]
            #[inline(always)]
            pub const fn rxdmon(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Serial Input Data Monitor"]
            #[inline(always)]
            pub fn set_rxdmon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Serial Port Break Data Select"]
            #[inline(always)]
            pub const fn spb2dt(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Serial Port Break Data Select"]
            #[inline(always)]
            pub fn set_spb2dt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Serial Port Break I/O"]
            #[inline(always)]
            pub const fn spb2io(&self) -> super::vals::Spb2io {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spb2io::from_bits(val as u8)
            }
            #[doc = "Serial Port Break I/O"]
            #[inline(always)]
            pub fn set_spb2io(&mut self, val: super::vals::Spb2io) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Sptr {
            #[inline(always)]
            fn default() -> Sptr {
                Sptr(0)
            }
        }
        impl core::fmt::Debug for Sptr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sptr")
                    .field("rxdmon", &self.rxdmon())
                    .field("spb2dt", &self.spb2dt())
                    .field("spb2io", &self.spb2io())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sptr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sptr {{ rxdmon: {=bool:?}, spb2dt: {=bool:?}, spb2io: {:?} }}",
                    self.rxdmon(),
                    self.spb2dt(),
                    self.spb2io()
                )
            }
        }
        #[doc = "Serial Status Register for Non,Smart Card Interface (SCMR.SMIF = 0)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ssr(pub u8);
        impl Ssr {
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub const fn mpbt(&self) -> super::vals::Mpbt {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mpbt::from_bits(val as u8)
            }
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: super::vals::Mpbt) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub const fn mpb(&self) -> super::vals::Mpb {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Mpb::from_bits(val as u8)
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: super::vals::Mpb) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub const fn fer(&self) -> super::vals::Fer {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Fer::from_bits(val as u8)
            }
            #[doc = "Framing Error Flag"]
            #[inline(always)]
            pub fn set_fer(&mut self, val: super::vals::Fer) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ssr {
            #[inline(always)]
            fn default() -> Ssr {
                Ssr(0)
            }
        }
        impl core::fmt::Debug for Ssr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ssr")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("fer", &self.fer())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ssr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ssr {{ mpbt: {:?}, mpb: {:?}, tend: {:?}, per: {:?}, fer: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . fer () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Serial Status Register for Smart Card Interface Mode (SCMR.SMIF = 1)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SsrSmci(pub u8);
        impl SsrSmci {
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub const fn mpbt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor Bit Transfer"]
            #[inline(always)]
            pub fn set_mpbt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u8) & 0x01) << 0usize);
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub const fn mpb(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Multi,Processor"]
            #[inline(always)]
            pub fn set_mpb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u8) & 0x01) << 1usize);
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub const fn tend(&self) -> super::vals::SsrSmciTend {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::SsrSmciTend::from_bits(val as u8)
            }
            #[doc = "Transmit End Flag"]
            #[inline(always)]
            pub fn set_tend(&mut self, val: super::vals::SsrSmciTend) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn per(&self) -> super::vals::SsrSmciPer {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::SsrSmciPer::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_per(&mut self, val: super::vals::SsrSmciPer) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub const fn ers(&self) -> super::vals::Ers {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ers::from_bits(val as u8)
            }
            #[doc = "Error Signal Status Flag"]
            #[inline(always)]
            pub fn set_ers(&mut self, val: super::vals::Ers) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn orer(&self) -> super::vals::SsrSmciOrer {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::SsrSmciOrer::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_orer(&mut self, val: super::vals::SsrSmciOrer) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub const fn rdrf(&self) -> super::vals::SsrSmciRdrf {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::SsrSmciRdrf::from_bits(val as u8)
            }
            #[doc = "Receive Data Full Flag"]
            #[inline(always)]
            pub fn set_rdrf(&mut self, val: super::vals::SsrSmciRdrf) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub const fn tdre(&self) -> super::vals::SsrSmciTdre {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::SsrSmciTdre::from_bits(val as u8)
            }
            #[doc = "Transmit Data Empty Flag"]
            #[inline(always)]
            pub fn set_tdre(&mut self, val: super::vals::SsrSmciTdre) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for SsrSmci {
            #[inline(always)]
            fn default() -> SsrSmci {
                SsrSmci(0)
            }
        }
        impl core::fmt::Debug for SsrSmci {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SsrSmci")
                    .field("mpbt", &self.mpbt())
                    .field("mpb", &self.mpb())
                    .field("tend", &self.tend())
                    .field("per", &self.per())
                    .field("ers", &self.ers())
                    .field("orer", &self.orer())
                    .field("rdrf", &self.rdrf())
                    .field("tdre", &self.tdre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SsrSmci {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SsrSmci {{ mpbt: {=bool:?}, mpb: {=bool:?}, tend: {:?}, per: {:?}, ers: {:?}, orer: {:?}, rdrf: {:?}, tdre: {:?} }}" , self . mpbt () , self . mpb () , self . tend () , self . per () , self . ers () , self . orer () , self . rdrf () , self . tdre ())
            }
        }
        #[doc = "Transmit Data Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tdrhl(pub u16);
        impl Tdrhl {
            #[doc = "Serial Transmit Data"]
            #[inline(always)]
            pub const fn tdat(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Serial Transmit Data"]
            #[inline(always)]
            pub fn set_tdat(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u16) & 0x01ff) << 0usize);
            }
        }
        impl Default for Tdrhl {
            #[inline(always)]
            fn default() -> Tdrhl {
                Tdrhl(0)
            }
        }
        impl core::fmt::Debug for Tdrhl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tdrhl").field("tdat", &self.tdat()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tdrhl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tdrhl {{ tdat: {=u16:?} }}", self.tdat())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcs {
            #[inline(always)]
            fn from(val: u8) -> Abcs {
                Abcs::from_bits(val)
            }
        }
        impl From<Abcs> for u8 {
            #[inline(always)]
            fn from(val: Abcs) -> u8 {
                Abcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Abcse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Abcse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Abcse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Abcse {
            #[inline(always)]
            fn from(val: u8) -> Abcse {
                Abcse::from_bits(val)
            }
        }
        impl From<Abcse> for u8 {
            #[inline(always)]
            fn from(val: Abcse) -> u8 {
                Abcse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bgdm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bgdm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bgdm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bgdm {
            #[inline(always)]
            fn from(val: u8) -> Bgdm {
                Bgdm::from_bits(val)
            }
        }
        impl From<Bgdm> for u8 {
            #[inline(always)]
            fn from(val: Bgdm) -> u8 {
                Bgdm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blk {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Blk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blk {
            #[inline(always)]
            fn from(val: u8) -> Blk {
                Blk::from_bits(val)
            }
        }
        impl From<Blk> for u8 {
            #[inline(always)]
            fn from(val: Blk) -> u8 {
                Blk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Brme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brme {
            #[inline(always)]
            fn from(val: u8) -> Brme {
                Brme::from_bits(val)
            }
        }
        impl From<Brme> for u8 {
            #[inline(always)]
            fn from(val: Brme) -> u8 {
                Brme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr {
            #[inline(always)]
            fn from(val: u8) -> Chr {
                Chr::from_bits(val)
            }
        }
        impl From<Chr> for u8 {
            #[inline(always)]
            fn from(val: Chr) -> u8 {
                Chr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chr1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Chr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chr1 {
            #[inline(always)]
            fn from(val: u8) -> Chr1 {
                Chr1::from_bits(val)
            }
        }
        impl From<Chr1> for u8 {
            #[inline(always)]
            fn from(val: Chr1) -> u8 {
                Chr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckph {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckph {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckph {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckph {
            #[inline(always)]
            fn from(val: u8) -> Ckph {
                Ckph::from_bits(val)
            }
        }
        impl From<Ckph> for u8 {
            #[inline(always)]
            fn from(val: Ckph) -> u8 {
                Ckph::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckpol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckpol {
            #[inline(always)]
            fn from(val: u8) -> Ckpol {
                Ckpol::from_bits(val)
            }
        }
        impl From<Ckpol> for u8 {
            #[inline(always)]
            fn from(val: Ckpol) -> u8 {
                Ckpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cm {
            #[inline(always)]
            fn from(val: u8) -> Cm {
                Cm::from_bits(val)
            }
        }
        impl From<Cm> for u8 {
            #[inline(always)]
            fn from(val: Cm) -> u8 {
                Cm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ctse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctse {
            #[inline(always)]
            fn from(val: u8) -> Ctse {
                Ctse::from_bits(val)
            }
        }
        impl From<Ctse> for u8 {
            #[inline(always)]
            fn from(val: Ctse) -> u8 {
                Ctse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcme {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcme {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcme {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcme {
            #[inline(always)]
            fn from(val: u8) -> Dcme {
                Dcme::from_bits(val)
            }
        }
        impl From<Dcme> for u8 {
            #[inline(always)]
            fn from(val: Dcme) -> u8 {
                Dcme::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dcmf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dcmf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dcmf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dcmf {
            #[inline(always)]
            fn from(val: u8) -> Dcmf {
                Dcmf::from_bits(val)
            }
        }
        impl From<Dcmf> for u8 {
            #[inline(always)]
            fn from(val: Dcmf) -> u8 {
                Dcmf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dfer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfer {
            #[inline(always)]
            fn from(val: u8) -> Dfer {
                Dfer::from_bits(val)
            }
        }
        impl From<Dfer> for u8 {
            #[inline(always)]
            fn from(val: Dfer) -> u8 {
                Dfer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dper {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dper {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dper {
            #[inline(always)]
            fn from(val: u8) -> Dper {
                Dper::from_bits(val)
            }
        }
        impl From<Dper> for u8 {
            #[inline(always)]
            fn from(val: Dper) -> u8 {
                Dper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ers {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ers {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ers {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ers {
            #[inline(always)]
            fn from(val: u8) -> Ers {
                Ers::from_bits(val)
            }
        }
        impl From<Ers> for u8 {
            #[inline(always)]
            fn from(val: Ers) -> u8 {
                Ers::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Fer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fer {
            #[inline(always)]
            fn from(val: u8) -> Fer {
                Fer::from_bits(val)
            }
        }
        impl From<Fer> for u8 {
            #[inline(always)]
            fn from(val: Fer) -> u8 {
                Fer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Gm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gm {
            #[inline(always)]
            fn from(val: u8) -> Gm {
                Gm::from_bits(val)
            }
        }
        impl From<Gm> for u8 {
            #[inline(always)]
            fn from(val: Gm) -> u8 {
                Gm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idsel {
            #[inline(always)]
            fn from(val: u8) -> Idsel {
                Idsel::from_bits(val)
            }
        }
        impl From<Idsel> for u8 {
            #[inline(always)]
            fn from(val: Idsel) -> u8 {
                Idsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackr {
            #[inline(always)]
            fn from(val: u8) -> Iicackr {
                Iicackr::from_bits(val)
            }
        }
        impl From<Iicackr> for u8 {
            #[inline(always)]
            fn from(val: Iicackr) -> u8 {
                Iicackr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicackt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicackt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicackt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicackt {
            #[inline(always)]
            fn from(val: u8) -> Iicackt {
                Iicackt::from_bits(val)
            }
        }
        impl From<Iicackt> for u8 {
            #[inline(always)]
            fn from(val: Iicackt) -> u8 {
                Iicackt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iiccsc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iiccsc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iiccsc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iiccsc {
            #[inline(always)]
            fn from(val: u8) -> Iiccsc {
                Iiccsc::from_bits(val)
            }
        }
        impl From<Iiccsc> for u8 {
            #[inline(always)]
            fn from(val: Iiccsc) -> u8 {
                Iiccsc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicdl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Iicdl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicdl {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicdl {
            #[inline(always)]
            fn from(val: u8) -> Iicdl {
                Iicdl::from_bits(val)
            }
        }
        impl From<Iicdl> for u8 {
            #[inline(always)]
            fn from(val: Iicdl) -> u8 {
                Iicdl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicintm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicintm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicintm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicintm {
            #[inline(always)]
            fn from(val: u8) -> Iicintm {
                Iicintm::from_bits(val)
            }
        }
        impl From<Iicintm> for u8 {
            #[inline(always)]
            fn from(val: Iicintm) -> u8 {
                Iicintm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicm {
            #[inline(always)]
            fn from(val: u8) -> Iicm {
                Iicm::from_bits(val)
            }
        }
        impl From<Iicm> for u8 {
            #[inline(always)]
            fn from(val: Iicm) -> u8 {
                Iicm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicrstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicrstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicrstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicrstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicrstareq {
                Iicrstareq::from_bits(val)
            }
        }
        impl From<Iicrstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicrstareq) -> u8 {
                Iicrstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicscls {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicscls {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicscls {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicscls {
            #[inline(always)]
            fn from(val: u8) -> Iicscls {
                Iicscls::from_bits(val)
            }
        }
        impl From<Iicscls> for u8 {
            #[inline(always)]
            fn from(val: Iicscls) -> u8 {
                Iicscls::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicsdas {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Iicsdas {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicsdas {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicsdas {
            #[inline(always)]
            fn from(val: u8) -> Iicsdas {
                Iicsdas::from_bits(val)
            }
        }
        impl From<Iicsdas> for u8 {
            #[inline(always)]
            fn from(val: Iicsdas) -> u8 {
                Iicsdas::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstareq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstareq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstareq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstareq {
            #[inline(always)]
            fn from(val: u8) -> Iicstareq {
                Iicstareq::from_bits(val)
            }
        }
        impl From<Iicstareq> for u8 {
            #[inline(always)]
            fn from(val: Iicstareq) -> u8 {
                Iicstareq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstif {
            #[inline(always)]
            fn from(val: u8) -> Iicstif {
                Iicstif::from_bits(val)
            }
        }
        impl From<Iicstif> for u8 {
            #[inline(always)]
            fn from(val: Iicstif) -> u8 {
                Iicstif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iicstpreq {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iicstpreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iicstpreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iicstpreq {
            #[inline(always)]
            fn from(val: u8) -> Iicstpreq {
                Iicstpreq::from_bits(val)
            }
        }
        impl From<Iicstpreq> for u8 {
            #[inline(always)]
            fn from(val: Iicstpreq) -> u8 {
                Iicstpreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mff {
            #[inline(always)]
            fn from(val: u8) -> Mff {
                Mff::from_bits(val)
            }
        }
        impl From<Mff> for u8 {
            #[inline(always)]
            fn from(val: Mff) -> u8 {
                Mff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mp {
            #[inline(always)]
            fn from(val: u8) -> Mp {
                Mp::from_bits(val)
            }
        }
        impl From<Mp> for u8 {
            #[inline(always)]
            fn from(val: Mp) -> u8 {
                Mp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpb {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpb {
            #[inline(always)]
            fn from(val: u8) -> Mpb {
                Mpb::from_bits(val)
            }
        }
        impl From<Mpb> for u8 {
            #[inline(always)]
            fn from(val: Mpb) -> u8 {
                Mpb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpbt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpbt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpbt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpbt {
            #[inline(always)]
            fn from(val: u8) -> Mpbt {
                Mpbt::from_bits(val)
            }
        }
        impl From<Mpbt> for u8 {
            #[inline(always)]
            fn from(val: Mpbt) -> u8 {
                Mpbt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpie {
            #[inline(always)]
            fn from(val: u8) -> Mpie {
                Mpie::from_bits(val)
            }
        }
        impl From<Mpie> for u8 {
            #[inline(always)]
            fn from(val: Mpie) -> u8 {
                Mpie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mss {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mss {
            #[inline(always)]
            fn from(val: u8) -> Mss {
                Mss::from_bits(val)
            }
        }
        impl From<Mss> for u8 {
            #[inline(always)]
            fn from(val: Mss) -> u8 {
                Mss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Nfcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcs {
            #[inline(always)]
            fn from(val: u8) -> Nfcs {
                Nfcs::from_bits(val)
            }
        }
        impl From<Nfcs> for u8 {
            #[inline(always)]
            fn from(val: Nfcs) -> u8 {
                Nfcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Nfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfen {
            #[inline(always)]
            fn from(val: u8) -> Nfen {
                Nfen::from_bits(val)
            }
        }
        impl From<Nfen> for u8 {
            #[inline(always)]
            fn from(val: Nfen) -> u8 {
                Nfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pe {
            #[inline(always)]
            fn from(val: u8) -> Pe {
                Pe::from_bits(val)
            }
        }
        impl From<Pe> for u8 {
            #[inline(always)]
            fn from(val: Pe) -> u8 {
                Pe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxdesel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rxdesel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxdesel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxdesel {
            #[inline(always)]
            fn from(val: u8) -> Rxdesel {
                Rxdesel::from_bits(val)
            }
        }
        impl From<Rxdesel> for u8 {
            #[inline(always)]
            fn from(val: Rxdesel) -> u8 {
                Rxdesel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrCke {
            #[inline(always)]
            fn from(val: u8) -> ScrCke {
                ScrCke::from_bits(val)
            }
        }
        impl From<ScrCke> for u8 {
            #[inline(always)]
            fn from(val: ScrCke) -> u8 {
                ScrCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRe {
            #[inline(always)]
            fn from(val: u8) -> ScrRe {
                ScrRe::from_bits(val)
            }
        }
        impl From<ScrRe> for u8 {
            #[inline(always)]
            fn from(val: ScrRe) -> u8 {
                ScrRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrRie {
            #[inline(always)]
            fn from(val: u8) -> ScrRie {
                ScrRie::from_bits(val)
            }
        }
        impl From<ScrRie> for u8 {
            #[inline(always)]
            fn from(val: ScrRie) -> u8 {
                ScrRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciCke {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ScrSmciCke {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciCke {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciCke {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciCke {
                ScrSmciCke::from_bits(val)
            }
        }
        impl From<ScrSmciCke> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciCke) -> u8 {
                ScrSmciCke::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRe {
                ScrSmciRe::from_bits(val)
            }
        }
        impl From<ScrSmciRe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRe) -> u8 {
                ScrSmciRe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciRie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciRie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciRie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciRie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciRie {
                ScrSmciRie::from_bits(val)
            }
        }
        impl From<ScrSmciRie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciRie) -> u8 {
                ScrSmciRie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTe {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTe {
                ScrSmciTe::from_bits(val)
            }
        }
        impl From<ScrSmciTe> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTe) -> u8 {
                ScrSmciTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrSmciTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrSmciTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrSmciTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrSmciTie {
            #[inline(always)]
            fn from(val: u8) -> ScrSmciTie {
                ScrSmciTie::from_bits(val)
            }
        }
        impl From<ScrSmciTie> for u8 {
            #[inline(always)]
            fn from(val: ScrSmciTie) -> u8 {
                ScrSmciTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTe {
            #[inline(always)]
            fn from(val: u8) -> ScrTe {
                ScrTe::from_bits(val)
            }
        }
        impl From<ScrTe> for u8 {
            #[inline(always)]
            fn from(val: ScrTe) -> u8 {
                ScrTe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ScrTie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl ScrTie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ScrTie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ScrTie {
            #[inline(always)]
            fn from(val: u8) -> ScrTie {
                ScrTie::from_bits(val)
            }
        }
        impl From<ScrTie> for u8 {
            #[inline(always)]
            fn from(val: ScrTie) -> u8 {
                ScrTie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sdir {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sdir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sdir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sdir {
            #[inline(always)]
            fn from(val: u8) -> Sdir {
                Sdir::from_bits(val)
            }
        }
        impl From<Sdir> for u8 {
            #[inline(always)]
            fn from(val: Sdir) -> u8 {
                Sdir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sinv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sinv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sinv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sinv {
            #[inline(always)]
            fn from(val: u8) -> Sinv {
                Sinv::from_bits(val)
            }
        }
        impl From<Sinv> for u8 {
            #[inline(always)]
            fn from(val: Sinv) -> u8 {
                Sinv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Smif {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Smif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Smif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Smif {
            #[inline(always)]
            fn from(val: u8) -> Smif {
                Smif::from_bits(val)
            }
        }
        impl From<Smif> for u8 {
            #[inline(always)]
            fn from(val: Smif) -> u8 {
                Smif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrCks {
            #[inline(always)]
            fn from(val: u8) -> SmrCks {
                SmrCks::from_bits(val)
            }
        }
        impl From<SmrCks> for u8 {
            #[inline(always)]
            fn from(val: SmrCks) -> u8 {
                SmrCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrPm {
            #[inline(always)]
            fn from(val: u8) -> SmrPm {
                SmrPm::from_bits(val)
            }
        }
        impl From<SmrPm> for u8 {
            #[inline(always)]
            fn from(val: SmrPm) -> u8 {
                SmrPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciCks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl SmrSmciCks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciCks {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciCks {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciCks {
                SmrSmciCks::from_bits(val)
            }
        }
        impl From<SmrSmciCks> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciCks) -> u8 {
                SmrSmciCks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SmrSmciPm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SmrSmciPm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SmrSmciPm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SmrSmciPm {
            #[inline(always)]
            fn from(val: u8) -> SmrSmciPm {
                SmrSmciPm::from_bits(val)
            }
        }
        impl From<SmrSmciPm> for u8 {
            #[inline(always)]
            fn from(val: SmrSmciPm) -> u8 {
                SmrSmciPm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb2io {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spb2io {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb2io {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb2io {
            #[inline(always)]
            fn from(val: u8) -> Spb2io {
                Spb2io::from_bits(val)
            }
        }
        impl From<Spb2io> for u8 {
            #[inline(always)]
            fn from(val: Spb2io) -> u8 {
                Spb2io::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sse {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sse {
            #[inline(always)]
            fn from(val: u8) -> Sse {
                Sse::from_bits(val)
            }
        }
        impl From<Sse> for u8 {
            #[inline(always)]
            fn from(val: Sse) -> u8 {
                Sse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrOrer {
                SsrOrer::from_bits(val)
            }
        }
        impl From<SsrOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrOrer) -> u8 {
                SsrOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrPer {
            #[inline(always)]
            fn from(val: u8) -> SsrPer {
                SsrPer::from_bits(val)
            }
        }
        impl From<SsrPer> for u8 {
            #[inline(always)]
            fn from(val: SsrPer) -> u8 {
                SsrPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrRdrf {
                SsrRdrf::from_bits(val)
            }
        }
        impl From<SsrRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrRdrf) -> u8 {
                SsrRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciOrer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciOrer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciOrer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciOrer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciOrer {
                SsrSmciOrer::from_bits(val)
            }
        }
        impl From<SsrSmciOrer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciOrer) -> u8 {
                SsrSmciOrer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciPer {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciPer {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciPer {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciPer {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciPer {
                SsrSmciPer::from_bits(val)
            }
        }
        impl From<SsrSmciPer> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciPer) -> u8 {
                SsrSmciPer::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciRdrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciRdrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciRdrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciRdrf {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciRdrf {
                SsrSmciRdrf::from_bits(val)
            }
        }
        impl From<SsrSmciRdrf> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciRdrf) -> u8 {
                SsrSmciRdrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTdre {
                SsrSmciTdre::from_bits(val)
            }
        }
        impl From<SsrSmciTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTdre) -> u8 {
                SsrSmciTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrSmciTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrSmciTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrSmciTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrSmciTend {
            #[inline(always)]
            fn from(val: u8) -> SsrSmciTend {
                SsrSmciTend::from_bits(val)
            }
        }
        impl From<SsrSmciTend> for u8 {
            #[inline(always)]
            fn from(val: SsrSmciTend) -> u8 {
                SsrSmciTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTdre {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTdre {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTdre {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTdre {
            #[inline(always)]
            fn from(val: u8) -> SsrTdre {
                SsrTdre::from_bits(val)
            }
        }
        impl From<SsrTdre> for u8 {
            #[inline(always)]
            fn from(val: SsrTdre) -> u8 {
                SsrTdre::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SsrTend {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl SsrTend {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SsrTend {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SsrTend {
            #[inline(always)]
            fn from(val: u8) -> SsrTend {
                SsrTend::from_bits(val)
            }
        }
        impl From<SsrTend> for u8 {
            #[inline(always)]
            fn from(val: SsrTend) -> u8 {
                SsrTend::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Teie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Teie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Teie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Teie {
            #[inline(always)]
            fn from(val: u8) -> Teie {
                Teie::from_bits(val)
            }
        }
        impl From<Teie> for u8 {
            #[inline(always)]
            fn from(val: Teie) -> u8 {
                Teie::to_bits(val)
            }
        }
    }
}
pub mod spi0 {
    #[doc = "Serial Peripheral Interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spi0 {
        ptr: *mut u8,
    }
    unsafe impl Send for Spi0 {}
    unsafe impl Sync for Spi0 {}
    impl Spi0 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SPI Control Register"]
        #[inline(always)]
        pub const fn spcr(self) -> crate::common::Reg<regs::Spcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SPI Slave Select Polarity Register"]
        #[inline(always)]
        pub const fn sslp(self) -> crate::common::Reg<regs::Sslp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01usize) as _) }
        }
        #[doc = "SPI Pin Control Register"]
        #[inline(always)]
        pub const fn sppcr(self) -> crate::common::Reg<regs::Sppcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "SPI Status Register"]
        #[inline(always)]
        pub const fn spsr(self) -> crate::common::Reg<regs::Spsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03usize) as _) }
        }
        #[doc = "SPI Data Register"]
        #[inline(always)]
        pub const fn spdr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Data Register"]
        #[inline(always)]
        pub const fn spdr_by(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Data Register"]
        #[inline(always)]
        pub const fn spdr_ha(self) -> crate::common::Reg<u16, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "SPI Bit Rate Register"]
        #[inline(always)]
        pub const fn spbr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ausize) as _) }
        }
        #[doc = "SPI Data Control Register"]
        #[inline(always)]
        pub const fn spdcr(self) -> crate::common::Reg<regs::Spdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0busize) as _) }
        }
        #[doc = "SPI Clock Delay Register"]
        #[inline(always)]
        pub const fn spckd(self) -> crate::common::Reg<regs::Spckd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "SPI Slave Select Negation Delay Register"]
        #[inline(always)]
        pub const fn sslnd(self) -> crate::common::Reg<regs::Sslnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0dusize) as _) }
        }
        #[doc = "SPI Next,Access Delay Register"]
        #[inline(always)]
        pub const fn spnd(self) -> crate::common::Reg<regs::Spnd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eusize) as _) }
        }
        #[doc = "SPI Control Register 2"]
        #[inline(always)]
        pub const fn spcr2(self) -> crate::common::Reg<regs::Spcr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fusize) as _) }
        }
        #[doc = "SPI Command Register 0"]
        #[inline(always)]
        pub const fn spcmd0(self) -> crate::common::Reg<regs::Spcmd0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SPI Clock Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spckd(pub u8);
        impl Spckd {
            #[doc = "RSPCK Delay Setting"]
            #[inline(always)]
            pub const fn sckdl(&self) -> super::vals::Sckdl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Sckdl::from_bits(val as u8)
            }
            #[doc = "RSPCK Delay Setting"]
            #[inline(always)]
            pub fn set_sckdl(&mut self, val: super::vals::Sckdl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Spckd {
            #[inline(always)]
            fn default() -> Spckd {
                Spckd(0)
            }
        }
        impl core::fmt::Debug for Spckd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spckd")
                    .field("sckdl", &self.sckdl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spckd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Spckd {{ sckdl: {:?} }}", self.sckdl())
            }
        }
        #[doc = "SPI Command Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcmd0(pub u16);
        impl Spcmd0 {
            #[doc = "RSPCK Phase Setting"]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "RSPCK Phase Setting"]
            #[inline(always)]
            pub fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "RSPCK Polarity Setting"]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "RSPCK Polarity Setting"]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Bit Rate Division Setting"]
            #[inline(always)]
            pub const fn brdv(&self) -> super::vals::Brdv {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Brdv::from_bits(val as u8)
            }
            #[doc = "Bit Rate Division Setting"]
            #[inline(always)]
            pub fn set_brdv(&mut self, val: super::vals::Brdv) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u16) & 0x03) << 2usize);
            }
            #[doc = "SPI Data Length Setting"]
            #[inline(always)]
            pub const fn spb(&self) -> super::vals::Spb {
                let val = (self.0 >> 8usize) & 0x0f;
                super::vals::Spb::from_bits(val as u8)
            }
            #[doc = "SPI Data Length Setting"]
            #[inline(always)]
            pub fn set_spb(&mut self, val: super::vals::Spb) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u16) & 0x0f) << 8usize);
            }
            #[doc = "SPI LSB First"]
            #[inline(always)]
            pub const fn lsbf(&self) -> super::vals::Lsbf {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Lsbf::from_bits(val as u8)
            }
            #[doc = "SPI LSB First"]
            #[inline(always)]
            pub fn set_lsbf(&mut self, val: super::vals::Lsbf) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
            #[doc = "SPI Next,Access Delay Enable"]
            #[inline(always)]
            pub const fn spnden(&self) -> super::vals::Spnden {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Spnden::from_bits(val as u8)
            }
            #[doc = "SPI Next,Access Delay Enable"]
            #[inline(always)]
            pub fn set_spnden(&mut self, val: super::vals::Spnden) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u16) & 0x01) << 13usize);
            }
            #[doc = "SSL Negation Delay Setting Enable"]
            #[inline(always)]
            pub const fn slnden(&self) -> super::vals::Slnden {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Slnden::from_bits(val as u8)
            }
            #[doc = "SSL Negation Delay Setting Enable"]
            #[inline(always)]
            pub fn set_slnden(&mut self, val: super::vals::Slnden) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "RSPCK Delay Setting Enable"]
            #[inline(always)]
            pub const fn sckden(&self) -> super::vals::Sckden {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sckden::from_bits(val as u8)
            }
            #[doc = "RSPCK Delay Setting Enable"]
            #[inline(always)]
            pub fn set_sckden(&mut self, val: super::vals::Sckden) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Spcmd0 {
            #[inline(always)]
            fn default() -> Spcmd0 {
                Spcmd0(0)
            }
        }
        impl core::fmt::Debug for Spcmd0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcmd0")
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .field("brdv", &self.brdv())
                    .field("spb", &self.spb())
                    .field("lsbf", &self.lsbf())
                    .field("spnden", &self.spnden())
                    .field("slnden", &self.slnden())
                    .field("sckden", &self.sckden())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcmd0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spcmd0 {{ cpha: {:?}, cpol: {:?}, brdv: {:?}, spb: {:?}, lsbf: {:?}, spnden: {:?}, slnden: {:?}, sckden: {:?} }}" , self . cpha () , self . cpol () , self . brdv () , self . spb () , self . lsbf () , self . spnden () , self . slnden () , self . sckden ())
            }
        }
        #[doc = "SPI Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcr(pub u8);
        impl Spcr {
            #[doc = "SPI Mode Select"]
            #[inline(always)]
            pub const fn spms(&self) -> super::vals::Spms {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Spms::from_bits(val as u8)
            }
            #[doc = "SPI Mode Select"]
            #[inline(always)]
            pub fn set_spms(&mut self, val: super::vals::Spms) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Communications Operating Mode Select"]
            #[inline(always)]
            pub const fn txmd(&self) -> super::vals::Txmd {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Txmd::from_bits(val as u8)
            }
            #[doc = "Communications Operating Mode Select"]
            #[inline(always)]
            pub fn set_txmd(&mut self, val: super::vals::Txmd) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Mode Fault Error Detection Enable"]
            #[inline(always)]
            pub const fn modfen(&self) -> super::vals::Modfen {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Modfen::from_bits(val as u8)
            }
            #[doc = "Mode Fault Error Detection Enable"]
            #[inline(always)]
            pub fn set_modfen(&mut self, val: super::vals::Modfen) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "SPI Master/Slave Mode Select"]
            #[inline(always)]
            pub const fn mstr(&self) -> super::vals::Mstr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Mstr::from_bits(val as u8)
            }
            #[doc = "SPI Master/Slave Mode Select"]
            #[inline(always)]
            pub fn set_mstr(&mut self, val: super::vals::Mstr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "SPI Error Interrupt Enable"]
            #[inline(always)]
            pub const fn speie(&self) -> super::vals::Speie {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Speie::from_bits(val as u8)
            }
            #[doc = "SPI Error Interrupt Enable"]
            #[inline(always)]
            pub fn set_speie(&mut self, val: super::vals::Speie) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "Transmit Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub const fn sptie(&self) -> super::vals::Sptie {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Sptie::from_bits(val as u8)
            }
            #[doc = "Transmit Buffer Empty Interrupt Enable"]
            #[inline(always)]
            pub fn set_sptie(&mut self, val: super::vals::Sptie) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SPI Function Enable"]
            #[inline(always)]
            pub const fn spe(&self) -> super::vals::Spe {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Spe::from_bits(val as u8)
            }
            #[doc = "SPI Function Enable"]
            #[inline(always)]
            pub fn set_spe(&mut self, val: super::vals::Spe) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "SPI Receive Buffer Full Interrupt Enable"]
            #[inline(always)]
            pub const fn sprie(&self) -> super::vals::Sprie {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sprie::from_bits(val as u8)
            }
            #[doc = "SPI Receive Buffer Full Interrupt Enable"]
            #[inline(always)]
            pub fn set_sprie(&mut self, val: super::vals::Sprie) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spcr {
            #[inline(always)]
            fn default() -> Spcr {
                Spcr(0)
            }
        }
        impl core::fmt::Debug for Spcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcr")
                    .field("spms", &self.spms())
                    .field("txmd", &self.txmd())
                    .field("modfen", &self.modfen())
                    .field("mstr", &self.mstr())
                    .field("speie", &self.speie())
                    .field("sptie", &self.sptie())
                    .field("spe", &self.spe())
                    .field("sprie", &self.sprie())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spcr {{ spms: {:?}, txmd: {:?}, modfen: {:?}, mstr: {:?}, speie: {:?}, sptie: {:?}, spe: {:?}, sprie: {:?} }}" , self . spms () , self . txmd () , self . modfen () , self . mstr () , self . speie () , self . sptie () , self . spe () , self . sprie ())
            }
        }
        #[doc = "SPI Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spcr2(pub u8);
        impl Spcr2 {
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub const fn sppe(&self) -> super::vals::Sppe {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sppe::from_bits(val as u8)
            }
            #[doc = "Parity Enable"]
            #[inline(always)]
            pub fn set_sppe(&mut self, val: super::vals::Sppe) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub const fn spoe(&self) -> super::vals::Spoe {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Spoe::from_bits(val as u8)
            }
            #[doc = "Parity Mode"]
            #[inline(always)]
            pub fn set_spoe(&mut self, val: super::vals::Spoe) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "SPI Idle Interrupt Enable"]
            #[inline(always)]
            pub const fn spiie(&self) -> super::vals::Spiie {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Spiie::from_bits(val as u8)
            }
            #[doc = "SPI Idle Interrupt Enable"]
            #[inline(always)]
            pub fn set_spiie(&mut self, val: super::vals::Spiie) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Self,Testing"]
            #[inline(always)]
            pub const fn pte(&self) -> super::vals::Pte {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Pte::from_bits(val as u8)
            }
            #[doc = "Parity Self,Testing"]
            #[inline(always)]
            pub fn set_pte(&mut self, val: super::vals::Pte) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "RSPCK Auto,Stop Function Enable"]
            #[inline(always)]
            pub const fn sckase(&self) -> super::vals::Sckase {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sckase::from_bits(val as u8)
            }
            #[doc = "RSPCK Auto,Stop Function Enable"]
            #[inline(always)]
            pub fn set_sckase(&mut self, val: super::vals::Sckase) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Spcr2 {
            #[inline(always)]
            fn default() -> Spcr2 {
                Spcr2(0)
            }
        }
        impl core::fmt::Debug for Spcr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spcr2")
                    .field("sppe", &self.sppe())
                    .field("spoe", &self.spoe())
                    .field("spiie", &self.spiie())
                    .field("pte", &self.pte())
                    .field("sckase", &self.sckase())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spcr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Spcr2 {{ sppe: {:?}, spoe: {:?}, spiie: {:?}, pte: {:?}, sckase: {:?} }}",
                    self.sppe(),
                    self.spoe(),
                    self.spiie(),
                    self.pte(),
                    self.sckase()
                )
            }
        }
        #[doc = "SPI Data Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spdcr(pub u8);
        impl Spdcr {
            #[doc = "SPI Receive/Transmit Data Select"]
            #[inline(always)]
            pub const fn sprdtd(&self) -> super::vals::Sprdtd {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sprdtd::from_bits(val as u8)
            }
            #[doc = "SPI Receive/Transmit Data Select"]
            #[inline(always)]
            pub fn set_sprdtd(&mut self, val: super::vals::Sprdtd) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "SPI Word Access/Halfword Access Specification"]
            #[inline(always)]
            pub const fn splw(&self) -> super::vals::Splw {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Splw::from_bits(val as u8)
            }
            #[doc = "SPI Word Access/Halfword Access Specification"]
            #[inline(always)]
            pub fn set_splw(&mut self, val: super::vals::Splw) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SPI Byte Access Specification"]
            #[inline(always)]
            pub const fn spbyt(&self) -> super::vals::Spbyt {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Spbyt::from_bits(val as u8)
            }
            #[doc = "SPI Byte Access Specification"]
            #[inline(always)]
            pub fn set_spbyt(&mut self, val: super::vals::Spbyt) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Spdcr {
            #[inline(always)]
            fn default() -> Spdcr {
                Spdcr(0)
            }
        }
        impl core::fmt::Debug for Spdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spdcr")
                    .field("sprdtd", &self.sprdtd())
                    .field("splw", &self.splw())
                    .field("spbyt", &self.spbyt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Spdcr {{ sprdtd: {:?}, splw: {:?}, spbyt: {:?} }}",
                    self.sprdtd(),
                    self.splw(),
                    self.spbyt()
                )
            }
        }
        #[doc = "SPI Next,Access Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spnd(pub u8);
        impl Spnd {
            #[doc = "SPI Next,Access Delay Setting"]
            #[inline(always)]
            pub const fn spndl(&self) -> super::vals::Spndl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Spndl::from_bits(val as u8)
            }
            #[doc = "SPI Next,Access Delay Setting"]
            #[inline(always)]
            pub fn set_spndl(&mut self, val: super::vals::Spndl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Spnd {
            #[inline(always)]
            fn default() -> Spnd {
                Spnd(0)
            }
        }
        impl core::fmt::Debug for Spnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spnd")
                    .field("spndl", &self.spndl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Spnd {{ spndl: {:?} }}", self.spndl())
            }
        }
        #[doc = "SPI Pin Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sppcr(pub u8);
        impl Sppcr {
            #[doc = "SPI Loopback"]
            #[inline(always)]
            pub const fn splp(&self) -> super::vals::Splp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Splp::from_bits(val as u8)
            }
            #[doc = "SPI Loopback"]
            #[inline(always)]
            pub fn set_splp(&mut self, val: super::vals::Splp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SPI Loopback 2"]
            #[inline(always)]
            pub const fn splp2(&self) -> super::vals::Splp2 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Splp2::from_bits(val as u8)
            }
            #[doc = "SPI Loopback 2"]
            #[inline(always)]
            pub fn set_splp2(&mut self, val: super::vals::Splp2) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "MOSI Idle Fixed Value"]
            #[inline(always)]
            pub const fn moifv(&self) -> super::vals::Moifv {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Moifv::from_bits(val as u8)
            }
            #[doc = "MOSI Idle Fixed Value"]
            #[inline(always)]
            pub fn set_moifv(&mut self, val: super::vals::Moifv) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "MOSI Idle Value Fixing Enable"]
            #[inline(always)]
            pub const fn moife(&self) -> super::vals::Moife {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Moife::from_bits(val as u8)
            }
            #[doc = "MOSI Idle Value Fixing Enable"]
            #[inline(always)]
            pub fn set_moife(&mut self, val: super::vals::Moife) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
        }
        impl Default for Sppcr {
            #[inline(always)]
            fn default() -> Sppcr {
                Sppcr(0)
            }
        }
        impl core::fmt::Debug for Sppcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sppcr")
                    .field("splp", &self.splp())
                    .field("splp2", &self.splp2())
                    .field("moifv", &self.moifv())
                    .field("moife", &self.moife())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sppcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sppcr {{ splp: {:?}, splp2: {:?}, moifv: {:?}, moife: {:?} }}",
                    self.splp(),
                    self.splp2(),
                    self.moifv(),
                    self.moife()
                )
            }
        }
        #[doc = "SPI Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Spsr(pub u8);
        impl Spsr {
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub const fn ovrf(&self) -> super::vals::Ovrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ovrf::from_bits(val as u8)
            }
            #[doc = "Overrun Error Flag"]
            #[inline(always)]
            pub fn set_ovrf(&mut self, val: super::vals::Ovrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "SPI Idle Flag"]
            #[inline(always)]
            pub const fn idlnf(&self) -> super::vals::Idlnf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Idlnf::from_bits(val as u8)
            }
            #[doc = "SPI Idle Flag"]
            #[inline(always)]
            pub fn set_idlnf(&mut self, val: super::vals::Idlnf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Mode Fault Error Flag"]
            #[inline(always)]
            pub const fn modf(&self) -> super::vals::Modf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Modf::from_bits(val as u8)
            }
            #[doc = "Mode Fault Error Flag"]
            #[inline(always)]
            pub fn set_modf(&mut self, val: super::vals::Modf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub const fn perf(&self) -> super::vals::Perf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Perf::from_bits(val as u8)
            }
            #[doc = "Parity Error Flag"]
            #[inline(always)]
            pub fn set_perf(&mut self, val: super::vals::Perf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Underrun Error Flag"]
            #[inline(always)]
            pub const fn udrf(&self) -> super::vals::Udrf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Udrf::from_bits(val as u8)
            }
            #[doc = "Underrun Error Flag"]
            #[inline(always)]
            pub fn set_udrf(&mut self, val: super::vals::Udrf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
            #[doc = "SPI Transmit Buffer Empty Flag"]
            #[inline(always)]
            pub const fn sptef(&self) -> super::vals::Sptef {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Sptef::from_bits(val as u8)
            }
            #[doc = "SPI Transmit Buffer Empty Flag"]
            #[inline(always)]
            pub fn set_sptef(&mut self, val: super::vals::Sptef) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "SPI Receive Buffer Full Flag"]
            #[inline(always)]
            pub const fn sprf(&self) -> super::vals::Sprf {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Sprf::from_bits(val as u8)
            }
            #[doc = "SPI Receive Buffer Full Flag"]
            #[inline(always)]
            pub fn set_sprf(&mut self, val: super::vals::Sprf) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Spsr {
            #[inline(always)]
            fn default() -> Spsr {
                Spsr(0)
            }
        }
        impl core::fmt::Debug for Spsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Spsr")
                    .field("ovrf", &self.ovrf())
                    .field("idlnf", &self.idlnf())
                    .field("modf", &self.modf())
                    .field("perf", &self.perf())
                    .field("udrf", &self.udrf())
                    .field("sptef", &self.sptef())
                    .field("sprf", &self.sprf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Spsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Spsr {{ ovrf: {:?}, idlnf: {:?}, modf: {:?}, perf: {:?}, udrf: {:?}, sptef: {:?}, sprf: {:?} }}" , self . ovrf () , self . idlnf () , self . modf () , self . perf () , self . udrf () , self . sptef () , self . sprf ())
            }
        }
        #[doc = "SPI Slave Select Negation Delay Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sslnd(pub u8);
        impl Sslnd {
            #[doc = "SSL Negation Delay Setting"]
            #[inline(always)]
            pub const fn slndl(&self) -> super::vals::Slndl {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Slndl::from_bits(val as u8)
            }
            #[doc = "SSL Negation Delay Setting"]
            #[inline(always)]
            pub fn set_slndl(&mut self, val: super::vals::Slndl) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Sslnd {
            #[inline(always)]
            fn default() -> Sslnd {
                Sslnd(0)
            }
        }
        impl core::fmt::Debug for Sslnd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sslnd")
                    .field("slndl", &self.slndl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sslnd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sslnd {{ slndl: {:?} }}", self.slndl())
            }
        }
        #[doc = "SPI Slave Select Polarity Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sslp(pub u8);
        impl Sslp {
            #[doc = "SSLn0 Signal Polarity Setting"]
            #[inline(always)]
            pub const fn ssl0p(&self) -> super::vals::Ssl0p {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ssl0p::from_bits(val as u8)
            }
            #[doc = "SSLn0 Signal Polarity Setting"]
            #[inline(always)]
            pub fn set_ssl0p(&mut self, val: super::vals::Ssl0p) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Sslp {
            #[inline(always)]
            fn default() -> Sslp {
                Sslp(0)
            }
        }
        impl core::fmt::Debug for Sslp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sslp")
                    .field("ssl0p", &self.ssl0p())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sslp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sslp {{ ssl0p: {:?} }}", self.ssl0p())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Brdv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Brdv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Brdv {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Brdv {
            #[inline(always)]
            fn from(val: u8) -> Brdv {
                Brdv::from_bits(val)
            }
        }
        impl From<Brdv> for u8 {
            #[inline(always)]
            fn from(val: Brdv) -> u8 {
                Brdv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Idlnf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Idlnf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Idlnf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Idlnf {
            #[inline(always)]
            fn from(val: u8) -> Idlnf {
                Idlnf::from_bits(val)
            }
        }
        impl From<Idlnf> for u8 {
            #[inline(always)]
            fn from(val: Idlnf) -> u8 {
                Idlnf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lsbf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lsbf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lsbf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lsbf {
            #[inline(always)]
            fn from(val: u8) -> Lsbf {
                Lsbf::from_bits(val)
            }
        }
        impl From<Lsbf> for u8 {
            #[inline(always)]
            fn from(val: Lsbf) -> u8 {
                Lsbf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modf {
            #[inline(always)]
            fn from(val: u8) -> Modf {
                Modf::from_bits(val)
            }
        }
        impl From<Modf> for u8 {
            #[inline(always)]
            fn from(val: Modf) -> u8 {
                Modf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modfen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Modfen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modfen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modfen {
            #[inline(always)]
            fn from(val: u8) -> Modfen {
                Modfen::from_bits(val)
            }
        }
        impl From<Modfen> for u8 {
            #[inline(always)]
            fn from(val: Modfen) -> u8 {
                Modfen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moife {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moife {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moife {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moife {
            #[inline(always)]
            fn from(val: u8) -> Moife {
                Moife::from_bits(val)
            }
        }
        impl From<Moife> for u8 {
            #[inline(always)]
            fn from(val: Moife) -> u8 {
                Moife::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Moifv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Moifv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Moifv {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Moifv {
            #[inline(always)]
            fn from(val: u8) -> Moifv {
                Moifv::from_bits(val)
            }
        }
        impl From<Moifv> for u8 {
            #[inline(always)]
            fn from(val: Moifv) -> u8 {
                Moifv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstr {
            #[inline(always)]
            fn from(val: u8) -> Mstr {
                Mstr::from_bits(val)
            }
        }
        impl From<Mstr> for u8 {
            #[inline(always)]
            fn from(val: Mstr) -> u8 {
                Mstr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ovrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ovrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ovrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ovrf {
            #[inline(always)]
            fn from(val: u8) -> Ovrf {
                Ovrf::from_bits(val)
            }
        }
        impl From<Ovrf> for u8 {
            #[inline(always)]
            fn from(val: Ovrf) -> u8 {
                Ovrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Perf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Perf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Perf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Perf {
            #[inline(always)]
            fn from(val: u8) -> Perf {
                Perf::from_bits(val)
            }
        }
        impl From<Perf> for u8 {
            #[inline(always)]
            fn from(val: Perf) -> u8 {
                Perf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pte {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Pte {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pte {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pte {
            #[inline(always)]
            fn from(val: u8) -> Pte {
                Pte::from_bits(val)
            }
        }
        impl From<Pte> for u8 {
            #[inline(always)]
            fn from(val: Pte) -> u8 {
                Pte::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckase {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sckase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckase {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckase {
            #[inline(always)]
            fn from(val: u8) -> Sckase {
                Sckase::from_bits(val)
            }
        }
        impl From<Sckase> for u8 {
            #[inline(always)]
            fn from(val: Sckase) -> u8 {
                Sckase::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sckden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckden {
            #[inline(always)]
            fn from(val: u8) -> Sckden {
                Sckden::from_bits(val)
            }
        }
        impl From<Sckden> for u8 {
            #[inline(always)]
            fn from(val: Sckden) -> u8 {
                Sckden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckdl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sckdl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckdl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckdl {
            #[inline(always)]
            fn from(val: u8) -> Sckdl {
                Sckdl::from_bits(val)
            }
        }
        impl From<Sckdl> for u8 {
            #[inline(always)]
            fn from(val: Sckdl) -> u8 {
                Sckdl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slnden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Slnden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slnden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slnden {
            #[inline(always)]
            fn from(val: u8) -> Slnden {
                Slnden::from_bits(val)
            }
        }
        impl From<Slnden> for u8 {
            #[inline(always)]
            fn from(val: Slnden) -> u8 {
                Slnden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slndl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Slndl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slndl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slndl {
            #[inline(always)]
            fn from(val: u8) -> Slndl {
                Slndl::from_bits(val)
            }
        }
        impl From<Slndl> for u8 {
            #[inline(always)]
            fn from(val: Slndl) -> u8 {
                Slndl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Spb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spb {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spb {
            #[inline(always)]
            fn from(val: u8) -> Spb {
                Spb::from_bits(val)
            }
        }
        impl From<Spb> for u8 {
            #[inline(always)]
            fn from(val: Spb) -> u8 {
                Spb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spbyt {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spbyt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spbyt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spbyt {
            #[inline(always)]
            fn from(val: u8) -> Spbyt {
                Spbyt::from_bits(val)
            }
        }
        impl From<Spbyt> for u8 {
            #[inline(always)]
            fn from(val: Spbyt) -> u8 {
                Spbyt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spe {
            #[inline(always)]
            fn from(val: u8) -> Spe {
                Spe::from_bits(val)
            }
        }
        impl From<Spe> for u8 {
            #[inline(always)]
            fn from(val: Spe) -> u8 {
                Spe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Speie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Speie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Speie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Speie {
            #[inline(always)]
            fn from(val: u8) -> Speie {
                Speie::from_bits(val)
            }
        }
        impl From<Speie> for u8 {
            #[inline(always)]
            fn from(val: Speie) -> u8 {
                Speie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spiie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spiie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spiie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spiie {
            #[inline(always)]
            fn from(val: u8) -> Spiie {
                Spiie::from_bits(val)
            }
        }
        impl From<Spiie> for u8 {
            #[inline(always)]
            fn from(val: Spiie) -> u8 {
                Spiie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splp {
            #[inline(always)]
            fn from(val: u8) -> Splp {
                Splp::from_bits(val)
            }
        }
        impl From<Splp> for u8 {
            #[inline(always)]
            fn from(val: Splp) -> u8 {
                Splp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splp2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splp2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splp2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splp2 {
            #[inline(always)]
            fn from(val: u8) -> Splp2 {
                Splp2::from_bits(val)
            }
        }
        impl From<Splp2> for u8 {
            #[inline(always)]
            fn from(val: Splp2) -> u8 {
                Splp2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Splw {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Splw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Splw {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Splw {
            #[inline(always)]
            fn from(val: u8) -> Splw {
                Splw::from_bits(val)
            }
        }
        impl From<Splw> for u8 {
            #[inline(always)]
            fn from(val: Splw) -> u8 {
                Splw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spms {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spms {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spms {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spms {
            #[inline(always)]
            fn from(val: u8) -> Spms {
                Spms::from_bits(val)
            }
        }
        impl From<Spms> for u8 {
            #[inline(always)]
            fn from(val: Spms) -> u8 {
                Spms::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spnden {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spnden {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spnden {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spnden {
            #[inline(always)]
            fn from(val: u8) -> Spnden {
                Spnden::from_bits(val)
            }
        }
        impl From<Spnden> for u8 {
            #[inline(always)]
            fn from(val: Spnden) -> u8 {
                Spnden::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spndl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Spndl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spndl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spndl {
            #[inline(always)]
            fn from(val: u8) -> Spndl {
                Spndl::from_bits(val)
            }
        }
        impl From<Spndl> for u8 {
            #[inline(always)]
            fn from(val: Spndl) -> u8 {
                Spndl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Spoe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Spoe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Spoe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Spoe {
            #[inline(always)]
            fn from(val: u8) -> Spoe {
                Spoe::from_bits(val)
            }
        }
        impl From<Spoe> for u8 {
            #[inline(always)]
            fn from(val: Spoe) -> u8 {
                Spoe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sppe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sppe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sppe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sppe {
            #[inline(always)]
            fn from(val: u8) -> Sppe {
                Sppe::from_bits(val)
            }
        }
        impl From<Sppe> for u8 {
            #[inline(always)]
            fn from(val: Sppe) -> u8 {
                Sppe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprdtd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprdtd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprdtd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprdtd {
            #[inline(always)]
            fn from(val: u8) -> Sprdtd {
                Sprdtd::from_bits(val)
            }
        }
        impl From<Sprdtd> for u8 {
            #[inline(always)]
            fn from(val: Sprdtd) -> u8 {
                Sprdtd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprf {
            #[inline(always)]
            fn from(val: u8) -> Sprf {
                Sprf::from_bits(val)
            }
        }
        impl From<Sprf> for u8 {
            #[inline(always)]
            fn from(val: Sprf) -> u8 {
                Sprf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sprie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprie {
            #[inline(always)]
            fn from(val: u8) -> Sprie {
                Sprie::from_bits(val)
            }
        }
        impl From<Sprie> for u8 {
            #[inline(always)]
            fn from(val: Sprie) -> u8 {
                Sprie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sptef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sptef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sptef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sptef {
            #[inline(always)]
            fn from(val: u8) -> Sptef {
                Sptef::from_bits(val)
            }
        }
        impl From<Sptef> for u8 {
            #[inline(always)]
            fn from(val: Sptef) -> u8 {
                Sptef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sptie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sptie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sptie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sptie {
            #[inline(always)]
            fn from(val: u8) -> Sptie {
                Sptie::from_bits(val)
            }
        }
        impl From<Sptie> for u8 {
            #[inline(always)]
            fn from(val: Sptie) -> u8 {
                Sptie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssl0p {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssl0p {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssl0p {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssl0p {
            #[inline(always)]
            fn from(val: u8) -> Ssl0p {
                Ssl0p::from_bits(val)
            }
        }
        impl From<Ssl0p> for u8 {
            #[inline(always)]
            fn from(val: Ssl0p) -> u8 {
                Ssl0p::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txmd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Txmd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txmd {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txmd {
            #[inline(always)]
            fn from(val: u8) -> Txmd {
                Txmd::from_bits(val)
            }
        }
        impl From<Txmd> for u8 {
            #[inline(always)]
            fn from(val: Txmd) -> u8 {
                Txmd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Udrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Udrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Udrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Udrf {
            #[inline(always)]
            fn from(val: u8) -> Udrf {
                Udrf::from_bits(val)
            }
        }
        impl From<Udrf> for u8 {
            #[inline(always)]
            fn from(val: Udrf) -> u8 {
                Udrf::to_bits(val)
            }
        }
    }
}
pub mod sram {
    #[doc = "SRAM Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sram {
        ptr: *mut u8,
    }
    unsafe impl Send for Sram {}
    unsafe impl Sync for Sram {}
    impl Sram {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SRAM Parity Error Operation After Detection Register"]
        #[inline(always)]
        pub const fn parioad(self) -> crate::common::Reg<regs::Parioad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "SRAM Protection Register"]
        #[inline(always)]
        pub const fn sramprcr(self) -> crate::common::Reg<regs::Sramprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "SRAM Parity Error Operation After Detection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Parioad(pub u8);
        impl Parioad {
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub const fn oad(&self) -> super::vals::Oad {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Oad::from_bits(val as u8)
            }
            #[doc = "Operation After Detection"]
            #[inline(always)]
            pub fn set_oad(&mut self, val: super::vals::Oad) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Parioad {
            #[inline(always)]
            fn default() -> Parioad {
                Parioad(0)
            }
        }
        impl core::fmt::Debug for Parioad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Parioad").field("oad", &self.oad()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Parioad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Parioad {{ oad: {:?} }}", self.oad())
            }
        }
        #[doc = "SRAM Protection Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sramprcr(pub u8);
        impl Sramprcr {
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub const fn sramprcr(&self) -> super::vals::Sramprcr {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sramprcr::from_bits(val as u8)
            }
            #[doc = "Register Write Control"]
            #[inline(always)]
            pub fn set_sramprcr(&mut self, val: super::vals::Sramprcr) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub const fn kw(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "Write Key Code"]
            #[inline(always)]
            pub fn set_kw(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u8) & 0x7f) << 1usize);
            }
        }
        impl Default for Sramprcr {
            #[inline(always)]
            fn default() -> Sramprcr {
                Sramprcr(0)
            }
        }
        impl core::fmt::Debug for Sramprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sramprcr")
                    .field("sramprcr", &self.sramprcr())
                    .field("kw", &self.kw())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sramprcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sramprcr {{ sramprcr: {:?}, kw: {=u8:?} }}",
                    self.sramprcr(),
                    self.kw()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oad {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Oad {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oad {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oad {
            #[inline(always)]
            fn from(val: u8) -> Oad {
                Oad::from_bits(val)
            }
        }
        impl From<Oad> for u8 {
            #[inline(always)]
            fn from(val: Oad) -> u8 {
                Oad::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sramprcr {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sramprcr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sramprcr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sramprcr {
            #[inline(always)]
            fn from(val: u8) -> Sramprcr {
                Sramprcr::from_bits(val)
            }
        }
        impl From<Sramprcr> for u8 {
            #[inline(always)]
            fn from(val: Sramprcr) -> u8 {
                Sramprcr::to_bits(val)
            }
        }
    }
}
pub mod sysc {
    #[doc = "System Control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysc {
        ptr: *mut u8,
    }
    unsafe impl Send for Sysc {}
    unsafe impl Sync for Sysc {}
    impl Sysc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Standby Control Register"]
        #[inline(always)]
        pub const fn sbycr(self) -> crate::common::Reg<regs::Sbycr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Module Stop Control Register A"]
        #[inline(always)]
        pub const fn mstpcra(self) -> crate::common::Reg<regs::Mstpcra, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "System Clock Division Control Register"]
        #[inline(always)]
        pub const fn sckdivcr(self) -> crate::common::Reg<regs::Sckdivcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "System Clock Source Control Register"]
        #[inline(always)]
        pub const fn sckscr(self) -> crate::common::Reg<regs::Sckscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x26usize) as _) }
        }
        #[doc = "Memory Wait Cycle Control Register for Code Flash"]
        #[inline(always)]
        pub const fn memwait(self) -> crate::common::Reg<regs::Memwait, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x31usize) as _) }
        }
        #[doc = "High,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn hococr(self) -> crate::common::Reg<regs::Hococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x36usize) as _) }
        }
        #[doc = "Middle,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn mococr(self) -> crate::common::Reg<regs::Mococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Oscillation Stabilization Flag Register"]
        #[inline(always)]
        pub const fn oscsf(self) -> crate::common::Reg<regs::Oscsf, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Clock Out Control Register"]
        #[inline(always)]
        pub const fn ckocr(self) -> crate::common::Reg<regs::Ckocr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3eusize) as _) }
        }
        #[doc = "Lower Power Operation Control Register"]
        #[inline(always)]
        pub const fn lpopt(self) -> crate::common::Reg<regs::Lpopt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "MOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn mocoutcr(self) -> crate::common::Reg<regs::Mocoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x61usize) as _) }
        }
        #[doc = "HOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn hocoutcr(self) -> crate::common::Reg<regs::Hocoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x62usize) as _) }
        }
        #[doc = "Snooze Control Register"]
        #[inline(always)]
        pub const fn snzcr(self) -> crate::common::Reg<regs::Snzcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x92usize) as _) }
        }
        #[doc = "Snooze End Control Register 0"]
        #[inline(always)]
        pub const fn snzedcr0(self) -> crate::common::Reg<regs::Snzedcr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Snooze Request Control Register 0"]
        #[inline(always)]
        pub const fn snzreqcr0(self) -> crate::common::Reg<regs::Snzreqcr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Power Save Memory Control Register"]
        #[inline(always)]
        pub const fn psmcr(self) -> crate::common::Reg<regs::Psmcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9fusize) as _) }
        }
        #[doc = "Operating Power Control Register"]
        #[inline(always)]
        pub const fn opccr(self) -> crate::common::Reg<regs::Opccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "High,Speed On,Chip Oscillator Wait Control Register"]
        #[inline(always)]
        pub const fn hocowtcr(self) -> crate::common::Reg<regs::Hocowtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa5usize) as _) }
        }
        #[doc = "Sub Operating Power Control Register"]
        #[inline(always)]
        pub const fn sopccr(self) -> crate::common::Reg<regs::Sopccr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xaausize) as _) }
        }
        #[doc = "Reset Status Register 1"]
        #[inline(always)]
        pub const fn rstsr1(self) -> crate::common::Reg<regs::Rstsr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register"]
        #[inline(always)]
        pub const fn lvd1cr1(self) -> crate::common::Reg<regs::Lvd1cr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Status Register"]
        #[inline(always)]
        pub const fn lvd1sr(self) -> crate::common::Reg<regs::Lvd1sr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe1usize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 1"]
        #[inline(always)]
        pub const fn lvd2cr1(self) -> crate::common::Reg<regs::Lvd2cr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe2usize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Status Register"]
        #[inline(always)]
        pub const fn lvd2sr(self) -> crate::common::Reg<regs::Lvd2sr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe3usize) as _) }
        }
        #[doc = "Protect Register"]
        #[inline(always)]
        pub const fn prcr(self) -> crate::common::Reg<regs::Prcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03feusize) as _) }
        }
        #[doc = "System Control OCD Control Register"]
        #[inline(always)]
        pub const fn syocdcr(self) -> crate::common::Reg<regs::Syocdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x040eusize) as _) }
        }
        #[doc = "Reset Status Register 0"]
        #[inline(always)]
        pub const fn rstsr0(self) -> crate::common::Reg<regs::Rstsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Reset Status Register 2"]
        #[inline(always)]
        pub const fn rstsr2(self) -> crate::common::Reg<regs::Rstsr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0411usize) as _) }
        }
        #[doc = "Voltage Monitor Circuit Control Register"]
        #[inline(always)]
        pub const fn lvcmpcr(self) -> crate::common::Reg<regs::Lvcmpcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0417usize) as _) }
        }
        #[doc = "Voltage Detection Level Select Register"]
        #[inline(always)]
        pub const fn lvdlvlr(self) -> crate::common::Reg<regs::Lvdlvlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0418usize) as _) }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register 0"]
        #[inline(always)]
        pub const fn lvd1cr0(self) -> crate::common::Reg<regs::Lvd1cr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x041ausize) as _) }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 0"]
        #[inline(always)]
        pub const fn lvd2cr0(self) -> crate::common::Reg<regs::Lvd2cr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x041busize) as _) }
        }
        #[doc = "Low,Speed On,Chip Oscillator Control Register"]
        #[inline(always)]
        pub const fn lococr(self) -> crate::common::Reg<regs::Lococr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0490usize) as _) }
        }
        #[doc = "LOCO User Trimming Control Register"]
        #[inline(always)]
        pub const fn locoutcr(self) -> crate::common::Reg<regs::Locoutcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0492usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Clock Out Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ckocr(pub u8);
        impl Ckocr {
            #[doc = "Clock Out Source Select"]
            #[inline(always)]
            pub const fn ckosel(&self) -> super::vals::Ckosel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ckosel::from_bits(val as u8)
            }
            #[doc = "Clock Out Source Select"]
            #[inline(always)]
            pub fn set_ckosel(&mut self, val: super::vals::Ckosel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
            #[doc = "Clock Output Frequency Division Ratio"]
            #[inline(always)]
            pub const fn ckodiv(&self) -> super::vals::Ckodiv {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Ckodiv::from_bits(val as u8)
            }
            #[doc = "Clock Output Frequency Division Ratio"]
            #[inline(always)]
            pub fn set_ckodiv(&mut self, val: super::vals::Ckodiv) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u8) & 0x07) << 4usize);
            }
            #[doc = "Clock Out Enable"]
            #[inline(always)]
            pub const fn ckoen(&self) -> super::vals::Ckoen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Ckoen::from_bits(val as u8)
            }
            #[doc = "Clock Out Enable"]
            #[inline(always)]
            pub fn set_ckoen(&mut self, val: super::vals::Ckoen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Ckocr {
            #[inline(always)]
            fn default() -> Ckocr {
                Ckocr(0)
            }
        }
        impl core::fmt::Debug for Ckocr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ckocr")
                    .field("ckosel", &self.ckosel())
                    .field("ckodiv", &self.ckodiv())
                    .field("ckoen", &self.ckoen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ckocr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ckocr {{ ckosel: {:?}, ckodiv: {:?}, ckoen: {:?} }}",
                    self.ckosel(),
                    self.ckodiv(),
                    self.ckoen()
                )
            }
        }
        #[doc = "High,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hococr(pub u8);
        impl Hococr {
            #[doc = "HOCO Stop"]
            #[inline(always)]
            pub const fn hcstp(&self) -> super::vals::Hcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hcstp::from_bits(val as u8)
            }
            #[doc = "HOCO Stop"]
            #[inline(always)]
            pub fn set_hcstp(&mut self, val: super::vals::Hcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Hococr {
            #[inline(always)]
            fn default() -> Hococr {
                Hococr(0)
            }
        }
        impl core::fmt::Debug for Hococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hococr")
                    .field("hcstp", &self.hcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hococr {{ hcstp: {:?} }}", self.hcstp())
            }
        }
        #[doc = "HOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hocoutcr(pub u8);
        impl Hocoutcr {
            #[doc = "HOCO User Trimming"]
            #[inline(always)]
            pub const fn hocoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "HOCO User Trimming"]
            #[inline(always)]
            pub fn set_hocoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Hocoutcr {
            #[inline(always)]
            fn default() -> Hocoutcr {
                Hocoutcr(0)
            }
        }
        impl core::fmt::Debug for Hocoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hocoutcr")
                    .field("hocoutrm", &self.hocoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hocoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hocoutcr {{ hocoutrm: {=u8:?} }}", self.hocoutrm())
            }
        }
        #[doc = "High,Speed On,Chip Oscillator Wait Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hocowtcr(pub u8);
        impl Hocowtcr {
            #[doc = "HOCO Wait Time Setting"]
            #[inline(always)]
            pub const fn hsts(&self) -> super::vals::Hsts {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Hsts::from_bits(val as u8)
            }
            #[doc = "HOCO Wait Time Setting"]
            #[inline(always)]
            pub fn set_hsts(&mut self, val: super::vals::Hsts) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Hocowtcr {
            #[inline(always)]
            fn default() -> Hocowtcr {
                Hocowtcr(0)
            }
        }
        impl core::fmt::Debug for Hocowtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hocowtcr")
                    .field("hsts", &self.hsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hocowtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hocowtcr {{ hsts: {:?} }}", self.hsts())
            }
        }
        #[doc = "Low,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lococr(pub u8);
        impl Lococr {
            #[doc = "LOCO Stop"]
            #[inline(always)]
            pub const fn lcstp(&self) -> super::vals::Lcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lcstp::from_bits(val as u8)
            }
            #[doc = "LOCO Stop"]
            #[inline(always)]
            pub fn set_lcstp(&mut self, val: super::vals::Lcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Lococr {
            #[inline(always)]
            fn default() -> Lococr {
                Lococr(0)
            }
        }
        impl core::fmt::Debug for Lococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lococr")
                    .field("lcstp", &self.lcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lococr {{ lcstp: {:?} }}", self.lcstp())
            }
        }
        #[doc = "LOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Locoutcr(pub u8);
        impl Locoutcr {
            #[doc = "LOCO User Trimming"]
            #[inline(always)]
            pub const fn locoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "LOCO User Trimming"]
            #[inline(always)]
            pub fn set_locoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Locoutcr {
            #[inline(always)]
            fn default() -> Locoutcr {
                Locoutcr(0)
            }
        }
        impl core::fmt::Debug for Locoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Locoutcr")
                    .field("locoutrm", &self.locoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Locoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Locoutcr {{ locoutrm: {=u8:?} }}", self.locoutrm())
            }
        }
        #[doc = "Lower Power Operation Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lpopt(pub u8);
        impl Lpopt {
            #[doc = "MPU Clock Disable Control"]
            #[inline(always)]
            pub const fn mpudis(&self) -> super::vals::Mpudis {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mpudis::from_bits(val as u8)
            }
            #[doc = "MPU Clock Disable Control"]
            #[inline(always)]
            pub fn set_mpudis(&mut self, val: super::vals::Mpudis) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Debug Clock Disable Control"]
            #[inline(always)]
            pub const fn dclkdis(&self) -> super::vals::Dclkdis {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Dclkdis::from_bits(val as u8)
            }
            #[doc = "Debug Clock Disable Control"]
            #[inline(always)]
            pub fn set_dclkdis(&mut self, val: super::vals::Dclkdis) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u8) & 0x03) << 1usize);
            }
            #[doc = "BPF Clock Disable Control"]
            #[inline(always)]
            pub const fn bpfclkdis(&self) -> super::vals::Bpfclkdis {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Bpfclkdis::from_bits(val as u8)
            }
            #[doc = "BPF Clock Disable Control"]
            #[inline(always)]
            pub fn set_bpfclkdis(&mut self, val: super::vals::Bpfclkdis) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "Lower Power Operation Enable"]
            #[inline(always)]
            pub const fn lpopten(&self) -> super::vals::Lpopten {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lpopten::from_bits(val as u8)
            }
            #[doc = "Lower Power Operation Enable"]
            #[inline(always)]
            pub fn set_lpopten(&mut self, val: super::vals::Lpopten) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lpopt {
            #[inline(always)]
            fn default() -> Lpopt {
                Lpopt(0)
            }
        }
        impl core::fmt::Debug for Lpopt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lpopt")
                    .field("mpudis", &self.mpudis())
                    .field("dclkdis", &self.dclkdis())
                    .field("bpfclkdis", &self.bpfclkdis())
                    .field("lpopten", &self.lpopten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lpopt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lpopt {{ mpudis: {:?}, dclkdis: {:?}, bpfclkdis: {:?}, lpopten: {:?} }}",
                    self.mpudis(),
                    self.dclkdis(),
                    self.bpfclkdis(),
                    self.lpopten()
                )
            }
        }
        #[doc = "Voltage Monitor Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvcmpcr(pub u8);
        impl Lvcmpcr {
            #[doc = "Voltage Detection 1 Enable"]
            #[inline(always)]
            pub const fn lvd1e(&self) -> super::vals::Lvd1e {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Lvd1e::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 1 Enable"]
            #[inline(always)]
            pub fn set_lvd1e(&mut self, val: super::vals::Lvd1e) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u8) & 0x01) << 5usize);
            }
            #[doc = "Voltage Detection 2 Enable"]
            #[inline(always)]
            pub const fn lvd2e(&self) -> super::vals::Lvd2e {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd2e::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 2 Enable"]
            #[inline(always)]
            pub fn set_lvd2e(&mut self, val: super::vals::Lvd2e) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
        }
        impl Default for Lvcmpcr {
            #[inline(always)]
            fn default() -> Lvcmpcr {
                Lvcmpcr(0)
            }
        }
        impl core::fmt::Debug for Lvcmpcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvcmpcr")
                    .field("lvd1e", &self.lvd1e())
                    .field("lvd2e", &self.lvd2e())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvcmpcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvcmpcr {{ lvd1e: {:?}, lvd2e: {:?} }}",
                    self.lvd1e(),
                    self.lvd2e()
                )
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1cr0(pub u8);
        impl Lvd1cr0 {
            #[doc = "Voltage Monitor 1 Interrupt/Reset Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Lvd1cr0Rie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd1cr0Rie::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt/Reset Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Lvd1cr0Rie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::Lvd1cr0Cmpe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1cr0Cmpe::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::Lvd1cr0Cmpe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 1 Circuit Mode Select"]
            #[inline(always)]
            pub const fn ri(&self) -> super::vals::Lvd1cr0Ri {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd1cr0Ri::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Circuit Mode Select"]
            #[inline(always)]
            pub fn set_ri(&mut self, val: super::vals::Lvd1cr0Ri) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Voltage Monitor 1 Reset Negate Select"]
            #[inline(always)]
            pub const fn rn(&self) -> super::vals::Lvd1cr0Rn {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lvd1cr0Rn::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Reset Negate Select"]
            #[inline(always)]
            pub fn set_rn(&mut self, val: super::vals::Lvd1cr0Rn) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lvd1cr0 {
            #[inline(always)]
            fn default() -> Lvd1cr0 {
                Lvd1cr0(0)
            }
        }
        impl core::fmt::Debug for Lvd1cr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1cr0")
                    .field("rie", &self.rie())
                    .field("cmpe", &self.cmpe())
                    .field("ri", &self.ri())
                    .field("rn", &self.rn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1cr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1cr0 {{ rie: {:?}, cmpe: {:?}, ri: {:?}, rn: {:?} }}",
                    self.rie(),
                    self.cmpe(),
                    self.ri(),
                    self.rn()
                )
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1cr1(pub u8);
        impl Lvd1cr1 {
            #[doc = "Voltage Monitor 1 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::Lvd1cr1Idtsel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lvd1cr1Idtsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::Lvd1cr1Idtsel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Interrupt Type Select"]
            #[inline(always)]
            pub const fn irqsel(&self) -> super::vals::Lvd1cr1Irqsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1cr1Irqsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Interrupt Type Select"]
            #[inline(always)]
            pub fn set_irqsel(&mut self, val: super::vals::Lvd1cr1Irqsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Lvd1cr1 {
            #[inline(always)]
            fn default() -> Lvd1cr1 {
                Lvd1cr1(0)
            }
        }
        impl core::fmt::Debug for Lvd1cr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1cr1")
                    .field("idtsel", &self.idtsel())
                    .field("irqsel", &self.irqsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1cr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1cr1 {{ idtsel: {:?}, irqsel: {:?} }}",
                    self.idtsel(),
                    self.irqsel()
                )
            }
        }
        #[doc = "Voltage Monitor 1 Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd1sr(pub u8);
        impl Lvd1sr {
            #[doc = "Voltage Monitor 1 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::Lvd1srDet {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd1srDet::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::Lvd1srDet) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 1 Signal Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::Lvd1srMon {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd1srMon::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Signal Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::Lvd1srMon) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Lvd1sr {
            #[inline(always)]
            fn default() -> Lvd1sr {
                Lvd1sr(0)
            }
        }
        impl core::fmt::Debug for Lvd1sr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd1sr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd1sr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd1sr {{ det: {:?}, mon: {:?} }}",
                    self.det(),
                    self.mon()
                )
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2cr0(pub u8);
        impl Lvd2cr0 {
            #[doc = "Voltage Monitor 2 Interrupt/Reset Enable"]
            #[inline(always)]
            pub const fn rie(&self) -> super::vals::Lvd2cr0Rie {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd2cr0Rie::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt/Reset Enable"]
            #[inline(always)]
            pub fn set_rie(&mut self, val: super::vals::Lvd2cr0Rie) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 2 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub const fn cmpe(&self) -> super::vals::Lvd2cr0Cmpe {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd2cr0Cmpe::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Circuit Comparison Result Output Enable"]
            #[inline(always)]
            pub fn set_cmpe(&mut self, val: super::vals::Lvd2cr0Cmpe) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Circuit Mode Select"]
            #[inline(always)]
            pub const fn ri(&self) -> super::vals::Lvd2cr0Ri {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lvd2cr0Ri::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Circuit Mode Select"]
            #[inline(always)]
            pub fn set_ri(&mut self, val: super::vals::Lvd2cr0Ri) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u8) & 0x01) << 6usize);
            }
            #[doc = "Voltage Monitor 2 Reset Negate Select"]
            #[inline(always)]
            pub const fn rn(&self) -> super::vals::Lvd2cr0Rn {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Lvd2cr0Rn::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Reset Negate Select"]
            #[inline(always)]
            pub fn set_rn(&mut self, val: super::vals::Lvd2cr0Rn) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Lvd2cr0 {
            #[inline(always)]
            fn default() -> Lvd2cr0 {
                Lvd2cr0(0)
            }
        }
        impl core::fmt::Debug for Lvd2cr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2cr0")
                    .field("rie", &self.rie())
                    .field("cmpe", &self.cmpe())
                    .field("ri", &self.ri())
                    .field("rn", &self.rn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2cr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd2cr0 {{ rie: {:?}, cmpe: {:?}, ri: {:?}, rn: {:?} }}",
                    self.rie(),
                    self.cmpe(),
                    self.ri(),
                    self.rn()
                )
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2cr1(pub u8);
        impl Lvd2cr1 {
            #[doc = "Voltage Monitor 2 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub const fn idtsel(&self) -> super::vals::Lvd2cr1Idtsel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lvd2cr1Idtsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Generation Condition Select"]
            #[inline(always)]
            pub fn set_idtsel(&mut self, val: super::vals::Lvd2cr1Idtsel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Voltage Monitor 2 Interrupt Type Select"]
            #[inline(always)]
            pub const fn irqsel(&self) -> super::vals::Lvd2cr1Irqsel {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd2cr1Irqsel::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Interrupt Type Select"]
            #[inline(always)]
            pub fn set_irqsel(&mut self, val: super::vals::Lvd2cr1Irqsel) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
        }
        impl Default for Lvd2cr1 {
            #[inline(always)]
            fn default() -> Lvd2cr1 {
                Lvd2cr1(0)
            }
        }
        impl core::fmt::Debug for Lvd2cr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2cr1")
                    .field("idtsel", &self.idtsel())
                    .field("irqsel", &self.irqsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2cr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd2cr1 {{ idtsel: {:?}, irqsel: {:?} }}",
                    self.idtsel(),
                    self.irqsel()
                )
            }
        }
        #[doc = "Voltage Monitor 2 Circuit Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvd2sr(pub u8);
        impl Lvd2sr {
            #[doc = "Voltage Monitor 2 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub const fn det(&self) -> super::vals::Lvd2srDet {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Lvd2srDet::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Voltage Variation Detection Flag"]
            #[inline(always)]
            pub fn set_det(&mut self, val: super::vals::Lvd2srDet) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 2 Signal Monitor Flag"]
            #[inline(always)]
            pub const fn mon(&self) -> super::vals::Lvd2srMon {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd2srMon::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Signal Monitor Flag"]
            #[inline(always)]
            pub fn set_mon(&mut self, val: super::vals::Lvd2srMon) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
        }
        impl Default for Lvd2sr {
            #[inline(always)]
            fn default() -> Lvd2sr {
                Lvd2sr(0)
            }
        }
        impl core::fmt::Debug for Lvd2sr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvd2sr")
                    .field("det", &self.det())
                    .field("mon", &self.mon())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvd2sr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvd2sr {{ det: {:?}, mon: {:?} }}",
                    self.det(),
                    self.mon()
                )
            }
        }
        #[doc = "Voltage Detection Level Select Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lvdlvlr(pub u8);
        impl Lvdlvlr {
            #[doc = "Voltage Detection 1 Level Select (Standard voltage during fall in voltage)"]
            #[inline(always)]
            pub const fn lvd1lvl(&self) -> super::vals::Lvd1lvl {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Lvd1lvl::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 1 Level Select (Standard voltage during fall in voltage)"]
            #[inline(always)]
            pub fn set_lvd1lvl(&mut self, val: super::vals::Lvd1lvl) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u8) & 0x1f) << 0usize);
            }
            #[doc = "Voltage Detection 2 Level Select (Standard voltage during fall in voltage)"]
            #[inline(always)]
            pub const fn lvd2lvl(&self) -> super::vals::Lvd2lvl {
                let val = (self.0 >> 5usize) & 0x07;
                super::vals::Lvd2lvl::from_bits(val as u8)
            }
            #[doc = "Voltage Detection 2 Level Select (Standard voltage during fall in voltage)"]
            #[inline(always)]
            pub fn set_lvd2lvl(&mut self, val: super::vals::Lvd2lvl) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val.to_bits() as u8) & 0x07) << 5usize);
            }
        }
        impl Default for Lvdlvlr {
            #[inline(always)]
            fn default() -> Lvdlvlr {
                Lvdlvlr(0)
            }
        }
        impl core::fmt::Debug for Lvdlvlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lvdlvlr")
                    .field("lvd1lvl", &self.lvd1lvl())
                    .field("lvd2lvl", &self.lvd2lvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lvdlvlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lvdlvlr {{ lvd1lvl: {:?}, lvd2lvl: {:?} }}",
                    self.lvd1lvl(),
                    self.lvd2lvl()
                )
            }
        }
        #[doc = "Memory Wait Cycle Control Register for Code Flash"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Memwait(pub u8);
        impl Memwait {
            #[doc = "Memory Wait Cycle Select for Code Flash"]
            #[inline(always)]
            pub const fn memwait(&self) -> super::vals::Memwait {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Memwait::from_bits(val as u8)
            }
            #[doc = "Memory Wait Cycle Select for Code Flash"]
            #[inline(always)]
            pub fn set_memwait(&mut self, val: super::vals::Memwait) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Memwait {
            #[inline(always)]
            fn default() -> Memwait {
                Memwait(0)
            }
        }
        impl core::fmt::Debug for Memwait {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Memwait")
                    .field("memwait", &self.memwait())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Memwait {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Memwait {{ memwait: {:?} }}", self.memwait())
            }
        }
        #[doc = "Middle,Speed On,Chip Oscillator Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mococr(pub u8);
        impl Mococr {
            #[doc = "MOCO Stop"]
            #[inline(always)]
            pub const fn mcstp(&self) -> super::vals::Mcstp {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mcstp::from_bits(val as u8)
            }
            #[doc = "MOCO Stop"]
            #[inline(always)]
            pub fn set_mcstp(&mut self, val: super::vals::Mcstp) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Mococr {
            #[inline(always)]
            fn default() -> Mococr {
                Mococr(0)
            }
        }
        impl core::fmt::Debug for Mococr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mococr")
                    .field("mcstp", &self.mcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mococr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mococr {{ mcstp: {:?} }}", self.mcstp())
            }
        }
        #[doc = "MOCO User Trimming Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mocoutcr(pub u8);
        impl Mocoutcr {
            #[doc = "MOCO User Trimming"]
            #[inline(always)]
            pub const fn mocoutrm(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "MOCO User Trimming"]
            #[inline(always)]
            pub fn set_mocoutrm(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Mocoutcr {
            #[inline(always)]
            fn default() -> Mocoutcr {
                Mocoutcr(0)
            }
        }
        impl core::fmt::Debug for Mocoutcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mocoutcr")
                    .field("mocoutrm", &self.mocoutrm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mocoutcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mocoutcr {{ mocoutrm: {=u8:?} }}", self.mocoutrm())
            }
        }
        #[doc = "Module Stop Control Register A"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mstpcra(pub u32);
        impl Mstpcra {
            #[doc = "DTC Module Stop"]
            #[inline(always)]
            pub const fn mstpa22(&self) -> super::vals::Mstpa22 {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Mstpa22::from_bits(val as u8)
            }
            #[doc = "DTC Module Stop"]
            #[inline(always)]
            pub fn set_mstpa22(&mut self, val: super::vals::Mstpa22) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Mstpcra {
            #[inline(always)]
            fn default() -> Mstpcra {
                Mstpcra(0)
            }
        }
        impl core::fmt::Debug for Mstpcra {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mstpcra")
                    .field("mstpa22", &self.mstpa22())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mstpcra {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mstpcra {{ mstpa22: {:?} }}", self.mstpa22())
            }
        }
        #[doc = "Operating Power Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opccr(pub u8);
        impl Opccr {
            #[doc = "Operating Power Control Mode Select"]
            #[inline(always)]
            pub const fn opcm(&self) -> super::vals::Opcm {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Opcm::from_bits(val as u8)
            }
            #[doc = "Operating Power Control Mode Select"]
            #[inline(always)]
            pub fn set_opcm(&mut self, val: super::vals::Opcm) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub const fn opcmtsf(&self) -> super::vals::Opcmtsf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Opcmtsf::from_bits(val as u8)
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub fn set_opcmtsf(&mut self, val: super::vals::Opcmtsf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Opccr {
            #[inline(always)]
            fn default() -> Opccr {
                Opccr(0)
            }
        }
        impl core::fmt::Debug for Opccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opccr")
                    .field("opcm", &self.opcm())
                    .field("opcmtsf", &self.opcmtsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Opccr {{ opcm: {:?}, opcmtsf: {:?} }}",
                    self.opcm(),
                    self.opcmtsf()
                )
            }
        }
        #[doc = "Oscillation Stabilization Flag Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oscsf(pub u8);
        impl Oscsf {
            #[doc = "HOCO Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub const fn hocosf(&self) -> super::vals::Hocosf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hocosf::from_bits(val as u8)
            }
            #[doc = "HOCO Clock Oscillation Stabilization Flag"]
            #[inline(always)]
            pub fn set_hocosf(&mut self, val: super::vals::Hocosf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Oscsf {
            #[inline(always)]
            fn default() -> Oscsf {
                Oscsf(0)
            }
        }
        impl core::fmt::Debug for Oscsf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oscsf")
                    .field("hocosf", &self.hocosf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oscsf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Oscsf {{ hocosf: {:?} }}", self.hocosf())
            }
        }
        #[doc = "Protect Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prcr(pub u16);
        impl Prcr {
            #[doc = "Enable writing to the registers related to the clock generation circuit"]
            #[inline(always)]
            pub const fn prc0(&self) -> super::vals::Prc0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Prc0::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the clock generation circuit"]
            #[inline(always)]
            pub fn set_prc0(&mut self, val: super::vals::Prc0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Enable writing to the registers related to the low power modes"]
            #[inline(always)]
            pub const fn prc1(&self) -> super::vals::Prc1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Prc1::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the low power modes"]
            #[inline(always)]
            pub fn set_prc1(&mut self, val: super::vals::Prc1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Enable writing to the registers related to the LVD"]
            #[inline(always)]
            pub const fn prc3(&self) -> super::vals::Prc3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Prc3::from_bits(val as u8)
            }
            #[doc = "Enable writing to the registers related to the LVD"]
            #[inline(always)]
            pub fn set_prc3(&mut self, val: super::vals::Prc3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u16) & 0x01) << 3usize);
            }
            #[doc = "PRC Key Code"]
            #[inline(always)]
            pub const fn prkey(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "PRC Key Code"]
            #[inline(always)]
            pub fn set_prkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u16) & 0xff) << 8usize);
            }
        }
        impl Default for Prcr {
            #[inline(always)]
            fn default() -> Prcr {
                Prcr(0)
            }
        }
        impl core::fmt::Debug for Prcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prcr")
                    .field("prc0", &self.prc0())
                    .field("prc1", &self.prc1())
                    .field("prc3", &self.prc3())
                    .field("prkey", &self.prkey())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prcr {{ prc0: {:?}, prc1: {:?}, prc3: {:?}, prkey: {=u8:?} }}",
                    self.prc0(),
                    self.prc1(),
                    self.prc3(),
                    self.prkey()
                )
            }
        }
        #[doc = "Power Save Memory Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psmcr(pub u8);
        impl Psmcr {
            #[doc = "Power Save Memory Control"]
            #[inline(always)]
            pub const fn psmc(&self) -> super::vals::Psmc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Psmc::from_bits(val as u8)
            }
            #[doc = "Power Save Memory Control"]
            #[inline(always)]
            pub fn set_psmc(&mut self, val: super::vals::Psmc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u8) & 0x03) << 0usize);
            }
        }
        impl Default for Psmcr {
            #[inline(always)]
            fn default() -> Psmcr {
                Psmcr(0)
            }
        }
        impl core::fmt::Debug for Psmcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psmcr").field("psmc", &self.psmc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psmcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Psmcr {{ psmc: {:?} }}", self.psmc())
            }
        }
        #[doc = "Reset Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr0(pub u8);
        impl Rstsr0 {
            #[doc = "Power,On Reset Detect Flag"]
            #[inline(always)]
            pub const fn porf(&self) -> super::vals::Porf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Porf::from_bits(val as u8)
            }
            #[doc = "Power,On Reset Detect Flag"]
            #[inline(always)]
            pub fn set_porf(&mut self, val: super::vals::Porf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Voltage Monitor 0 Reset Detect Flag"]
            #[inline(always)]
            pub const fn lvd0rf(&self) -> super::vals::Lvd0rf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Lvd0rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 0 Reset Detect Flag"]
            #[inline(always)]
            pub fn set_lvd0rf(&mut self, val: super::vals::Lvd0rf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Voltage Monitor 1 Reset Detect Flag"]
            #[inline(always)]
            pub const fn lvd1rf(&self) -> super::vals::Lvd1rf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Lvd1rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 1 Reset Detect Flag"]
            #[inline(always)]
            pub fn set_lvd1rf(&mut self, val: super::vals::Lvd1rf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "Voltage Monitor 2 Reset Detect Flag"]
            #[inline(always)]
            pub const fn lvd2rf(&self) -> super::vals::Lvd2rf {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Lvd2rf::from_bits(val as u8)
            }
            #[doc = "Voltage Monitor 2 Reset Detect Flag"]
            #[inline(always)]
            pub fn set_lvd2rf(&mut self, val: super::vals::Lvd2rf) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
        }
        impl Default for Rstsr0 {
            #[inline(always)]
            fn default() -> Rstsr0 {
                Rstsr0(0)
            }
        }
        impl core::fmt::Debug for Rstsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr0")
                    .field("porf", &self.porf())
                    .field("lvd0rf", &self.lvd0rf())
                    .field("lvd1rf", &self.lvd1rf())
                    .field("lvd2rf", &self.lvd2rf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rstsr0 {{ porf: {:?}, lvd0rf: {:?}, lvd1rf: {:?}, lvd2rf: {:?} }}",
                    self.porf(),
                    self.lvd0rf(),
                    self.lvd1rf(),
                    self.lvd2rf()
                )
            }
        }
        #[doc = "Reset Status Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr1(pub u16);
        impl Rstsr1 {
            #[doc = "Independent Watchdog Timer Reset Detect Flag"]
            #[inline(always)]
            pub const fn iwdtrf(&self) -> super::vals::Iwdtrf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Iwdtrf::from_bits(val as u8)
            }
            #[doc = "Independent Watchdog Timer Reset Detect Flag"]
            #[inline(always)]
            pub fn set_iwdtrf(&mut self, val: super::vals::Iwdtrf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u16) & 0x01) << 0usize);
            }
            #[doc = "Watchdog Timer Reset Detect Flag"]
            #[inline(always)]
            pub const fn wdtrf(&self) -> super::vals::Wdtrf {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Wdtrf::from_bits(val as u8)
            }
            #[doc = "Watchdog Timer Reset Detect Flag"]
            #[inline(always)]
            pub fn set_wdtrf(&mut self, val: super::vals::Wdtrf) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u16) & 0x01) << 1usize);
            }
            #[doc = "Software Reset Detect Flag"]
            #[inline(always)]
            pub const fn swrf(&self) -> super::vals::Swrf {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Swrf::from_bits(val as u8)
            }
            #[doc = "Software Reset Detect Flag"]
            #[inline(always)]
            pub fn set_swrf(&mut self, val: super::vals::Swrf) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u16) & 0x01) << 2usize);
            }
            #[doc = "SRAM Parity Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn rperf(&self) -> super::vals::Rperf {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Rperf::from_bits(val as u8)
            }
            #[doc = "SRAM Parity Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_rperf(&mut self, val: super::vals::Rperf) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u16) & 0x01) << 8usize);
            }
            #[doc = "Bus Slave MPU Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn bussrf(&self) -> super::vals::Bussrf {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Bussrf::from_bits(val as u8)
            }
            #[doc = "Bus Slave MPU Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_bussrf(&mut self, val: super::vals::Bussrf) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u16) & 0x01) << 10usize);
            }
            #[doc = "Bus Master MPU Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn busmrf(&self) -> super::vals::Busmrf {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Busmrf::from_bits(val as u8)
            }
            #[doc = "Bus Master MPU Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_busmrf(&mut self, val: super::vals::Busmrf) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u16) & 0x01) << 11usize);
            }
            #[doc = "CPU Stack Pointer Error Reset Detect Flag"]
            #[inline(always)]
            pub const fn sperf(&self) -> super::vals::Sperf {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Sperf::from_bits(val as u8)
            }
            #[doc = "CPU Stack Pointer Error Reset Detect Flag"]
            #[inline(always)]
            pub fn set_sperf(&mut self, val: super::vals::Sperf) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u16) & 0x01) << 12usize);
            }
        }
        impl Default for Rstsr1 {
            #[inline(always)]
            fn default() -> Rstsr1 {
                Rstsr1(0)
            }
        }
        impl core::fmt::Debug for Rstsr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr1")
                    .field("iwdtrf", &self.iwdtrf())
                    .field("wdtrf", &self.wdtrf())
                    .field("swrf", &self.swrf())
                    .field("rperf", &self.rperf())
                    .field("bussrf", &self.bussrf())
                    .field("busmrf", &self.busmrf())
                    .field("sperf", &self.sperf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rstsr1 {{ iwdtrf: {:?}, wdtrf: {:?}, swrf: {:?}, rperf: {:?}, bussrf: {:?}, busmrf: {:?}, sperf: {:?} }}" , self . iwdtrf () , self . wdtrf () , self . swrf () , self . rperf () , self . bussrf () , self . busmrf () , self . sperf ())
            }
        }
        #[doc = "Reset Status Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rstsr2(pub u8);
        impl Rstsr2 {
            #[doc = "Cold/Warm Start Determination Flag"]
            #[inline(always)]
            pub const fn cwsf(&self) -> super::vals::Cwsf {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Cwsf::from_bits(val as u8)
            }
            #[doc = "Cold/Warm Start Determination Flag"]
            #[inline(always)]
            pub fn set_cwsf(&mut self, val: super::vals::Cwsf) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
        }
        impl Default for Rstsr2 {
            #[inline(always)]
            fn default() -> Rstsr2 {
                Rstsr2(0)
            }
        }
        impl core::fmt::Debug for Rstsr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rstsr2")
                    .field("cwsf", &self.cwsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rstsr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rstsr2 {{ cwsf: {:?} }}", self.cwsf())
            }
        }
        #[doc = "Standby Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbycr(pub u16);
        impl Sbycr {
            #[doc = "Software Standby Mode Select"]
            #[inline(always)]
            pub const fn ssby(&self) -> super::vals::Ssby {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ssby::from_bits(val as u8)
            }
            #[doc = "Software Standby Mode Select"]
            #[inline(always)]
            pub fn set_ssby(&mut self, val: super::vals::Ssby) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Sbycr {
            #[inline(always)]
            fn default() -> Sbycr {
                Sbycr(0)
            }
        }
        impl core::fmt::Debug for Sbycr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbycr").field("ssby", &self.ssby()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbycr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sbycr {{ ssby: {:?} }}", self.ssby())
            }
        }
        #[doc = "System Clock Division Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sckdivcr(pub u32);
        impl Sckdivcr {
            #[doc = "Peripheral Module Clock D (PCLKD) Select"]
            #[inline(always)]
            pub const fn pckd(&self) -> super::vals::Pckd {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Pckd::from_bits(val as u8)
            }
            #[doc = "Peripheral Module Clock D (PCLKD) Select"]
            #[inline(always)]
            pub fn set_pckd(&mut self, val: super::vals::Pckd) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Peripheral Module Clock B (PCLKB) Select"]
            #[inline(always)]
            pub const fn pckb(&self) -> super::vals::Pckb {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Pckb::from_bits(val as u8)
            }
            #[doc = "Peripheral Module Clock B (PCLKB) Select"]
            #[inline(always)]
            pub fn set_pckb(&mut self, val: super::vals::Pckb) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "System Clock (ICLK) Select"]
            #[inline(always)]
            pub const fn ick(&self) -> super::vals::Ick {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Ick::from_bits(val as u8)
            }
            #[doc = "System Clock (ICLK) Select"]
            #[inline(always)]
            pub fn set_ick(&mut self, val: super::vals::Ick) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Sckdivcr {
            #[inline(always)]
            fn default() -> Sckdivcr {
                Sckdivcr(0)
            }
        }
        impl core::fmt::Debug for Sckdivcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sckdivcr")
                    .field("pckd", &self.pckd())
                    .field("pckb", &self.pckb())
                    .field("ick", &self.ick())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sckdivcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sckdivcr {{ pckd: {:?}, pckb: {:?}, ick: {:?} }}",
                    self.pckd(),
                    self.pckb(),
                    self.ick()
                )
            }
        }
        #[doc = "System Clock Source Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sckscr(pub u8);
        impl Sckscr {
            #[doc = "Clock Source Select"]
            #[inline(always)]
            pub const fn cksel(&self) -> super::vals::Cksel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Cksel::from_bits(val as u8)
            }
            #[doc = "Clock Source Select"]
            #[inline(always)]
            pub fn set_cksel(&mut self, val: super::vals::Cksel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u8) & 0x07) << 0usize);
            }
        }
        impl Default for Sckscr {
            #[inline(always)]
            fn default() -> Sckscr {
                Sckscr(0)
            }
        }
        impl core::fmt::Debug for Sckscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sckscr")
                    .field("cksel", &self.cksel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sckscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sckscr {{ cksel: {:?} }}", self.cksel())
            }
        }
        #[doc = "Snooze Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzcr(pub u8);
        impl Snzcr {
            #[doc = "DTC Enable in Snooze mode"]
            #[inline(always)]
            pub const fn snzdtcen(&self) -> super::vals::Snzdtcen {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Snzdtcen::from_bits(val as u8)
            }
            #[doc = "DTC Enable in Snooze mode"]
            #[inline(always)]
            pub fn set_snzdtcen(&mut self, val: super::vals::Snzdtcen) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Snooze mode Enable"]
            #[inline(always)]
            pub const fn snze(&self) -> super::vals::Snze {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Snze::from_bits(val as u8)
            }
            #[doc = "Snooze mode Enable"]
            #[inline(always)]
            pub fn set_snze(&mut self, val: super::vals::Snze) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Snzcr {
            #[inline(always)]
            fn default() -> Snzcr {
                Snzcr(0)
            }
        }
        impl core::fmt::Debug for Snzcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzcr")
                    .field("snzdtcen", &self.snzdtcen())
                    .field("snze", &self.snze())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Snzcr {{ snzdtcen: {:?}, snze: {:?} }}",
                    self.snzdtcen(),
                    self.snze()
                )
            }
        }
        #[doc = "Snooze End Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzedcr0(pub u8);
        impl Snzedcr0 {
            #[doc = "AGT1 Underflow Snooze End Enable"]
            #[inline(always)]
            pub const fn agtunfed(&self) -> super::vals::Agtunfed {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Agtunfed::from_bits(val as u8)
            }
            #[doc = "AGT1 Underflow Snooze End Enable"]
            #[inline(always)]
            pub fn set_agtunfed(&mut self, val: super::vals::Agtunfed) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Last DTC Transmission Completion Snooze End Enable"]
            #[inline(always)]
            pub const fn dtczred(&self) -> super::vals::Dtczred {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Dtczred::from_bits(val as u8)
            }
            #[doc = "Last DTC Transmission Completion Snooze End Enable"]
            #[inline(always)]
            pub fn set_dtczred(&mut self, val: super::vals::Dtczred) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u8) & 0x01) << 1usize);
            }
            #[doc = "Not Last DTC Transmission Completion Snooze End Enable"]
            #[inline(always)]
            pub const fn dtcnzred(&self) -> super::vals::Dtcnzred {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Dtcnzred::from_bits(val as u8)
            }
            #[doc = "Not Last DTC Transmission Completion Snooze End Enable"]
            #[inline(always)]
            pub fn set_dtcnzred(&mut self, val: super::vals::Dtcnzred) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u8) & 0x01) << 2usize);
            }
            #[doc = "ADC12 Compare Match Snooze End Enable"]
            #[inline(always)]
            pub const fn ad0mated(&self) -> super::vals::Ad0mated {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ad0mated::from_bits(val as u8)
            }
            #[doc = "ADC12 Compare Match Snooze End Enable"]
            #[inline(always)]
            pub fn set_ad0mated(&mut self, val: super::vals::Ad0mated) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u8) & 0x01) << 3usize);
            }
            #[doc = "ADC12 Compare Mismatch Snooze End Enable"]
            #[inline(always)]
            pub const fn ad0umted(&self) -> super::vals::Ad0umted {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ad0umted::from_bits(val as u8)
            }
            #[doc = "ADC12 Compare Mismatch Snooze End Enable"]
            #[inline(always)]
            pub fn set_ad0umted(&mut self, val: super::vals::Ad0umted) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Snzedcr0 {
            #[inline(always)]
            fn default() -> Snzedcr0 {
                Snzedcr0(0)
            }
        }
        impl core::fmt::Debug for Snzedcr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzedcr0")
                    .field("agtunfed", &self.agtunfed())
                    .field("dtczred", &self.dtczred())
                    .field("dtcnzred", &self.dtcnzred())
                    .field("ad0mated", &self.ad0mated())
                    .field("ad0umted", &self.ad0umted())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzedcr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Snzedcr0 {{ agtunfed: {:?}, dtczred: {:?}, dtcnzred: {:?}, ad0mated: {:?}, ad0umted: {:?} }}" , self . agtunfed () , self . dtczred () , self . dtcnzred () , self . ad0mated () , self . ad0umted ())
            }
        }
        #[doc = "Snooze Request Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Snzreqcr0(pub u32);
        impl Snzreqcr0 {
            #[doc = "Enable IRQ0 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen0(&self) -> super::vals::Snzreqen0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Snzreqen0::from_bits(val as u8)
            }
            #[doc = "Enable IRQ0 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen0(&mut self, val: super::vals::Snzreqen0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable IRQ1 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen1(&self) -> super::vals::Snzreqen1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Snzreqen1::from_bits(val as u8)
            }
            #[doc = "Enable IRQ1 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen1(&mut self, val: super::vals::Snzreqen1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable IRQ2 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen2(&self) -> super::vals::Snzreqen2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Snzreqen2::from_bits(val as u8)
            }
            #[doc = "Enable IRQ2 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen2(&mut self, val: super::vals::Snzreqen2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable IRQ3 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen3(&self) -> super::vals::Snzreqen3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Snzreqen3::from_bits(val as u8)
            }
            #[doc = "Enable IRQ3 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen3(&mut self, val: super::vals::Snzreqen3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable IRQ4 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen4(&self) -> super::vals::Snzreqen4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Snzreqen4::from_bits(val as u8)
            }
            #[doc = "Enable IRQ4 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen4(&mut self, val: super::vals::Snzreqen4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable IRQ5 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen5(&self) -> super::vals::Snzreqen5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Snzreqen5::from_bits(val as u8)
            }
            #[doc = "Enable IRQ5 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen5(&mut self, val: super::vals::Snzreqen5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable IRQ6 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen6(&self) -> super::vals::Snzreqen6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Snzreqen6::from_bits(val as u8)
            }
            #[doc = "Enable IRQ6 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen6(&mut self, val: super::vals::Snzreqen6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable IRQ7 pin snooze request"]
            #[inline(always)]
            pub const fn snzreqen7(&self) -> super::vals::Snzreqen7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Snzreqen7::from_bits(val as u8)
            }
            #[doc = "Enable IRQ7 pin snooze request"]
            #[inline(always)]
            pub fn set_snzreqen7(&mut self, val: super::vals::Snzreqen7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable KEY_INTKR snooze request"]
            #[inline(always)]
            pub const fn snzreqen17(&self) -> super::vals::Snzreqen17 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Snzreqen17::from_bits(val as u8)
            }
            #[doc = "Enable KEY_INTKR snooze request"]
            #[inline(always)]
            pub fn set_snzreqen17(&mut self, val: super::vals::Snzreqen17) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable AGT1 underflow snooze request"]
            #[inline(always)]
            pub const fn snzreqen28(&self) -> super::vals::Snzreqen28 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Snzreqen28::from_bits(val as u8)
            }
            #[doc = "Enable AGT1 underflow snooze request"]
            #[inline(always)]
            pub fn set_snzreqen28(&mut self, val: super::vals::Snzreqen28) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Enable AGT1 compare match A snooze request"]
            #[inline(always)]
            pub const fn snzreqen29(&self) -> super::vals::Snzreqen29 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Snzreqen29::from_bits(val as u8)
            }
            #[doc = "Enable AGT1 compare match A snooze request"]
            #[inline(always)]
            pub fn set_snzreqen29(&mut self, val: super::vals::Snzreqen29) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Enable AGT1 compare match B snooze request"]
            #[inline(always)]
            pub const fn snzreqen30(&self) -> super::vals::Snzreqen30 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Snzreqen30::from_bits(val as u8)
            }
            #[doc = "Enable AGT1 compare match B snooze request"]
            #[inline(always)]
            pub fn set_snzreqen30(&mut self, val: super::vals::Snzreqen30) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Snzreqcr0 {
            #[inline(always)]
            fn default() -> Snzreqcr0 {
                Snzreqcr0(0)
            }
        }
        impl core::fmt::Debug for Snzreqcr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Snzreqcr0")
                    .field("snzreqen0", &self.snzreqen0())
                    .field("snzreqen1", &self.snzreqen1())
                    .field("snzreqen2", &self.snzreqen2())
                    .field("snzreqen3", &self.snzreqen3())
                    .field("snzreqen4", &self.snzreqen4())
                    .field("snzreqen5", &self.snzreqen5())
                    .field("snzreqen6", &self.snzreqen6())
                    .field("snzreqen7", &self.snzreqen7())
                    .field("snzreqen17", &self.snzreqen17())
                    .field("snzreqen28", &self.snzreqen28())
                    .field("snzreqen29", &self.snzreqen29())
                    .field("snzreqen30", &self.snzreqen30())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Snzreqcr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Snzreqcr0 {{ snzreqen0: {:?}, snzreqen1: {:?}, snzreqen2: {:?}, snzreqen3: {:?}, snzreqen4: {:?}, snzreqen5: {:?}, snzreqen6: {:?}, snzreqen7: {:?}, snzreqen17: {:?}, snzreqen28: {:?}, snzreqen29: {:?}, snzreqen30: {:?} }}" , self . snzreqen0 () , self . snzreqen1 () , self . snzreqen2 () , self . snzreqen3 () , self . snzreqen4 () , self . snzreqen5 () , self . snzreqen6 () , self . snzreqen7 () , self . snzreqen17 () , self . snzreqen28 () , self . snzreqen29 () , self . snzreqen30 ())
            }
        }
        #[doc = "Sub Operating Power Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sopccr(pub u8);
        impl Sopccr {
            #[doc = "Sub Operating Power Control Mode Select"]
            #[inline(always)]
            pub const fn sopcm(&self) -> super::vals::Sopcm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sopcm::from_bits(val as u8)
            }
            #[doc = "Sub Operating Power Control Mode Select"]
            #[inline(always)]
            pub fn set_sopcm(&mut self, val: super::vals::Sopcm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u8) & 0x01) << 0usize);
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub const fn sopcmtsf(&self) -> super::vals::Sopcmtsf {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sopcmtsf::from_bits(val as u8)
            }
            #[doc = "Operating Power Control Mode Transition Status Flag"]
            #[inline(always)]
            pub fn set_sopcmtsf(&mut self, val: super::vals::Sopcmtsf) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u8) & 0x01) << 4usize);
            }
        }
        impl Default for Sopccr {
            #[inline(always)]
            fn default() -> Sopccr {
                Sopccr(0)
            }
        }
        impl core::fmt::Debug for Sopccr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sopccr")
                    .field("sopcm", &self.sopcm())
                    .field("sopcmtsf", &self.sopcmtsf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sopccr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Sopccr {{ sopcm: {:?}, sopcmtsf: {:?} }}",
                    self.sopcm(),
                    self.sopcmtsf()
                )
            }
        }
        #[doc = "System Control OCD Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syocdcr(pub u8);
        impl Syocdcr {
            #[doc = "Debugger Enable bit"]
            #[inline(always)]
            pub const fn dbgen(&self) -> super::vals::Dbgen {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dbgen::from_bits(val as u8)
            }
            #[doc = "Debugger Enable bit"]
            #[inline(always)]
            pub fn set_dbgen(&mut self, val: super::vals::Dbgen) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Syocdcr {
            #[inline(always)]
            fn default() -> Syocdcr {
                Syocdcr(0)
            }
        }
        impl core::fmt::Debug for Syocdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syocdcr")
                    .field("dbgen", &self.dbgen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syocdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Syocdcr {{ dbgen: {:?} }}", self.dbgen())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ad0mated {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ad0mated {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ad0mated {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ad0mated {
            #[inline(always)]
            fn from(val: u8) -> Ad0mated {
                Ad0mated::from_bits(val)
            }
        }
        impl From<Ad0mated> for u8 {
            #[inline(always)]
            fn from(val: Ad0mated) -> u8 {
                Ad0mated::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ad0umted {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ad0umted {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ad0umted {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ad0umted {
            #[inline(always)]
            fn from(val: u8) -> Ad0umted {
                Ad0umted::from_bits(val)
            }
        }
        impl From<Ad0umted> for u8 {
            #[inline(always)]
            fn from(val: Ad0umted) -> u8 {
                Ad0umted::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Agtunfed {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Agtunfed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Agtunfed {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Agtunfed {
            #[inline(always)]
            fn from(val: u8) -> Agtunfed {
                Agtunfed::from_bits(val)
            }
        }
        impl From<Agtunfed> for u8 {
            #[inline(always)]
            fn from(val: Agtunfed) -> u8 {
                Agtunfed::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bpfclkdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bpfclkdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bpfclkdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bpfclkdis {
            #[inline(always)]
            fn from(val: u8) -> Bpfclkdis {
                Bpfclkdis::from_bits(val)
            }
        }
        impl From<Bpfclkdis> for u8 {
            #[inline(always)]
            fn from(val: Bpfclkdis) -> u8 {
                Bpfclkdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busmrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Busmrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busmrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busmrf {
            #[inline(always)]
            fn from(val: u8) -> Busmrf {
                Busmrf::from_bits(val)
            }
        }
        impl From<Busmrf> for u8 {
            #[inline(always)]
            fn from(val: Busmrf) -> u8 {
                Busmrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bussrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Bussrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bussrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bussrf {
            #[inline(always)]
            fn from(val: u8) -> Bussrf {
                Bussrf::from_bits(val)
            }
        }
        impl From<Bussrf> for u8 {
            #[inline(always)]
            fn from(val: Bussrf) -> u8 {
                Bussrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckodiv {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ckodiv {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckodiv {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckodiv {
            #[inline(always)]
            fn from(val: u8) -> Ckodiv {
                Ckodiv::from_bits(val)
            }
        }
        impl From<Ckodiv> for u8 {
            #[inline(always)]
            fn from(val: Ckodiv) -> u8 {
                Ckodiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckoen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ckoen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckoen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckoen {
            #[inline(always)]
            fn from(val: u8) -> Ckoen {
                Ckoen::from_bits(val)
            }
        }
        impl From<Ckoen> for u8 {
            #[inline(always)]
            fn from(val: Ckoen) -> u8 {
                Ckoen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ckosel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ckosel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ckosel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ckosel {
            #[inline(always)]
            fn from(val: u8) -> Ckosel {
                Ckosel::from_bits(val)
            }
        }
        impl From<Ckosel> for u8 {
            #[inline(always)]
            fn from(val: Ckosel) -> u8 {
                Ckosel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cksel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cksel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cksel {
            #[inline(always)]
            fn from(val: u8) -> Cksel {
                Cksel::from_bits(val)
            }
        }
        impl From<Cksel> for u8 {
            #[inline(always)]
            fn from(val: Cksel) -> u8 {
                Cksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cwsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Cwsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cwsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cwsf {
            #[inline(always)]
            fn from(val: u8) -> Cwsf {
                Cwsf::from_bits(val)
            }
        }
        impl From<Cwsf> for u8 {
            #[inline(always)]
            fn from(val: Cwsf) -> u8 {
                Cwsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dbgen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dbgen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dbgen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dbgen {
            #[inline(always)]
            fn from(val: u8) -> Dbgen {
                Dbgen::from_bits(val)
            }
        }
        impl From<Dbgen> for u8 {
            #[inline(always)]
            fn from(val: Dbgen) -> u8 {
                Dbgen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dclkdis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dclkdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dclkdis {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dclkdis {
            #[inline(always)]
            fn from(val: u8) -> Dclkdis {
                Dclkdis::from_bits(val)
            }
        }
        impl From<Dclkdis> for u8 {
            #[inline(always)]
            fn from(val: Dclkdis) -> u8 {
                Dclkdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtcnzred {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtcnzred {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtcnzred {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtcnzred {
            #[inline(always)]
            fn from(val: u8) -> Dtcnzred {
                Dtcnzred::from_bits(val)
            }
        }
        impl From<Dtcnzred> for u8 {
            #[inline(always)]
            fn from(val: Dtcnzred) -> u8 {
                Dtcnzred::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dtczred {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Dtczred {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dtczred {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dtczred {
            #[inline(always)]
            fn from(val: u8) -> Dtczred {
                Dtczred::from_bits(val)
            }
        }
        impl From<Dtczred> for u8 {
            #[inline(always)]
            fn from(val: Dtczred) -> u8 {
                Dtczred::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hcstp {
            #[inline(always)]
            fn from(val: u8) -> Hcstp {
                Hcstp::from_bits(val)
            }
        }
        impl From<Hcstp> for u8 {
            #[inline(always)]
            fn from(val: Hcstp) -> u8 {
                Hcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hocosf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Hocosf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hocosf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hocosf {
            #[inline(always)]
            fn from(val: u8) -> Hocosf {
                Hocosf::from_bits(val)
            }
        }
        impl From<Hocosf> for u8 {
            #[inline(always)]
            fn from(val: Hocosf) -> u8 {
                Hocosf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hsts {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Hsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hsts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hsts {
            #[inline(always)]
            fn from(val: u8) -> Hsts {
                Hsts::from_bits(val)
            }
        }
        impl From<Hsts> for u8 {
            #[inline(always)]
            fn from(val: Hsts) -> u8 {
                Hsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ick {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ick {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ick {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ick {
            #[inline(always)]
            fn from(val: u8) -> Ick {
                Ick::from_bits(val)
            }
        }
        impl From<Ick> for u8 {
            #[inline(always)]
            fn from(val: Ick) -> u8 {
                Ick::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iwdtrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Iwdtrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iwdtrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iwdtrf {
            #[inline(always)]
            fn from(val: u8) -> Iwdtrf {
                Iwdtrf::from_bits(val)
            }
        }
        impl From<Iwdtrf> for u8 {
            #[inline(always)]
            fn from(val: Iwdtrf) -> u8 {
                Iwdtrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcstp {
            #[inline(always)]
            fn from(val: u8) -> Lcstp {
                Lcstp::from_bits(val)
            }
        }
        impl From<Lcstp> for u8 {
            #[inline(always)]
            fn from(val: Lcstp) -> u8 {
                Lcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpopten {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lpopten {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpopten {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpopten {
            #[inline(always)]
            fn from(val: u8) -> Lpopten {
                Lpopten::from_bits(val)
            }
        }
        impl From<Lpopten> for u8 {
            #[inline(always)]
            fn from(val: Lpopten) -> u8 {
                Lpopten::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd0rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd0rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd0rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd0rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd0rf {
                Lvd0rf::from_bits(val)
            }
        }
        impl From<Lvd0rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd0rf) -> u8 {
                Lvd0rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Cmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Cmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Cmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Cmpe {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Cmpe {
                Lvd1cr0Cmpe::from_bits(val)
            }
        }
        impl From<Lvd1cr0Cmpe> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Cmpe) -> u8 {
                Lvd1cr0Cmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Ri {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Ri {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Ri {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Ri {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Ri {
                Lvd1cr0Ri::from_bits(val)
            }
        }
        impl From<Lvd1cr0Ri> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Ri) -> u8 {
                Lvd1cr0Ri::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Rie {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Rie {
                Lvd1cr0Rie::from_bits(val)
            }
        }
        impl From<Lvd1cr0Rie> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Rie) -> u8 {
                Lvd1cr0Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr0Rn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr0Rn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr0Rn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr0Rn {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr0Rn {
                Lvd1cr0Rn::from_bits(val)
            }
        }
        impl From<Lvd1cr0Rn> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr0Rn) -> u8 {
                Lvd1cr0Rn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr1Idtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lvd1cr1Idtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr1Idtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr1Idtsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr1Idtsel {
                Lvd1cr1Idtsel::from_bits(val)
            }
        }
        impl From<Lvd1cr1Idtsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr1Idtsel) -> u8 {
                Lvd1cr1Idtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1cr1Irqsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1cr1Irqsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1cr1Irqsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1cr1Irqsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd1cr1Irqsel {
                Lvd1cr1Irqsel::from_bits(val)
            }
        }
        impl From<Lvd1cr1Irqsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd1cr1Irqsel) -> u8 {
                Lvd1cr1Irqsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1e {
            #[inline(always)]
            fn from(val: u8) -> Lvd1e {
                Lvd1e::from_bits(val)
            }
        }
        impl From<Lvd1e> for u8 {
            #[inline(always)]
            fn from(val: Lvd1e) -> u8 {
                Lvd1e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1lvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Lvd1lvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1lvl {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1lvl {
            #[inline(always)]
            fn from(val: u8) -> Lvd1lvl {
                Lvd1lvl::from_bits(val)
            }
        }
        impl From<Lvd1lvl> for u8 {
            #[inline(always)]
            fn from(val: Lvd1lvl) -> u8 {
                Lvd1lvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd1rf {
                Lvd1rf::from_bits(val)
            }
        }
        impl From<Lvd1rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd1rf) -> u8 {
                Lvd1rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1srDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1srDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1srDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1srDet {
            #[inline(always)]
            fn from(val: u8) -> Lvd1srDet {
                Lvd1srDet::from_bits(val)
            }
        }
        impl From<Lvd1srDet> for u8 {
            #[inline(always)]
            fn from(val: Lvd1srDet) -> u8 {
                Lvd1srDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd1srMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd1srMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd1srMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd1srMon {
            #[inline(always)]
            fn from(val: u8) -> Lvd1srMon {
                Lvd1srMon::from_bits(val)
            }
        }
        impl From<Lvd1srMon> for u8 {
            #[inline(always)]
            fn from(val: Lvd1srMon) -> u8 {
                Lvd1srMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Cmpe {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Cmpe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Cmpe {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Cmpe {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Cmpe {
                Lvd2cr0Cmpe::from_bits(val)
            }
        }
        impl From<Lvd2cr0Cmpe> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Cmpe) -> u8 {
                Lvd2cr0Cmpe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Ri {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Ri {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Ri {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Ri {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Ri {
                Lvd2cr0Ri::from_bits(val)
            }
        }
        impl From<Lvd2cr0Ri> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Ri) -> u8 {
                Lvd2cr0Ri::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Rie {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Rie {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Rie {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Rie {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Rie {
                Lvd2cr0Rie::from_bits(val)
            }
        }
        impl From<Lvd2cr0Rie> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Rie) -> u8 {
                Lvd2cr0Rie::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr0Rn {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr0Rn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr0Rn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr0Rn {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr0Rn {
                Lvd2cr0Rn::from_bits(val)
            }
        }
        impl From<Lvd2cr0Rn> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr0Rn) -> u8 {
                Lvd2cr0Rn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr1Idtsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lvd2cr1Idtsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr1Idtsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr1Idtsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr1Idtsel {
                Lvd2cr1Idtsel::from_bits(val)
            }
        }
        impl From<Lvd2cr1Idtsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr1Idtsel) -> u8 {
                Lvd2cr1Idtsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2cr1Irqsel {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2cr1Irqsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2cr1Irqsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2cr1Irqsel {
            #[inline(always)]
            fn from(val: u8) -> Lvd2cr1Irqsel {
                Lvd2cr1Irqsel::from_bits(val)
            }
        }
        impl From<Lvd2cr1Irqsel> for u8 {
            #[inline(always)]
            fn from(val: Lvd2cr1Irqsel) -> u8 {
                Lvd2cr1Irqsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2e {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2e {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2e {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2e {
            #[inline(always)]
            fn from(val: u8) -> Lvd2e {
                Lvd2e::from_bits(val)
            }
        }
        impl From<Lvd2e> for u8 {
            #[inline(always)]
            fn from(val: Lvd2e) -> u8 {
                Lvd2e::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2lvl {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Lvd2lvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2lvl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2lvl {
            #[inline(always)]
            fn from(val: u8) -> Lvd2lvl {
                Lvd2lvl::from_bits(val)
            }
        }
        impl From<Lvd2lvl> for u8 {
            #[inline(always)]
            fn from(val: Lvd2lvl) -> u8 {
                Lvd2lvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2rf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2rf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2rf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2rf {
            #[inline(always)]
            fn from(val: u8) -> Lvd2rf {
                Lvd2rf::from_bits(val)
            }
        }
        impl From<Lvd2rf> for u8 {
            #[inline(always)]
            fn from(val: Lvd2rf) -> u8 {
                Lvd2rf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2srDet {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2srDet {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2srDet {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2srDet {
            #[inline(always)]
            fn from(val: u8) -> Lvd2srDet {
                Lvd2srDet::from_bits(val)
            }
        }
        impl From<Lvd2srDet> for u8 {
            #[inline(always)]
            fn from(val: Lvd2srDet) -> u8 {
                Lvd2srDet::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lvd2srMon {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Lvd2srMon {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lvd2srMon {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lvd2srMon {
            #[inline(always)]
            fn from(val: u8) -> Lvd2srMon {
                Lvd2srMon::from_bits(val)
            }
        }
        impl From<Lvd2srMon> for u8 {
            #[inline(always)]
            fn from(val: Lvd2srMon) -> u8 {
                Lvd2srMon::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mcstp {
            #[inline(always)]
            fn from(val: u8) -> Mcstp {
                Mcstp::from_bits(val)
            }
        }
        impl From<Mcstp> for u8 {
            #[inline(always)]
            fn from(val: Mcstp) -> u8 {
                Mcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Memwait {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Memwait {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Memwait {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Memwait {
            #[inline(always)]
            fn from(val: u8) -> Memwait {
                Memwait::from_bits(val)
            }
        }
        impl From<Memwait> for u8 {
            #[inline(always)]
            fn from(val: Memwait) -> u8 {
                Memwait::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mpudis {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mpudis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mpudis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mpudis {
            #[inline(always)]
            fn from(val: u8) -> Mpudis {
                Mpudis::from_bits(val)
            }
        }
        impl From<Mpudis> for u8 {
            #[inline(always)]
            fn from(val: Mpudis) -> u8 {
                Mpudis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mstpa22 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Mstpa22 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mstpa22 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mstpa22 {
            #[inline(always)]
            fn from(val: u8) -> Mstpa22 {
                Mstpa22::from_bits(val)
            }
        }
        impl From<Mstpa22> for u8 {
            #[inline(always)]
            fn from(val: Mstpa22) -> u8 {
                Mstpa22::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opcm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Opcm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opcm {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opcm {
            #[inline(always)]
            fn from(val: u8) -> Opcm {
                Opcm::from_bits(val)
            }
        }
        impl From<Opcm> for u8 {
            #[inline(always)]
            fn from(val: Opcm) -> u8 {
                Opcm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opcmtsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Opcmtsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opcmtsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opcmtsf {
            #[inline(always)]
            fn from(val: u8) -> Opcmtsf {
                Opcmtsf::from_bits(val)
            }
        }
        impl From<Opcmtsf> for u8 {
            #[inline(always)]
            fn from(val: Opcmtsf) -> u8 {
                Opcmtsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pckb {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pckb {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pckb {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pckb {
            #[inline(always)]
            fn from(val: u8) -> Pckb {
                Pckb::from_bits(val)
            }
        }
        impl From<Pckb> for u8 {
            #[inline(always)]
            fn from(val: Pckb) -> u8 {
                Pckb::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pckd {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pckd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pckd {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pckd {
            #[inline(always)]
            fn from(val: u8) -> Pckd {
                Pckd::from_bits(val)
            }
        }
        impl From<Pckd> for u8 {
            #[inline(always)]
            fn from(val: Pckd) -> u8 {
                Pckd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Porf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Porf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Porf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Porf {
            #[inline(always)]
            fn from(val: u8) -> Porf {
                Porf::from_bits(val)
            }
        }
        impl From<Porf> for u8 {
            #[inline(always)]
            fn from(val: Porf) -> u8 {
                Porf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc0 {
            #[inline(always)]
            fn from(val: u8) -> Prc0 {
                Prc0::from_bits(val)
            }
        }
        impl From<Prc0> for u8 {
            #[inline(always)]
            fn from(val: Prc0) -> u8 {
                Prc0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc1 {
            #[inline(always)]
            fn from(val: u8) -> Prc1 {
                Prc1::from_bits(val)
            }
        }
        impl From<Prc1> for u8 {
            #[inline(always)]
            fn from(val: Prc1) -> u8 {
                Prc1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prc3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Prc3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prc3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prc3 {
            #[inline(always)]
            fn from(val: u8) -> Prc3 {
                Prc3::from_bits(val)
            }
        }
        impl From<Prc3> for u8 {
            #[inline(always)]
            fn from(val: Prc3) -> u8 {
                Prc3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psmc {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Psmc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psmc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psmc {
            #[inline(always)]
            fn from(val: u8) -> Psmc {
                Psmc::from_bits(val)
            }
        }
        impl From<Psmc> for u8 {
            #[inline(always)]
            fn from(val: Psmc) -> u8 {
                Psmc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rperf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rperf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rperf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rperf {
            #[inline(always)]
            fn from(val: u8) -> Rperf {
                Rperf::from_bits(val)
            }
        }
        impl From<Rperf> for u8 {
            #[inline(always)]
            fn from(val: Rperf) -> u8 {
                Rperf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzdtcen {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzdtcen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzdtcen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzdtcen {
            #[inline(always)]
            fn from(val: u8) -> Snzdtcen {
                Snzdtcen::from_bits(val)
            }
        }
        impl From<Snzdtcen> for u8 {
            #[inline(always)]
            fn from(val: Snzdtcen) -> u8 {
                Snzdtcen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snze {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snze {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snze {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snze {
            #[inline(always)]
            fn from(val: u8) -> Snze {
                Snze::from_bits(val)
            }
        }
        impl From<Snze> for u8 {
            #[inline(always)]
            fn from(val: Snze) -> u8 {
                Snze::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen0 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen0 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen0 {
                Snzreqen0::from_bits(val)
            }
        }
        impl From<Snzreqen0> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen0) -> u8 {
                Snzreqen0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen1 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen1 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen1 {
                Snzreqen1::from_bits(val)
            }
        }
        impl From<Snzreqen1> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen1) -> u8 {
                Snzreqen1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen17 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen17 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen17 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen17 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen17 {
                Snzreqen17::from_bits(val)
            }
        }
        impl From<Snzreqen17> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen17) -> u8 {
                Snzreqen17::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen2 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen2 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen2 {
                Snzreqen2::from_bits(val)
            }
        }
        impl From<Snzreqen2> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen2) -> u8 {
                Snzreqen2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen28 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen28 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen28 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen28 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen28 {
                Snzreqen28::from_bits(val)
            }
        }
        impl From<Snzreqen28> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen28) -> u8 {
                Snzreqen28::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen29 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen29 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen29 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen29 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen29 {
                Snzreqen29::from_bits(val)
            }
        }
        impl From<Snzreqen29> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen29) -> u8 {
                Snzreqen29::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen3 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen3 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen3 {
                Snzreqen3::from_bits(val)
            }
        }
        impl From<Snzreqen3> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen3) -> u8 {
                Snzreqen3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen30 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen30 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen30 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen30 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen30 {
                Snzreqen30::from_bits(val)
            }
        }
        impl From<Snzreqen30> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen30) -> u8 {
                Snzreqen30::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen4 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen4 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen4 {
                Snzreqen4::from_bits(val)
            }
        }
        impl From<Snzreqen4> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen4) -> u8 {
                Snzreqen4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen5 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen5 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen5 {
                Snzreqen5::from_bits(val)
            }
        }
        impl From<Snzreqen5> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen5) -> u8 {
                Snzreqen5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen6 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen6 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen6 {
                Snzreqen6::from_bits(val)
            }
        }
        impl From<Snzreqen6> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen6) -> u8 {
                Snzreqen6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snzreqen7 {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Snzreqen7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snzreqen7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snzreqen7 {
            #[inline(always)]
            fn from(val: u8) -> Snzreqen7 {
                Snzreqen7::from_bits(val)
            }
        }
        impl From<Snzreqen7> for u8 {
            #[inline(always)]
            fn from(val: Snzreqen7) -> u8 {
                Snzreqen7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sopcm {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sopcm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sopcm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sopcm {
            #[inline(always)]
            fn from(val: u8) -> Sopcm {
                Sopcm::from_bits(val)
            }
        }
        impl From<Sopcm> for u8 {
            #[inline(always)]
            fn from(val: Sopcm) -> u8 {
                Sopcm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sopcmtsf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sopcmtsf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sopcmtsf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sopcmtsf {
            #[inline(always)]
            fn from(val: u8) -> Sopcmtsf {
                Sopcmtsf::from_bits(val)
            }
        }
        impl From<Sopcmtsf> for u8 {
            #[inline(always)]
            fn from(val: Sopcmtsf) -> u8 {
                Sopcmtsf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sperf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Sperf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sperf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sperf {
            #[inline(always)]
            fn from(val: u8) -> Sperf {
                Sperf::from_bits(val)
            }
        }
        impl From<Sperf> for u8 {
            #[inline(always)]
            fn from(val: Sperf) -> u8 {
                Sperf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssby {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Ssby {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssby {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssby {
            #[inline(always)]
            fn from(val: u8) -> Ssby {
                Ssby::from_bits(val)
            }
        }
        impl From<Ssby> for u8 {
            #[inline(always)]
            fn from(val: Ssby) -> u8 {
                Ssby::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Swrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swrf {
            #[inline(always)]
            fn from(val: u8) -> Swrf {
                Swrf::from_bits(val)
            }
        }
        impl From<Swrf> for u8 {
            #[inline(always)]
            fn from(val: Swrf) -> u8 {
                Swrf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wdtrf {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Wdtrf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wdtrf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wdtrf {
            #[inline(always)]
            fn from(val: u8) -> Wdtrf {
                Wdtrf::from_bits(val)
            }
        }
        impl From<Wdtrf> for u8 {
            #[inline(always)]
            fn from(val: Wdtrf) -> u8 {
                Wdtrf::to_bits(val)
            }
        }
    }
}
pub mod wdt {
    #[doc = "Watchdog Timer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "WDT Refresh Register"]
        #[inline(always)]
        pub const fn wdtrr(self) -> crate::common::Reg<u8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "WDT Control Register"]
        #[inline(always)]
        pub const fn wdtcr(self) -> crate::common::Reg<regs::Wdtcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02usize) as _) }
        }
        #[doc = "WDT Status Register"]
        #[inline(always)]
        pub const fn wdtsr(self) -> crate::common::Reg<regs::Wdtsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "WDT Reset Control Register"]
        #[inline(always)]
        pub const fn wdtrcr(self) -> crate::common::Reg<regs::Wdtrcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06usize) as _) }
        }
        #[doc = "WDT Count Stop Control Register"]
        #[inline(always)]
        pub const fn wdtcstpr(self) -> crate::common::Reg<regs::Wdtcstpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "WDT Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtcr(pub u16);
        impl Wdtcr {
            #[doc = "Timeout Period Select"]
            #[inline(always)]
            pub const fn tops(&self) -> super::vals::Tops {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Tops::from_bits(val as u8)
            }
            #[doc = "Timeout Period Select"]
            #[inline(always)]
            pub fn set_tops(&mut self, val: super::vals::Tops) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u16) & 0x03) << 0usize);
            }
            #[doc = "Clock Division Ratio Select"]
            #[inline(always)]
            pub const fn cks(&self) -> super::vals::Cks {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Cks::from_bits(val as u8)
            }
            #[doc = "Clock Division Ratio Select"]
            #[inline(always)]
            pub fn set_cks(&mut self, val: super::vals::Cks) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u16) & 0x0f) << 4usize);
            }
            #[doc = "Window End Position Select"]
            #[inline(always)]
            pub const fn rpes(&self) -> super::vals::Rpes {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Rpes::from_bits(val as u8)
            }
            #[doc = "Window End Position Select"]
            #[inline(always)]
            pub fn set_rpes(&mut self, val: super::vals::Rpes) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u16) & 0x03) << 8usize);
            }
            #[doc = "Window Start Position Select"]
            #[inline(always)]
            pub const fn rpss(&self) -> super::vals::Rpss {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Rpss::from_bits(val as u8)
            }
            #[doc = "Window Start Position Select"]
            #[inline(always)]
            pub fn set_rpss(&mut self, val: super::vals::Rpss) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u16) & 0x03) << 12usize);
            }
        }
        impl Default for Wdtcr {
            #[inline(always)]
            fn default() -> Wdtcr {
                Wdtcr(0)
            }
        }
        impl core::fmt::Debug for Wdtcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtcr")
                    .field("tops", &self.tops())
                    .field("cks", &self.cks())
                    .field("rpes", &self.rpes())
                    .field("rpss", &self.rpss())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Wdtcr {{ tops: {:?}, cks: {:?}, rpes: {:?}, rpss: {:?} }}",
                    self.tops(),
                    self.cks(),
                    self.rpes(),
                    self.rpss()
                )
            }
        }
        #[doc = "WDT Count Stop Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtcstpr(pub u8);
        impl Wdtcstpr {
            #[doc = "Sleep,Mode Count Stop Control Register"]
            #[inline(always)]
            pub const fn slcstp(&self) -> super::vals::Slcstp {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Slcstp::from_bits(val as u8)
            }
            #[doc = "Sleep,Mode Count Stop Control Register"]
            #[inline(always)]
            pub fn set_slcstp(&mut self, val: super::vals::Slcstp) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Wdtcstpr {
            #[inline(always)]
            fn default() -> Wdtcstpr {
                Wdtcstpr(0)
            }
        }
        impl core::fmt::Debug for Wdtcstpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtcstpr")
                    .field("slcstp", &self.slcstp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtcstpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Wdtcstpr {{ slcstp: {:?} }}", self.slcstp())
            }
        }
        #[doc = "WDT Reset Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtrcr(pub u8);
        impl Wdtrcr {
            #[doc = "WDT Behavior Selection"]
            #[inline(always)]
            pub const fn rstirqs(&self) -> super::vals::Rstirqs {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Rstirqs::from_bits(val as u8)
            }
            #[doc = "WDT Behavior Selection"]
            #[inline(always)]
            pub fn set_rstirqs(&mut self, val: super::vals::Rstirqs) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u8) & 0x01) << 7usize);
            }
        }
        impl Default for Wdtrcr {
            #[inline(always)]
            fn default() -> Wdtrcr {
                Wdtrcr(0)
            }
        }
        impl core::fmt::Debug for Wdtrcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtrcr")
                    .field("rstirqs", &self.rstirqs())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtrcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Wdtrcr {{ rstirqs: {:?} }}", self.rstirqs())
            }
        }
        #[doc = "WDT Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Wdtsr(pub u16);
        impl Wdtsr {
            #[doc = "Down,Counter Value"]
            #[inline(always)]
            pub const fn cntval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Down,Counter Value"]
            #[inline(always)]
            pub fn set_cntval(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u16) & 0x3fff) << 0usize);
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub const fn undff(&self) -> super::vals::Undff {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Undff::from_bits(val as u8)
            }
            #[doc = "Underflow Flag"]
            #[inline(always)]
            pub fn set_undff(&mut self, val: super::vals::Undff) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u16) & 0x01) << 14usize);
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub const fn refef(&self) -> super::vals::Refef {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Refef::from_bits(val as u8)
            }
            #[doc = "Refresh Error Flag"]
            #[inline(always)]
            pub fn set_refef(&mut self, val: super::vals::Refef) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u16) & 0x01) << 15usize);
            }
        }
        impl Default for Wdtsr {
            #[inline(always)]
            fn default() -> Wdtsr {
                Wdtsr(0)
            }
        }
        impl core::fmt::Debug for Wdtsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Wdtsr")
                    .field("cntval", &self.cntval())
                    .field("undff", &self.undff())
                    .field("refef", &self.refef())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Wdtsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Wdtsr {{ cntval: {=u16:?}, undff: {:?}, refef: {:?} }}",
                    self.cntval(),
                    self.undff(),
                    self.refef()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cks {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Cks {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cks {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cks {
            #[inline(always)]
            fn from(val: u8) -> Cks {
                Cks::from_bits(val)
            }
        }
        impl From<Cks> for u8 {
            #[inline(always)]
            fn from(val: Cks) -> u8 {
                Cks::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refef {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Refef {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refef {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refef {
            #[inline(always)]
            fn from(val: u8) -> Refef {
                Refef::from_bits(val)
            }
        }
        impl From<Refef> for u8 {
            #[inline(always)]
            fn from(val: Refef) -> u8 {
                Refef::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpes {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rpes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpes {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpes {
            #[inline(always)]
            fn from(val: u8) -> Rpes {
                Rpes::from_bits(val)
            }
        }
        impl From<Rpes> for u8 {
            #[inline(always)]
            fn from(val: Rpes) -> u8 {
                Rpes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rpss {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rpss {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rpss {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rpss {
            #[inline(always)]
            fn from(val: u8) -> Rpss {
                Rpss::from_bits(val)
            }
        }
        impl From<Rpss> for u8 {
            #[inline(always)]
            fn from(val: Rpss) -> u8 {
                Rpss::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rstirqs {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Rstirqs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rstirqs {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rstirqs {
            #[inline(always)]
            fn from(val: u8) -> Rstirqs {
                Rstirqs::from_bits(val)
            }
        }
        impl From<Rstirqs> for u8 {
            #[inline(always)]
            fn from(val: Rstirqs) -> u8 {
                Rstirqs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slcstp {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Slcstp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slcstp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slcstp {
            #[inline(always)]
            fn from(val: u8) -> Slcstp {
                Slcstp::from_bits(val)
            }
        }
        impl From<Slcstp> for u8 {
            #[inline(always)]
            fn from(val: Slcstp) -> u8 {
                Slcstp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tops {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Tops {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tops {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tops {
            #[inline(always)]
            fn from(val: u8) -> Tops {
                Tops::from_bits(val)
            }
        }
        impl From<Tops> for u8 {
            #[inline(always)]
            fn from(val: Tops) -> u8 {
                Tops::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Undff {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
        }
        impl Undff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Undff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Undff {
            #[inline(always)]
            fn from(val: u8) -> Undff {
                Undff::from_bits(val)
            }
        }
        impl From<Undff> for u8 {
            #[inline(always)]
            fn from(val: Undff) -> u8 {
                Undff::to_bits(val)
            }
        }
    }
}
